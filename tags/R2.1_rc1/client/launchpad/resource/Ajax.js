//Build Ajax.js from client/ajax
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxCore() {}

AjxCore._objectIds = [null];


AjxCore.assignId = 
function(anObject) {
	var myId = AjxCore._objectIds.length;
	AjxCore._objectIds[myId]= anObject;
	return myId;
};

AjxCore.unassignId = 
function(anId) {
	AjxCore._objectIds[anId]= null;
};

AjxCore.objectWithId = 
function(anId) {
	return AjxCore._objectIds[anId];
};

/**
 * Adds a listener to an element, for the given event name.
 */
AjxCore.addListener = 
function(eventSource, eventName, action) {
	eventSource = AjxCore._getEventSource(eventSource);
	var listenerStruct = AjxCore._getListenerStruct(eventSource, eventName, true);
	listenerStruct.list[listenerStruct.list.length] = action;
};

/**
 * sets a one time event handler for the given eventName.
 */
AjxCore.setEventHandler = 
function(eventSource, eventName, action) {
	eventSource = AjxCore._getEventSource(eventSource);
	var listenerStruct = AjxCore._getListenerStruct(eventSource, eventName, true);
	listenerStruct.single = action;
};

/**
 * removes a listener for a given event
 */
AjxCore.removeListener = 
function(eventSource, eventName, action) {
	eventSource = AjxCore._getEventSource(eventSource);
	var listenerStruct = AjxCore._getListenerStruct(eventSource, eventName);

	if (listenerStruct) {
		var listenerList = listenerStruct.list;
		for (var i = 0; i < listenerList.length; i++) {
			if (listenerList[i] == action)
				listenerList[i] = null;
		}
	}
};

/**
 * removes all listeners for a given eventName, and source
 */
AjxCore.removeAllListeners = 
function(eventSource, eventName) {
	eventSource = AjxCore._getEventSource(eventSource);
	var listenerStruct = AjxCore._getListenerStruct(eventSource, eventName);

	if (listenerStruct) {
		var listenerList = listenerStruct.list;
		for (var i = 0; i < listenerList.length; i++)
			listenerList[i] = null;
	}
	AjxCore.unassignId(listenerStruct.id);
};

/**
 * notifies listeners of the event. This only needs to be called if
 * the event is not a standard DOM event. Those types of event callbacks
 * will be triggered by their event handlers
 */
AjxCore.notifyListeners = 
function(eventSource, eventName, arg1) {
	eventSource = AjxCore._getEventSource(eventSource);
	var listenerStruct = AjxCore._getListenerStruct(eventSource, eventName)
	if (listenerStruct)
		eventSource[eventName](arg1);
};

AjxCore._getEventSource = 
function(eventSource) {
	if (typeof(eventSource) == 'string')
		eventSource = document.getElementById(eventSource);
	return eventSource;
};

AjxCore.getListenerStruct = 
function (eventSource, eventName) {
	return AjxCore._getListenerStruct(eventSource, eventName);
};

/**
 * gets the existing struct for the eventSource, or creates a new one.
 */
AjxCore._getListenerStruct = 
function(eventSource, eventName, create) {
	var listenerStruct = null;
	if (eventSource[eventName]) {
		var id = eventSource[eventName]._lsListenerStructId;
		listenerStruct = AjxCore.objectWithId(id);
	} else if (create) {
		listenerStruct = AjxCore._setupListener(eventSource, eventName);
	}

	return listenerStruct;
};
    
/**
 * Creates a listener struct
 */
AjxCore._setupListener = 
function(eventSource, eventName, id) {
	var listenerStruct = new Object();
	listenerStruct.list = new Array();
	listenerStruct.single = null;
	var id = listenerStruct.id = AjxCore.assignId(listenerStruct);
	var handler = AjxCore._createListenerClosure(id);
	eventSource[eventName] = handler;
	eventSource[eventName]._lsListenerStructId = id;

	return listenerStruct;
};

AjxCore._createListenerClosure = 
function(id) {
	var closure = function(arg1) {
		var listenerStruct = AjxCore.objectWithId(id);
		var listenerList = listenerStruct.list;
		for (var i = 0; i < listenerList.length; i++) {
			var callback = listenerList[i];
			if (callback) {
				if (typeof(callback) == 'string') {
					eval(callback);
				} else {
					// handle AjxListener callbacks as well as simple functions
					if (callback.handleEvent) {
						callback.handleEvent(arg1, this);
					} else {
						callback(arg1, this);
					}
				}
			}
		}
        if (listenerStruct.single) {
			var callback = listenerStruct.single;
			if (typeof(callback) == 'string') {
				eval(callback);
			} else {
				return callback.handleEvent
					? callback.handleEvent(arg1, this)
					: callback(arg1, this);
			}
		}
	}
	return closure;
};

/**
 * Convenience method for adding onload listeners
 */
AjxCore.addOnloadListener = 
function(action) {
	if (window.onload && (!window.onload._lsListenerStructId)) {
		var priorListener = window.onload;
		window.onload = null;
		AjxCore.addListener(window, "onload", priorListener);
	}

	AjxCore.addListener(window, "onload", action);
};

/**
 * Convenience method for adding onunload listeners
 */    
AjxCore.addOnunloadListener = 
function(action) {
	if (window.onunload && (!window.onunload._lsListenerStructId)) {
		var priorListener = window.onunload;
		window.onunload = null;
		AjxCore.addListener(window, "onunload", priorListener);
	}

	AjxCore.addListener(window, "onunload", action);
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxEnv() {
}

AjxEnv._inited = false;


AjxEnv.reset = function () {
	AjxEnv.browserVersion = -1;
	AjxEnv.geckoDate = 0;
	AjxEnv.mozVersion = -1;
	AjxEnv.isMac = false;
	AjxEnv.isWindows = false;
	AjxEnv.isLinux = false;
	AjxEnv.isNav  = false;
	AjxEnv.isIE = false;
	AjxEnv.isNav4 = false;
	AjxEnv.trueNs = true;
	AjxEnv.isNav6 = false;
	AjxEnv.isNav6up = false;
	AjxEnv.isNav7 = false;
	AjxEnv.isIE3 = false;
	AjxEnv.isIE4 = false;
	AjxEnv.isIE4up = false;
	AjxEnv.isIE5 = false;
	AjxEnv.isIE5_5 = false;
	AjxEnv.isIE5up = false;
	AjxEnv.isIE5_5up = false;
	AjxEnv.isIE6  = false;
	AjxEnv.isIE6up = false;
	AjxEnv.isNormalResolution = false;
	AjxEnv.ieScaleFactor = 1;
	AjxEnv.isFirefox = false;
	AjxEnv.isFirefox1up = false;
	AjxEnv.isFirefox1_5up = false;
	AjxEnv.isMozilla = false;
	AjxEnv.isMozilla1_4up = false;
	AjxEnv.isSafari = false;
	AjxEnv.isGeckoBased = false;
	AjxEnv.isOpera = false;
	AjxEnv.useTransparentPNGs = false;

	// screen resolution - ADD MORE RESOLUTION CHECKS AS NEEDED HERE:
	AjxEnv.is800x600orLower = screen.width <= 800 && screen.height <= 600;
};

AjxEnv.parseUA = function (userAgent) {
	var agt = userAgent.toLowerCase();
	var agtArr = agt.split(" ");
	var i = 0;
	var index = -1;
	var token = null;
	var isSpoofer = false;
	var isWebTv = false;
	var isHotJava = false;
	var beginsWithMozilla = false;
	var isCompatible = false;
	if (agtArr != null) {
		if ( (index = agtArr[0].search(/^\s*mozilla\//) )!= -1){
			beginsWithMozilla = true;
			AjxEnv.browserVersion = parseFloat(agtArr[0].substring(index + 8));
			AjxEnv.isNav = true;
		}
		for ( ; i < agtArr.length; ++i ){
			token = agtArr[i];
			if (token.indexOf('compatible') != -1 ) {
				isCompatible = true;
				AjxEnv.isNav = false;
			} else if ((token.indexOf('opera')) != -1){
				AjxEnv.isOpera = true;
				AjxEnv.isNav = false;
				AjxEnv.browserVersion = parseFloat(agtArr[i+1]);
			} else if ((token.indexOf('spoofer')) != -1){
				isSpoofer = true;
				AjxEnv.isNav = false;
			} else if ((token.indexOf('webtv')) != -1) {
				isWebTv = true;
				AjxEnv.isNav = false;
			} else if ((token.indexOf('hotjava')) != -1) {
				isHotJava = true;
				AjxEnv.isNav = false;
			} else if ((index = token.indexOf('msie')) != -1) {
				AjxEnv.isIE = true;
				AjxEnv.browserVersion = parseFloat(agtArr[i+1]);
			} else if ((index = token.indexOf('gecko/')) != -1){
				AjxEnv.isGeckoBased = true;
				AjxEnv.geckoDate = parseFloat(token.substr(index + 6));
			} else if ((index = token.indexOf('rv:')) != -1){
				AjxEnv.mozVersion = parseFloat(token.substr(index + 3));
				AjxEnv.browserVersion = AjxEnv.mozVersion;
			} else if ((index = token.indexOf('firefox/')) != -1){
				AjxEnv.isFirefox = true;
				AjxEnv.browserVersion = parseFloat(token.substr(index + 8));
			} else if ((index = token.indexOf('netscape6/')) != -1){
				AjxEnv.trueNs = true;
				AjxEnv.browserVersion = parseFloat(token.substr(index + 10));
			} else if ((index = token.indexOf('netscape/')) != -1){
				AjxEnv.trueNs = true;
				AjxEnv.browserVersion = parseFloat(token.substr(index + 9));
			} else if ((index = token.indexOf('safari/')) != -1){
				AjxEnv.isSafari = true;
				AjxEnv.browserVersion = parseFloat(token.substr(index + 7));
			} else if (token.indexOf('windows') != -1){
				AjxEnv.isWindows = true;
			} else if ((token.indexOf('macintosh') != -1) ||
					   (token.indexOf('mac_') != -1)){
				AjxEnv.isMac = true;
			} else if (token.indexOf('linux') != -1){
				AjxEnv.isLinux = true;
			}
		}
		// Note: Opera and WebTV spoof Navigator.  
		// We do strict client detection.
		AjxEnv.isNav  = (beginsWithMozilla && !isSpoofer && !isCompatible && 
						!AjxEnv.isOpera && !isWebTv && !isHotJava &&
						!AjxEnv.isSafari);

		AjxEnv.isIE = (AjxEnv.isIE && !AjxEnv.isOpera);

		AjxEnv.isNav4 = (AjxEnv.isNav && (AjxEnv.browserVersion  == 4) &&
						(!AjxEnv.isIE));
		AjxEnv.isNav6 = (AjxEnv.isNav && AjxEnv.trueNs && 
						(AjxEnv.browserVersion >=6.0) && 
						(AjxEnv.browserVersion < 7.0));
		AjxEnv.isNav6up = (AjxEnv.isNav && AjxEnv.trueNs && 
						  (AjxEnv.browserVersion >= 6.0));
		AjxEnv.isNav7 = (AjxEnv.isNav && AjxEnv.trueNs && 
						(AjxEnv.browserVersion == 7.0));

		AjxEnv.isIE3 = (AjxEnv.isIE && (AjxEnv.browserVersion < 4));
		AjxEnv.isIE4 = (AjxEnv.isIE && (AjxEnv.browserVersion == 4) && 
					 (AjxEnv.browserVersion == 4.0));
		AjxEnv.isIE4up = (AjxEnv.isIE && (AjxEnv.browserVersion >= 4));
		AjxEnv.isIE5 = (AjxEnv.isIE && (AjxEnv.browserVersion == 4) && 
					 (AjxEnv.browserVersion == 5.0));
		AjxEnv.isIE5_5 = (AjxEnv.isIE && (AjxEnv.browserVersion == 4) && 
						 (AjxEnv.browserVersion == 5.5));
		AjxEnv.isIE5up = (AjxEnv.isIE && (AjxEnv.browserVersion >= 5.0));
		AjxEnv.isIE5_5up =(AjxEnv.isIE && (AjxEnv.browserVersion >= 5.5));
		AjxEnv.isIE6  = (AjxEnv.isIE && (AjxEnv.browserVersion == 6.0));
		AjxEnv.isIE6up = (AjxEnv.isIE && (AjxEnv.browserVersion >= 6.0));

		AjxEnv.isMozilla = ((AjxEnv.isNav && AjxEnv.mozVersion && 
							AjxEnv.isGeckoBased && (AjxEnv.geckoDate != 0)));
		AjxEnv.isMozilla1_4up = (AjxEnv.isMozilla && (AjxEnv.mozVersion >= 1.4));
		AjxEnv.isFirefox = ((AjxEnv.isMozilla && AjxEnv.isFirefox));
		AjxEnv.isFirefox1up = (AjxEnv.isFirefox && AjxEnv.browserVersion >= 1.0);
		AjxEnv.isFirefox1_5up = (AjxEnv.isFirefox && AjxEnv.browserVersion >= 1.5);

	}
	// setup some global setting we can check for high resolution
	if (AjxEnv.isIE){
		AjxEnv.isNormalResolution = true;
		AjxEnv.ieScaleFactor = screen.deviceXDPI / screen.logicalXDPI;
		if (AjxEnv.ieScaleFactor > 1) {
			AjxEnv.isNormalResolution = false;
		}
	}
	// show transparent PNGs on platforms that support them well
	//	(eg: all but IE and Linux)
	//	MOW: having trouble getting safari to render transparency for shadows, skipping there, too
	AjxEnv.useTransparentPNGs = !AjxEnv.isIE && !AjxEnv.isLinux && !AjxEnv.isSafari;
	AjxEnv._inited = !AjxEnv.isIE;
};

AjxEnv.reset();
AjxEnv.parseUA(navigator.userAgent);

// COMPATIBILITY

// Safari doesn't support string.replace(/regexp/, function);
if (AjxEnv.isSafari) {
	if (!String.prototype._AjxOldReplace) {
		String.prototype._AjxOldReplace = String.prototype.replace;
		String.prototype.replace = function(re, val) {
			if (typeof val != "function")
				return this._AjxOldReplace(re, val);
			else {
				// TODO: investigate if it's possible to use the array.join approach
				var str = this.slice(0), v, l, a;
				while (a = re.exec(str)) {
					v = val.apply(null, a);
					l = a[0].length;
					re.lastIndex -= l - v.length;
					str = str.substr(0, a.index) + v + str.substr(a.index + l);
					if (!re.global)
						break;
				}
				return str;
			}
		};
	}
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
 * AjxUtil - static class with some utility methods. This is where to
 * put things when no other class wants them.
 *
 * 12/3/2004 At this point, it only needs AjxEnv to be loaded.
 */
function AjxUtil () {
};

AjxUtil.FLOAT_RE = /^[+\-]?((\d+(\.\d*)?)|((\d*\.)?\d+))([eE][+\-]?\d+)?$/;
AjxUtil.NOTFLOAT_RE = /[^\d\.]/;
AjxUtil.NOTINT_RE = /[^0-9]+/;
AjxUtil.LIFETIME_FIELD = /^([0-9])+([dhms])?$/;

AjxUtil.isSpecified 		= function(aThing) { return ((aThing !== void 0) && (aThing !== null)); };
AjxUtil.isUndefined 		= function(aThing) { return (aThing === void 0); };
AjxUtil.isNull 				= function(aThing) { return (aThing === null); };
AjxUtil.isBoolean 			= function(aThing) { return (typeof(aThing) == 'boolean'); };
AjxUtil.isString 			= function(aThing) { return (typeof(aThing) == 'string'); };
AjxUtil.isNumber 			= function(aThing) { return (typeof(aThing) == 'number'); };
AjxUtil.isObject 			= function(aThing) { return ((typeof(aThing) == 'object') && (aThing !== null)); };
AjxUtil.isArray 			= function(aThing) { return AjxUtil.isInstance(aThing, Array); };
AjxUtil.isFunction 			= function(aThing) { return (typeof(aThing) == 'function'); };
AjxUtil.isDate 				= function(aThing) { return AjxUtil.isInstance(aThing, Date); };
AjxUtil.isLifeTime 			= function(aThing) { return AjxUtil.LIFETIME_FIELD.test(aThing); };
AjxUtil.isNumeric 			= function(aThing) { return (!isNaN(parseFloat(aThing)) && AjxUtil.FLOAT_RE.test(aThing) && !AjxUtil.NOTFLOAT_RE.test(aThing)); };
AjxUtil.isLong			    = function(aThing) { return (AjxUtil.isNumeric(aThing) && !AjxUtil.NOTINT_RE.test(aThing)); };
AjxUtil.isNonNegativeLong   = function(aThing) { return (AjxUtil.isNumeric(aThing) && AjxUtil.isLong(aThing) && (parseFloat(aThing) >= 0)); };


// REVISIT: Should do more precise checking. However, there are names in
//			common use that do not follow the RFC patterns (e.g. domain
//			names that start with digits).
AjxUtil.IP_ADDRESS_RE = /^\d{1,3}(\.\d{1,3}){3}(\.\d{1,3}\.\d{1,3})?$/;
AjxUtil.DOMAIN_NAME_SHORT_RE = /^[A-Za-z0-9\-]{2,}$/;
AjxUtil.DOMAIN_NAME_FULL_RE = /^[A-Za-z0-9\-]{2,}(\.[A-Za-z0-9\-]{2,}){1,}$/;
AjxUtil.HOST_NAME_RE = /^[A-Za-z0-9\-]{2,}(\.[A-Za-z0-9\-]{2,})*$/;
AjxUtil.HOST_NAME_WITH_PORT_RE = /^[A-Za-z0-9\-]{2,}(\.[A-Za-z0-9\-]{2,})*:([0-9])+$/;
AjxUtil.EMAIL_SHORT_RE = /^[^@\s]+$/;
AjxUtil.EMAIL_FULL_RE = /^[^@\s]+@[A-Za-z0-9\-]{2,}(\.[A-Za-z0-9\-]{2,})*$/;
AjxUtil.EMAIL_RE = /^([a-zA-Z0-9_\-])+((\.)?([a-zA-Z0-9_\-])+)*@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;
AjxUtil.SHORT_URL_RE = /^[A-Za-z0-9]{2,}:\/\/[A-Za-z0-9\-]{2,}(\.[A-Za-z0-9\-]{2,})*(:([0-9])+)*$/;
AjxUtil.IP_SHORT_URL_RE = /^[A-Za-z0-9]{2,}:\/\/\d{1,3}(\.\d{1,3}){3}(\.\d{1,3}\.\d{1,3})?(:([0-9])+)*$/;

AjxUtil.isIpAddress 		= function(s) { return AjxUtil.IP_ADDR_RE.test(s); };
AjxUtil.isDomain 			= function(s) {	return AjxUtil.DOMAIN_RE.test(s); };
AjxUtil.isHostName 			= function(s) { return AjxUtil.HOST_NAME_RE.test(s); };
AjxUtil.isDomainName = 
function(s, shortMatch) {
	return shortMatch 
		? AjxUtil.DOMAIN_NAME_SHORT_RE.test(s) 
		: AjxUtil.DOMAIN_NAME_FULL_RE.test(s);
};

AjxUtil.isEmailAddress = 
function(s, nameOnly) {
	return nameOnly 
		? AjxUtil.EMAIL_SHORT_RE.test(s) 
		: AjxUtil.EMAIL_FULL_RE.test(s);
};

AjxUtil.SIZE_GIGABYTES = "GB";
AjxUtil.SIZE_MEGABYTES = "MB";
AjxUtil.SIZE_KILOBYTES = "KB";
AjxUtil.SIZE_BYTES = "B";

/**
 * Formats a size (in bytes) to the largest whole unit. For example,
 * AjxUtil.formatSize(302132199) returns "288 MB".
 *
 * @param size      The size (in bytes) to be formatted.
 * @param round     True to round to nearest integer. Default is true.
 * @param fractions Number of fractional digits to display, if not rounding.
 *                  Trailing zeros after the decimal point are trimmed.
 */
AjxUtil.formatSize = 
function(size, round, fractions) {
	if (round == null) round = true;
	if (fractions == null) fractions = 20; // max allowed for toFixed is 20

	var units = AjxUtil.SIZE_BYTES;
	if (size >= 1073741824) {
		size /= 1073741824;
		units = AjxUtil.SIZE_GIGABYTES;
	}
	else if (size >= 1048576) {
		size /= 1048576;
		units = AjxUtil.SIZE_MEGABYTES;
	}
	else if (size > 1023) {
		size /= 1024;
		units = AjxUtil.SIZE_KILOBYTES;
	}

	var formattedSize = round ? Math.round(size) : size.toFixed(fractions).replace(/\.?0+$/,"");
	var formattedUnits = ' '+units;
	
	return formattedSize + formattedUnits;
};

/**
 * Formats a size (in bytes) to a specific unit. Since the unit size is
 * known, the unit is not shown in the returned string. For example,
 * AjxUtil.formatSizeForUnit(302132199, AjxUtil.SIZE_MEGABYTES, false, 2) 
 * returns "288.13".
 *
 * @param size      The size (in bytes) to be formatted.
 * @param units     The unit of measure.
 * @param round     True to round to nearest integer. Default is true.
 * @param fractions Number of fractional digits to display, if not rounding.
 *                  Trailing zeros after the decimal point are trimmed.
 */
AjxUtil.formatSizeForUnits = 
function(size, units, round, fractions) {
	if (units == null) units = AjxUtil.SIZE_BYTES;
	if (round == null) round = true;
	if (fractions == null) fractions = 20; // max allowed for toFixed is 20

	switch (units) {
		case AjxUtil.SIZE_GIGABYTES: { size /= 1073741824; break; }
		case AjxUtil.SIZE_MEGABYTES: { size /= 1048576; break; }
		case AjxUtil.SIZE_KILOBYTES: { size /= 1024; break; }
	}
	
	var formattedSize = round ? Math.round(size) : size.toFixed(fractions).replace(/\.?0+$/,"");
	return formattedSize;
};

/**
 * Performs the opposite of AjxUtil.formatSize in that this function takes a 
 * formatted size.
 *
 * @param units Unit constant: "GB", "MB", "KB", "B". Must be specified 
 *              unless the formatted size ends with the size marker, in
 *				which case the size marker in the formattedSize param
 *				overrides this parameter.
 */
AjxUtil.parseSize = 
function(formattedSize, units) {
	// NOTE: Take advantage of fact that parseFloat ignores bad chars
	//       after numbers
	var size = parseFloat(formattedSize.replace(/^\s*/,""));

	var marker = /[GMK]?B$/i;
	var result = marker.exec(formattedSize);
	if (result) {
		//alert("units: "+units+", result[0]: '"+result[0]+"'");
		units = result[0].toUpperCase();
	}
	
	switch (units) {
		case AjxUtil.SIZE_GIGABYTES: size *= 1073741824; break;
		case AjxUtil.SIZE_MEGABYTES: size *= 1048576; break; 
		case AjxUtil.SIZE_KILOBYTES: size *= 1024; break;
	}
	
	//alert("AjxUtil#parseSize: formattedSize="+formattedSize+", size="+size);
	return size;
};

AjxUtil.isInstance = 
function(aThing, aClass) { 
	return !!(aThing && aThing.constructor && (aThing.constructor === aClass)); 
};

AjxUtil.assert = 
function(aCondition, aMessage) {
	if (!aCondition && AjxUtil.onassert) AjxUtil.onassert(aMessage);
};

AjxUtil.onassert = 
function(aMessage) {
	// Create an exception object and set the message
	var myException = new Object();
	myException.message = aMessage;
	
	// Compile a stack trace
	var myStack = new Array();
	if (AjxEnv.isIE5_5up) {
		// On IE, the caller chain is on the arguments stack
		var myTrace = arguments.caller;
		while (myTrace) {
		    myStack[myStack.length] = myTrace.callee;
	    	myTrace = myTrace.caller;
		}
	} else {
		try {
			var myTrace = arguments.callee.caller;
			while (myTrace) {
				myStack[myStack.length] = myTrace;
				if (myStack.length > 2) break;
				myTrace = myTrace.caller;
		    }
		} catch (e) {
		}
	}
	myException.stack = myStack;
	
	// Alert with the message and a description of the stack
	var stackString = '';
	var MAX_LEN = 170;
	for (var i = 1; i < myStack.length; i++) {
		if (i > 1) stackString += '\n';
		if (i < 11) {
			var fs = myStack[i].toString();
			if (fs.length > MAX_LEN) {
				fs = fs.substr(0,MAX_LEN) + '...';
				fs = fs.replace(/\n/g, '');
			}
			stackString += i + ': ' + fs;
		} else {
			stackString += '(' + (myStack.length - 11) + ' frames follow)';
			break;
		}
	}
	alert('assertion:\n\n' + aMessage + '\n\n---- Call Stack ---\n' + stackString);
	
	// Now throw the exception
	throw myException;
};

AjxUtil.NODE_REPEATS = new Object();
AjxUtil.NODE_REPEATS["folder"]		= true;
AjxUtil.NODE_REPEATS["search"]		= true;
AjxUtil.NODE_REPEATS["tag"]			= true;
AjxUtil.NODE_REPEATS["pref"]		= true;
AjxUtil.NODE_REPEATS["attr"]		= true;
AjxUtil.NODE_REPEATS["c"]			= true;
AjxUtil.NODE_REPEATS["m"]			= true;
AjxUtil.NODE_REPEATS["cn"]			= true;
AjxUtil.NODE_REPEATS["e"]			= true;
AjxUtil.NODE_REPEATS["a"]			= true;
AjxUtil.NODE_REPEATS["mbx"]			= true;
//AjxUtil.NODE_REPEATS["mp"]		= true; // only when parent is "mp"
// these really shouldn't repeat
AjxUtil.NODE_REPEATS["prefs"]		= true;
AjxUtil.NODE_REPEATS["attrs"]		= true;
AjxUtil.NODE_REPEATS["tags"]		= true;

AjxUtil.NODE_IS_ATTR = new Object();
AjxUtil.NODE_IS_ATTR["authToken"]	= true;
AjxUtil.NODE_IS_ATTR["lifetime"]	= true;
AjxUtil.NODE_IS_ATTR["sessionId"]	= true;
AjxUtil.NODE_IS_ATTR["name"]		= true;
AjxUtil.NODE_IS_ATTR["quotaUsed"]	= true;
AjxUtil.NODE_IS_ATTR["su"]			= true;
AjxUtil.NODE_IS_ATTR["fr"]			= true;
AjxUtil.NODE_IS_ATTR["mid"]			= true;
//AjxUtil.NODE_IS_ATTR["content"]	= true; // only when parent is "note"

AjxUtil.NODE_CONTENT = new Object();
AjxUtil.NODE_CONTENT["pref"]		= true;
AjxUtil.NODE_CONTENT["attr"]		= true;
AjxUtil.NODE_CONTENT["a"]			= true;

// IE doesn't define Node type constants
AjxUtil.ELEMENT_NODE	= 1;
AjxUtil.TEXT_NODE		= 3;

/**
* Convert an XML node to the equivalent JS. Traverses the node's
* children recursively.
* <p>
* NOTE: This method has not been extensively tested and likely needs
* work.
*
* @param node		[Element]	XML node
* @param omitName	[boolean]	if true, don't include node name in output
*/
AjxUtil.xmlToJs =
function(node, omitName) {

	if (node.nodeType == AjxUtil.TEXT_NODE)
		return ['"', node.data, '"'].join("");

	var name = node.name ? node.name : node.localName;
	if (node.nodeType == AjxUtil.ELEMENT_NODE) {
		// if only child is text, no need for enclosing {}
		var hasTextNode = (node.childNodes && node.childNodes.length == 1 && 
				   (node.childNodes[0].nodeType == AjxUtil.TEXT_NODE));
		var text;
		if (omitName) {
			text = "{";
		} else if (hasTextNode) {
			text = [name, ":"].join("");
		} else {
			text = [name, ":{"].join("");
		}
		var needComma = false;	
		if (node.attributes) {
			for (var i = 0; i < node.attributes.length; i++) {
				var attr = node.attributes[i];
				if (attr.name == "xmlns") continue;
				if (needComma) text += ",";
				var value = AjxUtil.isNumeric(attr.value) ? attr.value : AjxUtil.jsEncode(attr.value);
				text = [text, attr.name, ':', value].join("");
				needComma = true;
			}
		}
		if (node.hasChildNodes()) {
			var cnodes = new Object();
			var hasChild = false;
			for (var i = 0; i < node.childNodes.length; i++) {
				var child = node.childNodes[i];
				var cname = child.name ? child.name : child.localName;
				var isAttr = AjxUtil.NODE_IS_ATTR[cname] || 
							 (name == "content" && parent.name == "note");
				if (isAttr) {
					if (needComma) text += ",";
					text = [text, cname, ':', AjxUtil.jsEncode(child.textContent)].join("");
					needComma = true;
				} else {
					if (!cnodes[cname])
						cnodes[cname] = new Array();
					cnodes[cname].push(child);
					hasChild = true;
				}
			}
			if (hasChild && needComma) {text += ","; needComma = false;}
			for (var cname in cnodes) {
				if (needComma) {
					text += ",";
					needComma = false;
				}
				var repeats = AjxUtil.NODE_REPEATS[cname] ||
							  (cname == "mp" && name == "mp");
				if (repeats) text += cname + ":[";
				var clist = cnodes[cname];
				for (var i = 0; i < clist.length; i++) {
					if (needComma) text += ",";
					text += AjxUtil.xmlToJs(clist[i], repeats);
					needComma = true;
				}
				if (repeats) text += "]";
			}
		}
		if (!hasTextNode) text += "}";
	}

	return text;
}

AjxUtil.JS_CHAR_ENCODINGS = [
	"\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007",
	"\\b",     "\\t",     "\\n",     "\\u000B", "\\f",     "\\r",     "\\u000E", "\\u000F",
	"\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017",
	"\\u0018", "\\u0019", "\\u001A", "\\u001B", "\\u001C", "\\u001D", "\\u001E", "\\u001F"
];

AjxUtil.jsEncode =
function(string) {

	if (!string) return "\"\"";

	var text = '"';
	for (var i = 0; i < string.length; i++) {
		var c = string.charAt(i);
		switch (c) {
			case '\\': case '"': case '/':
				text += '\\' + c;
				break;
			default:
				var code = string.charCodeAt(i);
				text += (code < 32) ? AjxUtil.JS_CHAR_ENCODINGS[code] : c;
		}
	}
	text += '"';
	return text;
};

AjxUtil.getInnerText = 
function(node) {
 	if (AjxEnv.isIE)
 		return node.innerText;

	function f(n) {
		if (n) {
			if (n.nodeType == 3 /* TEXT_NODE */)
				return n.data;
			if (n.nodeType == 1 /* ELEMENT_NODE */) {
				if (/^br$/i.test(n.tagName))
					return "\r\n";
				var str = "";
				for (var i = n.firstChild; i; i = i.nextSibling)
					str += f(i);
				return str;
			}
		}
		return "";
	};
	return f(node);
};

/**
 * This method returns a proxy for the specified object. This is useful when
 * you want to modify properties of an object and want to keep those values
 * separate from the values in the original object. You can then iterate
 * over the proxy's properties and use the <code>hasOwnProperty</code>
 * method to determine if the property is a new value in the proxy.
 * <p>
 * <strong>Note:</strong>
 * A reference to the original object is stored in the proxy as the "_object_" 
 * property.
 *
 * @param object [object] The object to proxy.
 * @param level  [number] The number of property levels deep to proxy.
 *						  Defaults to zero.
 */
AjxUtil.createProxy = 
function(object, level) {
	var proxy;
	var proxyCtor = function(){}; // bug #6517 (Safari doesnt like 'new Function')
	proxyCtor.prototype = object;
	if (object instanceof Array) {
		proxy  = new Array();
		var cnt  = object.length;
		for(var ix = 0; ix < cnt; ix++) {
			proxy[ix] = object[ix];
		}
	} else {
		proxy = new proxyCtor;
	}
	
	if (level) {
		for (var prop in object) {
			if (typeof object[prop] == "object")
				proxy[prop] = AjxUtil.createProxy(object[prop], level - 1);
		}
	}	
	
	proxy._object_ = object;
	return proxy;
};

/**
* Returns a copy of a list with empty members removed.
*
* @param list	[array]		original list
*/
AjxUtil.collapseList =
function(list) {
	var newList = [];
	for (var i = 0; i < list.length; i++)
		if (list[i])
			newList.push(list[i]);
	return newList;
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


// NOTE: The API for the classes in this file are inspired by the Java text
//		 formatting classes but the implementation was NOT copied or ported
//		 from the Java sources.

//
// Format class
//

/** 
 * Base class for all formats. To format an object, instantiate the
 * format of your choice and call the <code>format</code> method which
 * returns the formatted string.
 */
function AjxFormat(pattern) {
	this._pattern = pattern;
	this._segments = [];
}

/** Returns string representation of this object. */
AjxFormat.prototype.toString = function() { 
	var s = [];
	s.push("pattern=\"",this._pattern,'"');
	if (this._segments.length > 0) {
		s.push(", segments={ ");
		for (var i = 0; i < this._segments.length; i++) {
			if (i > 0) { s.push(", "); }
			s.push(String(this._segments[i]));
		}
		s.push(" }");
	}
	return s.join("");
};

// Data

AjxFormat.prototype._pattern;
AjxFormat.prototype._segments;

// Public methods

/** 
 * This method does <em>not</em> need to be overridden unless
 * the subclass doesn't use format segments and takes complete 
 * responsibility for formatting.
 */
AjxFormat.prototype.format = function(object) { 
	var s = [];
	for (var i = 0; i < this._segments.length; i++) {
		s.push(this._segments[i].format(object));
	}
	return s.join("");
};

/** 
 * Parses the given string according to this format's pattern and returns
 * an object.
 * <p>
 * <strong>Note:</strong>
 * The default implementation of this method assumes that the sub-class
 * has implemented the <code>_createParseObject</code> method.
 */
AjxFormat.prototype.parse = function(s) {
	var object = this._createParseObject();
	var index = 0;
	for (var i = 0; i < this._segments.length; i++) {
		var segment = this._segments[i];
		index = segment.parse(object, s, index);
	}
	// REVISIT: Should this return null instead?
	if (index < s.length) {
		throw new AjxFormat.ParsingException(this, null, "input too long"); // I18n
	}
	return object;
};

/** 
 * Returns an array of segments that comprise this format. 
 * <p>
 * <strong>Note:</strong>
 * This method is specific to this implementation and does not follow
 * the format classes found in the <code>java.text</code> package.
 */
AjxFormat.prototype.getSegments = function() {
	return this._segments;
};

/** Returns a string pattern for this format. */
AjxFormat.prototype.toPattern = function() {
	return this._pattern;
};

/** Returns a copy of this format. */
AjxFormat.prototype.clone = function() {
	return new this.constructor(this._pattern);
};

// Protected methods

/**
 * Creates the object that is initialized by parsing
 * <p>
 * <strong>Note:</strong>
 * This must be implemented by sub-classes.
 */
AjxFormat.prototype._createParseObject = function(s) {
	throw new AjxFormat.ParsingException(this, null, "not implemented"); // I18n
};

// Protected static methods

AjxFormat._zeroPad = function(s, length, zeroChar, rightSide) {
	s = typeof s == "string" ? s : String(s);

	if (s.length >= length) return s;

	zeroChar = zeroChar || '0';
	
	var a = [];
	for (var i = s.length; i < length; i++) {
		a.push(zeroChar);
	}
	a[rightSide ? "unshift" : "push"](s);

	return a.join("");
};

//
// Format exception base class
//

AjxFormat.FormatException = function(format, message) {
	this._format = format;
	this._message = message;
};
AjxFormat.FormatException.prototype.toString = function() { 
	return this._message; 
};

// Data

AjxFormat.FormatException.prototype._format;
AjxFormat.FormatException.prototype._message;

//
// Formatting exception class
//

AjxFormat.FormattingException = function(format, segment, message) {
	AjxFormat.FormatException.call(this, format, message);
	this._segment = segment;
};
AjxFormat.FormattingException.prototype = new AjxFormat.FormatException;
AjxFormat.FormattingException.prototype.constructor = AjxFormat.FormattingException;

// Data

AjxFormat.FormattingException.prototype._segment;

//
// Parsing exception class
//

AjxFormat.ParsingException = function(format, segment, message) {
	AjxFormat.FormatException.call(this, format, message);
	this._segment = segment;
};
AjxFormat.ParsingException.prototype = new AjxFormat.FormatException;
AjxFormat.ParsingException.prototype.constructor = AjxFormat.ParsingException;

// Data

AjxFormat.ParsingException.prototype._segment;

//
// Segment class
//

AjxFormat.Segment = function(format, s) {
	this._parent = format;
	this._s = s;
};

AjxFormat.Segment.prototype.toString = function() { 
	return "segment: \""+this._s+'"'; 
};

// Data

AjxFormat.Segment.prototype._parent;
AjxFormat.Segment.prototype._s;

// Public methods

AjxFormat.Segment.prototype.format = function(o) { 
	return this._s; 
};

/**
 * Parses the string at the given index, initializes the parse object
 * (as appropriate), and returns the new index within the string for
 * the next parsing step.
 * <p>
 * <strong>Note:</strong>
 * This method must be implemented by sub-classes.
 *
 * @param o     [object] The parse object to be initialized.
 * @param s     [string] The input string to be parsed.
 * @param index [number] The index within the string to start parsing.
 */
AjxFormat.Segment.prototype.parse = function(o, s, i) {
	throw new AjxFormat.ParsingException(this._parent, this, "not implemented"); // I18n
};

// Protected static methods

AjxFormat.Segment._parseLiteral = function(literal, s, index) {
	if (s.length - index < literal.length) {
		throw new AjxFormat.ParsingException(this._parent, this, "input too short"); // I18n
	}
	for (var i = 0; i < literal.length; i++) {
		if (literal.charAt(i) != s.charAt(index + i)) {
			throw new AjxFormat.ParsingException(this._parent, this, "input doesn't match"); // I18n
		}
	}
	return index + literal.length;
};
AjxFormat.Segment._parseLiterals = function(literals, s, index) {
	for (var i = 0; i < literals.length; i++) {
		try {
			var literal = literals[i];
			return AjxFormat.Segment._parseLiteral(literal, s, index);
		}
		catch (e) {
			// ignore. keep trying to find a match
		}
	}
	return -1;
};

/**
 * Parses an integer at the offset of the given string and calls a
 * method on the specified object.
 *
 * @param o         [object]   The target object.
 * @param f         [function] The method to call on the target object.
 * @param adjust    [number]   The numeric adjustment to make on the
 *                             value before calling the object method.
 * @param s         [string]   The string to parse.
 * @param index     [number]   The index within the string to start parsing.
 * @param fixedlen  [number]   If specified, specifies the required number
 *                             of digits to be parsed.
 */
AjxFormat.Segment._parseInt = function(o, f, adjust, s, index, fixedlen) {
	var len = fixedlen || s.length - index;
	var head = index;
	for (var i = 0; i < len; i++) {
		if (!s.charAt(index++).match(/\d/)) {
			index--;
			break;
		}
	}
	var tail = index;
	if (head == tail) {
		throw new AjxFormat.ParsingException(this._parent, this, "number not present"); // I18n
	}
	if (fixedlen && tail - head != fixedlen) {
		throw new AjxFormat.ParsingException(this._parent, this, "number too short"); // I18n
	}
	var value = parseInt(s.substring(head, tail), 10);
	if (f) {
		var target = o || window;
		f.call(target, value + adjust);
	}
	return tail;
};

//
// Date format class
//

/**
 * The AjxDateFormat class formats Date objects according to a specified 
 * pattern. The patterns are defined the same as the SimpleDateFormat
 * class in the Java libraries. <strong>Note:</strong> <em>Only the
 * Gregorian Calendar is supported at this time.</em> Supporting other
 * calendars would require a lot more information downloaded to the
 * client. Limiting dates to the Gregorian calendar is a trade-off.
 * <p>
 * <strong>Note:</strong>
 * The date format differs from the Java patterns a few ways: the pattern
 * "EEEEE" (5 'E's) denotes a <em>short</em> weekday and the pattern "MMMMM"
 * (5 'M's) denotes a <em>short</em> month name. This matches the extended 
 * pattern found in the Common Locale Data Repository (CLDR) found at: 
 * http://www.unicode.org/cldr/.
 */
function AjxDateFormat(pattern) {
	AjxFormat.call(this, pattern);
	if (typeof pattern == "number") {
		switch (pattern) {
			case AjxDateFormat.SHORT: pattern = I18nMsg.formatDateShort; break;
			case AjxDateFormat.MEDIUM: pattern = I18nMsg.formatDateMedium; break;
			case AjxDateFormat.LONG: pattern = I18nMsg.formatDateLong; break;
			case AjxDateFormat.FULL: pattern = I18nMsg.formatDateFull; break;
		}
	}	
	for (var i = 0; i < pattern.length; i++) {
		// literal
		var c = pattern.charAt(i);
		if (c == "'") {
			var head = i + 1;
			for (i++ ; i < pattern.length; i++) {
				var c = pattern.charAt(i);
				if (c == "'") {
					if (i + 1 < pattern.length && pattern.charAt(i + 1) == "'") {
						pattern = pattern.substr(0, i) + pattern.substr(i + 1);
					}
					else {
						break;
					}
				}
			}
			if (i == pattern.length) {
				// TODO: i18n
				throw new FormatException(this, "unterminated string literal");
			}
			var tail = i;
			var segment = new AjxFormat.TextSegment(this, pattern.substring(head, tail));
			this._segments.push(segment);
			continue;
		}

		// non-meta chars
		var head = i;
		while(i < pattern.length) {
			c = pattern.charAt(i);
			if (AjxDateFormat._META_CHARS.indexOf(c) != -1 || c == "'") {
				break;
			}
			i++;
		}
		var tail = i;
		if (head != tail) {
			var segment = new AjxFormat.TextSegment(this, pattern.substring(head, tail));
			this._segments.push(segment);
			i--;
			continue;
		}
		
		// meta char
		var head = i;
		while(++i < pattern.length) {
			if (pattern.charAt(i) != c) {
				break;
			}		
		}
		var tail = i--;
		var count = tail - head;
		var field = pattern.substr(head, count);
		var segment = null;
		switch (c) {
			case 'G': segment = new AjxDateFormat.EraSegment(this, field); break;
			case 'y': segment = new AjxDateFormat.YearSegment(this, field); break;
			case 'M': segment = new AjxDateFormat.MonthSegment(this, field); break;
			case 'w': segment = new AjxDateFormat.WeekSegment(this, field); break;
			case 'W': segment = new AjxDateFormat.WeekSegment(this, field); break;
			case 'D': segment = new AjxDateFormat.DaySegment(this, field); break;
			case 'd': segment = new AjxDateFormat.DaySegment(this, field); break;
			case 'F': segment = new AjxDateFormat.WeekdaySegment(this, field); break;
			case 'E': segment = new AjxDateFormat.WeekdaySegment(this, field); break;
			case 'a': segment = new AjxDateFormat.AmPmSegment(this, field); break;
			case 'H': segment = new AjxDateFormat.HourSegment(this, field); break;
			case 'k': segment = new AjxDateFormat.HourSegment(this, field); break;
			case 'K': segment = new AjxDateFormat.HourSegment(this, field); break;
			case 'h': segment = new AjxDateFormat.HourSegment(this, field); break;
			case 'm': segment = new AjxDateFormat.MinuteSegment(this, field); break;
			case 's': segment = new AjxDateFormat.SecondSegment(this, field); break;
			case 'S': segment = new AjxDateFormat.SecondSegment(this, field); break;
			case 'z': segment = new AjxDateFormat.TimezoneSegment(this, field); break;
			case 'Z': segment = new AjxDateFormat.TimezoneSegment(this, field); break;
		}
		if (segment != null) {
			segment._index = this._segments.length;
			this._segments.push(segment);
		}
	}
}
AjxDateFormat.prototype = new AjxFormat;
AjxDateFormat.prototype.constructor = AjxDateFormat;

AjxDateFormat.prototype.toString = function() {
	return "[AjxDateFormat: "+AjxFormat.prototype.toString.call(this)+"]";
};

// Constants

AjxDateFormat.SHORT = 0;
AjxDateFormat.MEDIUM = 1;
AjxDateFormat.LONG = 2;
AjxDateFormat.FULL = 3;
AjxDateFormat.DEFAULT = AjxDateFormat.MEDIUM;

AjxDateFormat._META_CHARS = "GyMwWDdFEaHkKhmsSzZ";

AjxDateFormat._dateFormats = [
	I18nMsg.formatDateShort, I18nMsg.formatDateMedium,
	I18nMsg.formatDateLong, I18nMsg.formatDateFull
];
AjxDateFormat._timeFormats = [
	I18nMsg.formatTimeShort, I18nMsg.formatTimeMedium, 
	I18nMsg.formatTimeLong, I18nMsg.formatTimeFull
];

AjxDateFormat._DATE_FORMATTERS = {};
AjxDateFormat._TIME_FORMATTERS = {};
AjxDateFormat._DATETIME_FORMATTERS = {};

// Static methods

AjxDateFormat.getDateInstance = function(style) {
	// lazily create formatters
	style = style != null ? style : AjxDateFormat.DEFAULT;
	if (!AjxDateFormat._DATE_FORMATTERS[style]) {
		AjxDateFormat._DATE_FORMATTERS[style] = new AjxDateFormat(AjxDateFormat._dateFormats[style]);
	}
	return AjxDateFormat._DATE_FORMATTERS[style];
};

AjxDateFormat.getTimeInstance = function(style) {
	// lazily create formatters
	style = style != null ? style : AjxDateFormat.DEFAULT;
	if (!AjxDateFormat._TIME_FORMATTERS[style]) {
		AjxDateFormat._TIME_FORMATTERS[style] = new AjxDateFormat(AjxDateFormat._timeFormats[style]);
	}
	return AjxDateFormat._TIME_FORMATTERS[style];
};

AjxDateFormat.getDateTimeInstance = function(dateStyle, timeStyle) {
	// lazily create formatters
	dateStyle = dateStyle != null ? dateStyle : AjxDateFormat.DEFAULT;
	timeStyle = timeStyle != null ? timeStyle : AjxDateFormat.DEFAULT;
	var style = dateStyle * 10 + timeStyle;
	if (!AjxDateFormat._DATETIME_FORMATTERS[style]) {
		var pattern = I18nMsg.formatDateTime;
		var params = [ AjxDateFormat._dateFormats[dateStyle], AjxDateFormat._timeFormats[timeStyle] ];
		
		var dateTimePattern = AjxMessageFormat.format(pattern, params);
		AjxDateFormat._DATETIME_FORMATTERS[style] = new AjxDateFormat(dateTimePattern);
	}
	return AjxDateFormat._DATETIME_FORMATTERS[style];
};

AjxDateFormat.format = function(pattern, date) {
	return new AjxDateFormat(pattern).format(date);
};
AjxDateFormat.parse = function(pattern, dateStr) {
	return new AjxDateFormat(pattern).parse(dateStr);
};

// Public methods

/** 
 * Parses the given string and returns a date. If the string cannot be
 * parsed as a date, <code>null</code> is returned.
 */
AjxDateFormat.prototype.parse = function(s) {
	var object = null;
	try {
		object = AjxFormat.prototype.parse.call(this, s);
	}
	catch (e) {
		// do nothing
	}
	return object;
};

// Protected methods

AjxDateFormat.prototype._createParseObject = function() {
	return new Date(0, 0, 1, 0, 0, 0, 0);
};

//
// Text segment class
//

AjxFormat.TextSegment = function(format, s) {
	AjxFormat.Segment.call(this, format, s);
};
AjxFormat.TextSegment.prototype = new AjxFormat.Segment;
AjxFormat.TextSegment.prototype.constructor = AjxFormat.TextSegment;

AjxFormat.TextSegment.prototype.toString = function() { 
	return "text: \""+this._s+'"'; 
};

// Public methods

AjxFormat.TextSegment.prototype.parse = function(o, s, index) {
	return AjxFormat.Segment._parseLiteral(this._s, s, index);
};

//
// Date segment class
//

AjxDateFormat.DateSegment = function(format, s) {
	AjxFormat.Segment.call(this, format, s);
}
AjxDateFormat.DateSegment.prototype = new AjxFormat.Segment;
AjxDateFormat.DateSegment.prototype.constructor = AjxDateFormat.DateSegment;

// Protected methods

AjxDateFormat.DateSegment.prototype._getFixedLength = function() {
	var fixedlen;
	if (this._index + 1 < this._parent._segments.length) {
		var nextSegment = this._parent._segments[this._index + 1];
		if (!(nextSegment instanceof AjxFormat.TextSegment)) {
			fixedlen = this._s.length;
		}
	}
	return fixedlen;
};

//
// Date era segment class
//

AjxDateFormat.EraSegment = function(format, s) {
	AjxDateFormat.DateSegment.call(this, format, s);
};
AjxDateFormat.EraSegment.prototype = new AjxDateFormat.DateSegment;
AjxDateFormat.EraSegment.prototype.constructor = AjxDateFormat.EraSegment;

AjxDateFormat.EraSegment.prototype.toString = function() { 
	return "dateEra: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.EraSegment.prototype.format = function(date) { 
	// TODO: Only support current era at the moment...
	return I18nMsg.eraAD;
};

//
// Date year segment class
//

AjxDateFormat.YearSegment = function(format, s) {
	AjxDateFormat.DateSegment.call(this, format, s);
};
AjxDateFormat.YearSegment.prototype = new AjxDateFormat.DateSegment;
AjxDateFormat.YearSegment.prototype.constructor = AjxDateFormat.YearSegment;

AjxDateFormat.YearSegment.prototype.toString = function() { 
	return "dateYear: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.YearSegment.prototype.format = function(date) { 
	var year = String(date.getFullYear());
	return this._s.length < 4 ? year.substr(year.length - 2) : AjxFormat._zeroPad(year, this._s.length);
};

AjxDateFormat.YearSegment.prototype.parse = function(date, s, index) {
	var fixedlen = this._getFixedLength();
	var nindex = AjxFormat.Segment._parseInt(date, date.setFullYear, 0, s, index, fixedlen);
	// adjust 2-digit years
	if (nindex - index == 2) {
		if (!AjxDateFormat._2digitStartYear) {
			AjxDateFormat._2digitStartYear = parseInt(AjxMsg.dateParsing2DigitStartYear);
		}
		var syear = AjxDateFormat._2digitStartYear;
		var pyear = parseInt(s.substr(index,2), 10);
		var century = (Math.floor(syear / 100) + (pyear < (syear % 100) ? 1 : 0)) * 100;
		var year = century + pyear;
		date.setFullYear(year);
	}
	return nindex;
};

//
// Date month segment class
//

AjxDateFormat.MonthSegment = function(format, s) {
	AjxDateFormat.DateSegment.call(this, format, s);
};
AjxDateFormat.MonthSegment.prototype = new AjxDateFormat.DateSegment;
AjxDateFormat.MonthSegment.prototype.constructor = AjxDateFormat.MonthSegment;

AjxDateFormat.MonthSegment.prototype.toString = function() { 
	return "dateMonth: \""+this._s+'"'; 
};

// Constants

AjxDateFormat.MonthSegment.MONTHS = {};
AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.SHORT] = [
	AjxMsg.monthJanShort, AjxMsg.monthFebShort, AjxMsg.monthMarShort, 
	AjxMsg.monthAprShort, AjxMsg.monthMayShort, AjxMsg.monthJunShort, 
	AjxMsg.monthJulShort, AjxMsg.monthAugShort, AjxMsg.monthSepShort, 
	AjxMsg.monthOctShort, AjxMsg.monthNovShort, AjxMsg.monthDecShort
];
AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.MEDIUM] = [ 
	I18nMsg.monthJanMedium, I18nMsg.monthFebMedium, I18nMsg.monthMarMedium,
	I18nMsg.monthAprMedium, I18nMsg.monthMayMedium, I18nMsg.monthJunMedium,
	I18nMsg.monthJulMedium, I18nMsg.monthAugMedium, I18nMsg.monthSepMedium,
	I18nMsg.monthOctMedium, I18nMsg.monthNovMedium, I18nMsg.monthDecMedium
];
AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.LONG] = [ 
	I18nMsg.monthJanLong, I18nMsg.monthFebLong, I18nMsg.monthMarLong,
	I18nMsg.monthAprLong, I18nMsg.monthMayLong, I18nMsg.monthJunLong,
	I18nMsg.monthJulLong, I18nMsg.monthAugLong, I18nMsg.monthSepLong,
	I18nMsg.monthOctLong, I18nMsg.monthNovLong, I18nMsg.monthDecLong
];

// Public methods

AjxDateFormat.MonthSegment.prototype.format = function(date) {
	var month = date.getMonth();
	switch (this._s.length) {
		case 1: return String(month + 1);
		case 2: return AjxFormat._zeroPad(month + 1, 2);
		case 3: return AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.MEDIUM][month];
		case 5: return AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.SHORT][month];
	}
	return AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.LONG][month];
};

AjxDateFormat.MonthSegment.prototype.parse = function(date, s, index) {
	var months;
	switch (this._s.length) {
		case 3: 
			months = AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.SHORT];
		case 4: 
			months = months || AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.MEDIUM];
		case 5: {
			months = months || AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.LONG];
			var nindex = AjxFormat.Segment._parseLiterals(months, s, index);
			if (nindex != -1) {
				return nindex;
			}
			throw new AjxFormat.ParsingException(this._parent, this, "no match"); // I18n
		}
	}
	var fixedlen = this._getFixedLength();
	return AjxFormat.Segment._parseInt(date, date.setMonth, -1, s, index, fixedlen);
};

//
// Date week segment class
//

AjxDateFormat.WeekSegment = function(format, s) {
	AjxDateFormat.DateSegment.call(this, format, s);
};
AjxDateFormat.WeekSegment.prototype = new AjxDateFormat.DateSegment;
AjxDateFormat.WeekSegment.prototype.constructor = AjxDateFormat.WeekSegment;

AjxDateFormat.WeekSegment.prototype.toString = function() { 
	return "weekMonth: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.WeekSegment.prototype.format = function(date) {
	var year = date.getYear();
	var month = date.getMonth();
	var day = date.getDate();
	
	var ofYear = /w/.test(this._s);
	var date2 = new Date(year, ofYear ? 0 : month, 1);

	var week = 0;
	while (true) {
		week++;
		if (date2.getMonth() > month || (date2.getMonth() == month && date2.getDate() >= day)) {
			break;
		}
		date2.setDate(date2.getDate() + 7);
	}

	return AjxFormat._zeroPad(week, this._s.length);
};

//
// Date day segment class
//

AjxDateFormat.DaySegment = function(format, s) {
	AjxDateFormat.DateSegment.call(this, format, s);
};
AjxDateFormat.DaySegment.prototype = new AjxDateFormat.DateSegment;
AjxDateFormat.DaySegment.prototype.constructor = AjxDateFormat.DaySegment;

AjxDateFormat.DaySegment.prototype.toString = function() { 
	return "dateDay: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.DaySegment.prototype.format = function(date) {
	var month = date.getMonth();
	var day = date.getDate();
	if (/D/.test(this._s) && month > 0) {
		var year = date.getYear();
		do {
			// set date to first day of month and then go back one day
			var date2 = new Date(year, month, 1);
			date2.setDate(0); 
			
			day += date2.getDate();
			month--;
		} while (month > 0);
	}
	return AjxFormat._zeroPad(day, this._s.length);
};

AjxDateFormat.DaySegment.prototype.parse = function(date, s, index) {
	if (/D/.test(this._s)) {
		date.setMonth(0);
	}
	var fixedlen = this._getFixedLength();
	return AjxFormat.Segment._parseInt(date, date.setDate, 0, s, index, fixedlen);
};

//
// Date weekday segment class
//

AjxDateFormat.WeekdaySegment = function(format, s) {
	AjxDateFormat.DateSegment.call(this, format, s);
};
AjxDateFormat.WeekdaySegment.prototype = new AjxDateFormat.DateSegment;
AjxDateFormat.WeekdaySegment.prototype.constructor = AjxDateFormat.WeekdaySegment;

AjxDateFormat.DaySegment.prototype.toString = function() { 
	return "dateDay: \""+this._s+'"'; 
};

// Constants

AjxDateFormat.WeekdaySegment.WEEKDAYS = {};
// NOTE: The short names aren't available in Java so we have to define them.
AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.SHORT] = [ 
	AjxMsg.weekdaySunShort, AjxMsg.weekdayMonShort, AjxMsg.weekdayTueShort,
	AjxMsg.weekdayWedShort, AjxMsg.weekdayThuShort, AjxMsg.weekdayFriShort,
	AjxMsg.weekdaySatShort
];
AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.MEDIUM] = [ 
	I18nMsg.weekdaySunMedium, I18nMsg.weekdayMonMedium, I18nMsg.weekdayTueMedium,
	I18nMsg.weekdayWedMedium, I18nMsg.weekdayThuMedium, I18nMsg.weekdayFriMedium,
	I18nMsg.weekdaySatMedium
];
AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.LONG] = [ 
	I18nMsg.weekdaySunLong, I18nMsg.weekdayMonLong, I18nMsg.weekdayTueLong,
	I18nMsg.weekdayWedLong, I18nMsg.weekdayThuLong, I18nMsg.weekdayFriLong,
	I18nMsg.weekdaySatLong
];

// Public methods

AjxDateFormat.WeekdaySegment.prototype.format = function(date) {
	var weekday = date.getDay();
	if (/E/.test(this._s)) {
		var style;
		switch (this._s.length) {
			case 4: style = AjxDateFormat.LONG; break;
			case 5: style = AjxDateFormat.SHORT; break;
			default: style = AjxDateFormat.MEDIUM;
		}
		return AjxDateFormat.WeekdaySegment.WEEKDAYS[style][weekday];
	}
	return AjxFormat._zeroPad(weekday, this._s.length);
};

//
// Time segment class
//

AjxDateFormat.TimeSegment = function(format, s) {
	AjxFormat.Segment.call(this, format, s);
};
AjxDateFormat.TimeSegment.prototype = new AjxFormat.Segment;
AjxDateFormat.TimeSegment.prototype.constructor = AjxDateFormat.TimeSegment;

//
// Time hour segment class
//

AjxDateFormat.HourSegment = function(format, s) {
	AjxFormat.Segment.call(this, format, s);
};
AjxDateFormat.HourSegment.prototype = new AjxDateFormat.TimeSegment;
AjxDateFormat.HourSegment.prototype.constructor = AjxDateFormat.HourSegment;

AjxDateFormat.HourSegment.prototype.toString = function() { 
	return "timeHour: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.HourSegment.prototype.format = function(date) {
	var hours = date.getHours();
	if (hours > 12 && /[hK]/.test(this._s)) {
		hours -= 12;
	}
	/***
	// NOTE: This is commented out to match the Java formatter output
	//       but from the comments for these meta-chars, it doesn't
	//       seem right.
	if (/[Hk]/.test(this._s)) {
		hours--;
	}
	/***/
	return AjxFormat._zeroPad(hours, this._s.length);
};

//
// Time minute segment class
//

AjxDateFormat.MinuteSegment = function(format, s) {
	AjxFormat.Segment.call(this, format, s);
};
AjxDateFormat.MinuteSegment.prototype = new AjxDateFormat.TimeSegment;
AjxDateFormat.MinuteSegment.prototype.constructor = AjxDateFormat.MinuteSegment;

AjxDateFormat.MinuteSegment.prototype.toString = function() { 
	return "timeMinute: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.MinuteSegment.prototype.format = function(date) {
	var minutes = date.getMinutes();
	return AjxFormat._zeroPad(minutes, this._s.length);
};

//
// Time second segment class
//

AjxDateFormat.SecondSegment = function(format, s) {
	AjxFormat.Segment.call(this, format, s);
};
AjxDateFormat.SecondSegment.prototype = new AjxDateFormat.TimeSegment;
AjxDateFormat.SecondSegment.prototype.constructor = AjxDateFormat.SecondSegment;

AjxDateFormat.SecondSegment.prototype.toString = function() { 
	return "timeSecond: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.SecondSegment.prototype.format = function(date) {
	var minutes = /s/.test(this._s) ? date.getSeconds() : date.getMilliseconds();
	return AjxFormat._zeroPad(minutes, this._s.length);
};

//
// Time am/pm segment class
//

AjxDateFormat.AmPmSegment = function(format, s) {
	AjxFormat.Segment.call(this, format, s);
};
AjxDateFormat.AmPmSegment.prototype = new AjxDateFormat.TimeSegment;
AjxDateFormat.AmPmSegment.prototype.constructor = AjxDateFormat.AmPmSegment;

AjxDateFormat.AmPmSegment.prototype.toString = function() { 
	return "timeAmPm: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.AmPmSegment.prototype.format = function(date) {
	var hours = date.getHours();
	return hours < 12 ? I18nMsg.periodAm : I18nMsg.periodPm;
};

//
// Time timezone segment class
//

AjxDateFormat.TimezoneSegment = function(format, s) {
	AjxFormat.Segment.call(this, format, s);
};
AjxDateFormat.TimezoneSegment.prototype = new AjxDateFormat.TimeSegment;
AjxDateFormat.TimezoneSegment.prototype.constructor = AjxDateFormat.TimezoneSegment;

AjxDateFormat.TimezoneSegment.prototype.toString = function() { 
	return "timeTimezone: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.TimezoneSegment.prototype.format = function(date) {
	var clientId = date.timezone || AjxTimezone.DEFAULT;
	if (/Z/.test(this._s)) {
		return AjxTimezone.getShortName(clientId);
	}
	return this._s.length < 4 ? AjxTimezone.getMediumName(clientId) : AjxTimezone.getLongName(clientId);
};

//
// Message format class
//

function AjxMessageFormat(pattern) {
	AjxFormat.call(this, pattern);
	for (var i = 0; i < pattern.length; i++) {
		// literal
		var c = pattern.charAt(i);
		if (c == "'") {
			if (i + 1 < pattern.length && pattern.charAt(i + 1) == "'") {
				var segment = new AjxFormat.TextSegment(this, "'");
				this._segments.push(segment);
				i++;
				continue;
			}
			var head = i + 1;
			for (i++ ; i < pattern.length; i++) {
				var c = pattern.charAt(i);
				if (c == "'") {
					if (i + 1 < pattern.length && pattern.charAt(i + 1) == "'") {
						pattern = pattern.substr(0, i) + pattern.substr(i + 1);
					}
					else {
						break;
					}
				}
			}
			if (i == pattern.length) {
				// TODO: i18n
				throw new AjxFormat.FormatException(this, "unterminated string literal");
			}
			var tail = i;
			var segment = new AjxFormat.TextSegment(this, pattern.substring(head, tail));
			this._segments.push(segment);
			continue;
		}
		
		// non-meta chars
		var head = i;
		while(i < pattern.length) {
			c = pattern.charAt(i);
			if (c == '{' || c == "'") {
				break;
			}
			i++;
		}
		var tail = i;
		if (head != tail) {
			var segment = new AjxFormat.TextSegment(this, pattern.substring(head, tail));
			this._segments.push(segment);
			i--;
			continue;
		}
		
		// meta char
		var head = i + 1;
		while(++i < pattern.length) {
			if (pattern.charAt(i) == '}') {
				break;
			}		
		}
		var tail = i;
		var count = tail - head;
		var field = pattern.substr(head, count);
		var segment = new AjxMessageFormat.MessageSegment(this, field);		
		if (segment != null) {
			this._segments.push(segment);
		}
	}
}
AjxMessageFormat.prototype = new AjxFormat;
AjxMessageFormat.prototype.constructor = AjxMessageFormat;

AjxMessageFormat.prototype.toString = function() {
	return "[AjxMessageFormat: "+AjxFormat.prototype.toString.call(this)+"]";
};

// Static methods

AjxMessageFormat.format = function(pattern, params) {
	return new AjxMessageFormat(pattern).format(params);
};

// Public methods

AjxMessageFormat.prototype.format = function(params) {
	if (!(params instanceof Array)) {
		params = [ params ];
	}
	return AjxFormat.prototype.format.call(this, params);
};

//
// AjxMessageFormat.MessageSegment class
//

AjxMessageFormat.MessageSegment = function(format, s) {
	AjxFormat.Segment.call(this, format, s);
	var parts = s.split(',');
	this._index = Number(parts[0]);
	this._type = parts[1] || "string";
	this._style = parts[2];
	switch (this._type) {
		case "number": {
			switch (this._style) {
				case "integer": this._formatter = AjxNumberFormat.getIntegerInstance(); break;
				case "currency": this._formatter = AjxNumberFormat.getCurrencyInstance(); break;
				case "percent": this._formatter = AjxNumberFormat.getPercentInstance(); break;
				default: this._formatter = this._style == null ? AjxNumberFormat.getInstance() : new AjxNumberFormat(this._style);
			}
			break;
		}
		case "date": case "time": {
			var func = this._type == "date" ? AjxDateFormat.getDateInstance : AjxDateFormat.getTimeInstance;
			switch (this._style) {
				case "short": this._formatter = func(AjxDateFormat.SHORT); break;
				case "medium": this._formatter = func(AjxDateFormat.MEDIUM); break;
				case "long": this._formatter = func(AjxDateFormat.LONG); break;
				case "full": this._formatter = func(AjxDateFormat.FULL); break;
				default: this._formatter = this._style == null ? func(AjxDateFormat.DEFAULT) : new AjxDateFormat(this._style);
			}
			break;
		}
		case "choice": /*TODO*/ break;
	}
	
};
AjxMessageFormat.MessageSegment.prototype = new AjxFormat.Segment;
AjxMessageFormat.MessageSegment.prototype.constructor = AjxMessageFormat.MessageSegment;

AjxMessageFormat.MessageSegment.prototype.toString = function() {
	var a = [ "message: \"", this._s, "\", index: ", this.index ];
	if (this._type) a.push(", type: ", this._type);
	if (this._style) a.push(", style: ", this._style);
	if (this._formatter) a.push(", formatter: ", this._formatter.toString());
	return a.join("");
};

// Data

AjxMessageFormat.MessageSegment.prototype._index;
AjxMessageFormat.MessageSegment.prototype._type;
AjxMessageFormat.MessageSegment.prototype._style;

AjxMessageFormat.MessageSegment.prototype._formatter;

// Public methods

AjxMessageFormat.MessageSegment.prototype.format = function(args) {
	var object = args[this._index];
	return this._formatter ? this._formatter.format(object) : String(object);
};

//
// AjxNumberFormat class
//

/**
 * @param pattern       The number pattern.
 * @param skipNegFormat Specifies whether to skip the generation of this
 *                      format's negative value formatter. 
 *                      <p>
 *                      <strong>Note:</strong> 
 *                      This parameter is only used by the implementation 
 *                      and should not be passed by application code 
 *                      instantiating a custom number format.
 */
function AjxNumberFormat(pattern, skipNegFormat) {
	AjxFormat.call(this, pattern);
	if (pattern == "") return;

	var patterns = pattern.split(/;/);
	var pattern = patterns[0];
	
	// parse prefix
	var i = 0;
	var results = this.__parseStatic(pattern, i);
	i = results.offset;
	var hasPrefix = results.text != "";
	if (hasPrefix) {
		this._segments.push(new AjxFormat.TextSegment(this, results.text));
	}
	
	// parse number descriptor
	var start = i;
	while (i < pattern.length &&
	       AjxNumberFormat._META_CHARS.indexOf(pattern.charAt(i)) != -1) {
		i++;
	}
	var end = i;

	var numPattern = pattern.substring(start, end);
	var e = numPattern.indexOf('E');
	var expon = e != -1 ? numPattern.substring(e + 1) : null;
	if (expon) {
		numPattern = numPattern.substring(0, e);
		this._showExponent = true;
	}
	
	var dot = numPattern.indexOf('.');
	var whole = dot != -1 ? numPattern.substring(0, dot) : numPattern;
	if (whole) {
		var comma = whole.lastIndexOf(',');
		if (comma != -1) {
			this._groupingOffset = whole.length - comma - 1;
		}
		whole = whole.replace(/[^#0]/g,"");
		var zero = whole.indexOf('0');
		if (zero != -1) {
			this._minIntDigits = whole.length - zero;
		}
		this._maxIntDigits = whole.length;
	}
	
	var fract = dot != -1 ? numPattern.substring(dot + 1) : null;
	if (fract) {
		var zero = fract.lastIndexOf('0');
		if (zero != -1) {
			this._minFracDigits = zero + 1;
		}
		this._maxFracDigits = fract.replace(/[^#0]/g,"").length;
	}
	
	this._segments.push(new AjxNumberFormat.NumberSegment(this, numPattern));
	
	// parse suffix
	var results = this.__parseStatic(pattern, i);
	i = results.offset;
	if (results.text != "") {
		this._segments.push(new AjxFormat.TextSegment(this, results.text));
	}
	
	// add negative formatter
	if (skipNegFormat) return;
	
	if (patterns.length > 1) {
		var pattern = patterns[1];
		this._negativeFormatter = new AjxNumberFormat(pattern, true);
	}
	else {
		// no negative pattern; insert minus sign before number segment
		var formatter = new AjxNumberFormat("");
		formatter._segments = formatter._segments.concat(this._segments);

		var index = hasPrefix ? 1 : 0;
		var minus = new AjxFormat.TextSegment(formatter, I18nMsg.numberSignMinus);
		formatter._segments.splice(index, 0, minus);
		
		this._negativeFormatter = formatter;
	}
}
AjxNumberFormat.prototype = new AjxFormat;
AjxNumberFormat.prototype.constructor = AjxNumberFormat;

AjxNumberFormat.prototype.toString = function() {
	var array = [ 
		"[AjxNumberFormat: ", 
		"formatter=", AjxFormat.prototype.toString.call(this) 
	];
	if (this._negativeFormatter) {
		array.push(", negativeFormatter=", this._negativeFormatter.toString());
	}
	array.push(']');
	return array.join("");
};

// Constants

AjxNumberFormat._NUMBER = "number";
AjxNumberFormat._INTEGER = "integer";
AjxNumberFormat._CURRENCY = "currency";
AjxNumberFormat._PERCENT = "percent";

AjxNumberFormat._META_CHARS = "0#.,E";

AjxNumberFormat._FORMATTERS = {};

// Data

AjxNumberFormat.prototype._groupingOffset = Number.MAX_VALUE;
AjxNumberFormat.prototype._maxIntDigits;
AjxNumberFormat.prototype._minIntDigits = 1;
AjxNumberFormat.prototype._maxFracDigits;
AjxNumberFormat.prototype._minFracDigits;
AjxNumberFormat.prototype._isCurrency = false;
AjxNumberFormat.prototype._isPercent = false;
AjxNumberFormat.prototype._isPerMille = false;
AjxNumberFormat.prototype._showExponent = false;

AjxNumberFormat.prototype._negativeFormatter;

// Static functions

AjxNumberFormat.getInstance = function() {
	if (!AjxNumberFormat._FORMATTERS[AjxNumberFormat._NUMBER]) {
		AjxNumberFormat._FORMATTERS[AjxNumberFormat._NUMBER] = new AjxNumberFormat(I18nMsg.formatNumber);
	}
	return AjxNumberFormat._FORMATTERS[AjxNumberFormat._NUMBER];
};
AjxNumberFormat.getNumberInstance = AjxNumberFormat.getInstance;
AjxNumberFormat.getCurrencyInstance = function() {
	if (!AjxNumberFormat._FORMATTERS[AjxNumberFormat._CURRENCY]) {
		AjxNumberFormat._FORMATTERS[AjxNumberFormat._CURRENCY] = new AjxNumberFormat(I18nMsg.formatNumberCurrency);
	}
	return AjxNumberFormat._FORMATTERS[AjxNumberFormat._CURRENCY];
};
AjxNumberFormat.getIntegerInstance = function() {
	if (!AjxNumberFormat._FORMATTERS[AjxNumberFormat._INTEGER]) {
		AjxNumberFormat._FORMATTERS[AjxNumberFormat._INTEGER] = new AjxNumberFormat(I18nMsg.formatNumberInteger);
	}
	return AjxNumberFormat._FORMATTERS[AjxNumberFormat._INTEGER];
};
AjxNumberFormat.getPercentInstance = function() {
	if (!AjxNumberFormat._FORMATTERS[AjxNumberFormat._PERCENT]) {
		AjxNumberFormat._FORMATTERS[AjxNumberFormat._PERCENT] = new AjxNumberFormat(I18nMsg.formatNumberPercent);
	}
	return AjxNumberFormat._FORMATTERS[AjxNumberFormat._PERCENT];
};

AjxNumberFormat.format = function(pattern, number) {
	return new AjxNumberFormat(pattern).format(number);
};

// Public methods

AjxNumberFormat.prototype.format = function(number) {
	if (number < 0 && this._negativeFormatter) {
		return this._negativeFormatter.format(number);
	}
	return AjxFormat.prototype.format.call(this, number);
};

// Private methods

AjxNumberFormat.prototype.__parseStatic = function(s, i) {
	var data = [];
	while (i < s.length) {
		var c = s.charAt(i++);
		if (AjxNumberFormat._META_CHARS.indexOf(c) != -1) {
			i--;
			break;
		}
		switch (c) {
			case "'": {
				var start = i;
				while (i < s.length && s.charAt(i++) != "'") {
					// do nothing
				}
				var end = i;
				c = end - start == 0 ? "'" : s.substring(start, end);
				break;
			}
			case '%': {
				c = I18nMsg.numberSignPercent; 
				this._isPercent = true;
				break;
			}
			case '\u2030': {
				c = I18nMsg.numberSignPerMill; 
				this._isPerMille = true;
				break;
			}
			case '\u00a4': {
				c = s.charAt(i) == '\u00a4'
				  ? I18nMsg.currencyCode : I18nMsg.currencySymbol;
				this._isCurrency = true;
				break;
			}
		}
		data.push(c);
	}
	return { text: data.join(""), offset: i };
};

//
// AjxNumberFormat.NumberSegment class
//

AjxNumberFormat.NumberSegment = function(format, s) {
	AjxFormat.Segment.call(this, format, s);
};
AjxNumberFormat.NumberSegment.prototype = new AjxFormat.Segment;
AjxNumberFormat.NumberSegment.prototype.constructor = AjxNumberFormat.NumberSegment;

AjxNumberFormat.NumberSegment.prototype.toString = function() {
	return "number: \""+this._s+"\"";
};

// Public methods

AjxNumberFormat.NumberSegment.prototype.format = function(number) {
	// special values
	if (isNaN(number)) return I18nMsg.numberNaN;
	if (number === Number.NEGATIVE_INFINITY || number === Number.POSITIVE_INFINITY) {
		return I18nMsg.numberInfinity;
	}

	// adjust value
	if (typeof number != "number") number = Number(number);
	number = Math.abs(number); // NOTE: minus sign is part of pattern
	if (this._parent._isPercent) number *= 100;
	else if (this._parent._isPerMille) number *= 1000;

	// format
	var s = this._parent._showExponent
	      ? number.toExponential(this._parent._maxFracDigits).toUpperCase().replace(/E\+/,"E")
	      : number.toFixed(this._parent._maxFracDigits);
	s = this._normalize(s);
	return s;
};

// Protected methods

AjxNumberFormat.NumberSegment.prototype._normalize = function(s) {
	var match = s.split(/([\.Ee])/);
	
	// normalize whole part
	var whole = match.shift();
	if (whole.length < this._parent._minIntDigits) {
		whole = AjxFormat._zeroPad(whole, this._parent._minIntDigits, I18nMsg.numberZero);
	}
	if (whole.length > this._parent._groupingOffset) {
		var a = [];
		
		var i = whole.length - this._parent._groupingOffset;
		while (i > 0) {
			a.unshift(whole.substr(i, this._parent._groupingOffset));
			a.unshift(I18nMsg.numberSeparatorGrouping);
			i -= this._parent._groupingOffset;
		}
		a.unshift(whole.substring(0, i + this._parent._groupingOffset));
		
		whole = a.join("");
	}
	
	// normalize rest
	var fract = '0';
	var expon;
	while (match.length > 0) {
		switch (match.shift()) {
			case '.': fract = match.shift(); break;
			case 'E': case 'e': expon = match.shift(); break;
			default: // NOTE: should never get here!
		}
	}

	fract = fract.replace(/0+$/,"");
	if (fract.length < this._parent._minFracDigits) {
		fract = AjxFormat._zeroPad(fract, this._parent._minFracDigits, I18nMsg.numberZero, true);
	}
	
	var a = [ whole ];
	if (fract.length > 0) {
		var decimal = this._parent._isCurrency
		            ? I18nMsg.numberSeparatorMoneyDecimal
		            : I18nMsg.numberSeparatorDecimal;
		a.push(decimal, fract);
	}
	if (expon) {
		a.push('E', expon.replace(/^\+/,""));
	}
	
	// return normalize result
	return a.join("");
};

//
// AjxChoiceFormat class
//

/**
 * The arguments passed to this constructor can be either:
 * <ul>
 * <li>A single argument that represents a string pattern that specifies the 
 *     limits and formats separated by pipe characters (|).
 * <li>Two arguments, an array of limits and and array of format patterns.
 * </ul>
 * <p>
 * For complete details, see the JavaDoc for java.text.ChoiceFormat.
 */
function AjxChoiceFormat(pattern) {
	AjxFormat.call(this, pattern);
	var choices = pattern.split("|");
	if (arguments.length == 1) {
		this._limits = new Array(choices.length);
		this._lessThan = new Array(choices.length);
		this._formats = new Array(choices.length);
		var regex = new RegExp("^([^#<\u2264]+)([#<\u2264])(.*)$");
		for (var i = 0; i < choices.length; i++) {
			var choice = choices[i];
			var results = regex.exec(choice);
			var limit = results[1];
			var separator = results[2];
			var message = results[3];
			// set limit
			if (limit == '\u221E') {
				this._limits[i] = Number.POSITIVE_INFINITY;
			}
			else if (limit == '-\u221E') {
				this._limits[i] = Number.NEGATIVE_INFINITY;
			}
			else {
				this._limits[i] = parseFloat(limit);
			}
			// set less-than
			this._lessThan[i] = separator == '#' || separator == '\u2264';
			// set format
			this._formats[i] = new AjxMessageFormat(message);
		}
	}
	else {
		this._limits = arguments[0];
		this._lessThan = new Array(arguments[0].length);
		this._formats = arguments[1];
		this._pattern = [];
		for (var i = 0; i < this._formats.length; i++) {
			if (i > 0) {
				this._pattern.push("|");
			}
			this._pattern.push(this._limits[i], '#', this._formats[i]);
			this._lessThan[i] = false;
			this._formats[i] = new AjxMessageFormat(this._formats[i]);
		}
		this._pattern = this._pattern.join("");
	}
}
AjxChoiceFormat.prototype = new AjxFormat;
AjxChoiceFormat.prototype.constructor = AjxChoiceFormat;

AjxChoiceFormat.prototype.toString = function() {
	return [
		"[AjxChoiceFormat: ",
		"limits={ ", this._limits.join(", "), " }, ",
		"formats={ ", this._formats.join(", "), " }, ",
		"lessThan={ ", this._lessThan.join(", "), " }]"
	].join("");
};

// Data

AjxChoiceFormat.prototype._limits;
AjxChoiceFormat.prototype._lessThan;
AjxChoiceFormat.prototype._formats;

// Public methods

AjxChoiceFormat.prototype.getLimits = function() {
	return this._limits;
};
AjxChoiceFormat.prototype.getFormats = function() {
	return this._formats;
};

AjxChoiceFormat.prototype.format = function(number) {
	var formatter;
	if (isNaN(number) || number < this._limits[0]) {
		formatter = this._formats[0];
	}
	else {
		for (var i = 0; i < this._limits.length - 1; i++) {
			var a = this._limits[i];
			var b = this._limits[i+1];
			var aGEb = number >= a;
			var aLTb = this._lessThan[i+1] ? number < b : number <= b;
			if (aGEb && aLTb) {
				formatter = this._formats[i];
				break;
			}
		}
		if (!formatter) {
			formatter = this._formats[this._formats.length-1];
		}
	}
	return formatter.format(number);
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxException(msg, code, method, detail) {
	if (arguments.length == 0) return;
	this.msg = msg;
	this.code = code;
	this.method = method;
	this.detail = detail;
}

AjxException.prototype.toString = 
function() {
	return "AjxException";
}

AjxException.prototype.dump = 
function() {
	return "AjxException: msg="+this.msg+" code="+this.code+" method="+this.method+" detail="+this.detail;
}
AjxException.INVALIDPARENT 			= "AjxException.INVALIDPARENT";
AjxException.INVALID_OP 			= "AjxException.INVALID_OP";
AjxException.INTERNAL_ERROR 		= "AjxException.INTERNAL_ERROR";
AjxException.INVALID_PARAM 			= "AjxException.INVALID_PARAM";
AjxException.UNIMPLEMENTED_METHOD 	= "AjxException.UNIMPLEMENTED_METHOD";
AjxException.NETWORK_ERROR 			= "AjxException.NETWORK_ERROR";
AjxException.OUT_OF_RPC_CACHE		= "AjxException.OUT_OF_RPC_CACHE";
AjxException.UNSUPPORTED 			= "AjxException.UNSUPPORTED";
AjxException.UNKNOWN_ERROR 			= "AjxException.UNKNOWN_ERROR";
AjxException.CANCELED				= "AjxException.CANCELED";
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxCookie() {
}

AjxCookie.prototype.toString = 
function() {
	return "AjxCookie";
}

AjxCookie.getCookie = 
function(doc, name) {
	var arg = name + "=";
	var alen = arg.length;
	var clen = doc.cookie.length;
	var cookie = doc.cookie;
	var i = 0;
	while (i < clen) {
		var j = i + alen;
		if (cookie.substring(i, j) == arg) {
			var endstr = cookie.indexOf (";", j);
			if (endstr == -1)
				endstr = cookie.length;
			return unescape(cookie.substring(j, endstr));
		}
		i = cookie.indexOf(" ", i) + 1;
		if (i == 0) 
			break; 
	}
  return null;
}

AjxCookie.setCookie = 
function(doc, name, value, expires, path, domain, secure) {
	doc.cookie = name + "=" + escape (value) +
		((expires) ? "; expires=" + expires.toGMTString() : "") +
		((path) ? "; path=" + path : "") +
		((domain) ? "; domain=" + domain : "") +
		((secure) ? "; secure" : "");
}

AjxCookie.deleteCookie = 
function (doc, name, path, domain) {
	doc.cookie = name + "=" +
	((path) ? "; path=" + path : "") +
	((domain) ? "; domain=" + domain : "") + "; expires=Fri, 31 Dec 1999 23:59:59 GMT";
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxSoapException(msg, code, method, detail) {
	AjxException.call(this, msg, code, method, detail);
}

AjxSoapException.prototype.toString = 
function() {
	return "AjxSoapException";
}

AjxSoapException.prototype = new AjxException;
AjxSoapException.prototype.constructor = AjxSoapException;

AjxSoapException.INTERNAL_ERROR 	= "INTERNAL_ERROR";
AjxSoapException.INVALID_PDU 		= "INVALID_PDU";
AjxSoapException.ELEMENT_EXISTS 	= "ELEMENT_EXISTS";
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/* Represents a SOAP Fault
*
* Public attributes:
*
* - faultCode: The SOAP fault code
* - reason: Reason string
* - errorCode: server error code
*/
function AjxSoapFault(faultEl) {
	if (arguments.length == 0) return;
	var prefix = faultEl.prefix;
	var codeStr = prefix + ":Code";
	var reasonStr = prefix + ":Reason";
	var detailStr = prefix + ":Detail"
	// We will assume a correctly formatted Fault element
	for (var i = 0; i < faultEl.childNodes.length; i++) {
		var childNode = faultEl.childNodes[i];
		if (childNode.nodeName == codeStr) {
			var faultCode = childNode.firstChild.firstChild.nodeValue;
			if (faultCode == (prefix + ":VersionMismatch"))
				this.faultCode = AjxSoapFault.VERSION_MISMATCH;
			else if (faultCode == (prefix + ":MustUnderstand"))
				this.faultCode = AjxSoapFault.MUST_UNDERSTAND;
			else if (faultCode == (prefix + ":DataEncodingUnknown"))
				this.faultCode = AjxSoapFault.DATA_ENCODING_UNKNOWN;
			else if (faultCode == (prefix + ":Sender"))
				this.faultCode = AjxSoapFault.SENDER;
			else if (faultCode == (prefix + ":Receiver"))
				this.faultCode = AjxSoapFault.RECEIVER;
			else
				this.faultCode = AjxSoapFault.UNKNOWN;		
		} else if (childNode.nodeName == reasonStr) {
			this.reason = childNode.firstChild.firstChild.nodeValue;
		} else if (childNode.nodeName == detailStr) {
			this.errorCode = childNode.firstChild.firstChild.firstChild.nodeValue;
		}
	}
}

AjxSoapFault.prototype.toString = 
function() {
	return "AjxSoapFault";
}

AjxSoapFault.SENDER = -1;
AjxSoapFault.RECEIVER = -2;
AjxSoapFault.VERSION_MISMATCH = -3;
AjxSoapFault.MUST_UNDERSTAND = -4;
AjxSoapFault.DATA_ENCODING_UNKNOWN = -5;
AjxSoapFault.UNKNOWN = -6;
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


// Don't directly instantiate SoapDoc, use one of the create factory methods instead
function AjxSoapDoc() {
}

AjxSoapDoc.prototype.toString =
function() {
	return "AjxSoapDoc";
};

AjxSoapDoc._SOAP_URI = "http://www.w3.org/2003/05/soap-envelope";
// AjxSoapDoc._SOAP_URI = "http://schemas.xmlsoap.org/soap/envelope/";
AjxSoapDoc._XMLNS_URI = "http://www.w3.org/2000/xmlns";

AjxSoapDoc.create =
function(method, namespace, namespaceId, soapURI) {
	var sd = new AjxSoapDoc();
	sd._xmlDoc = AjxXmlDoc.create();
	var d = sd._xmlDoc.getDoc();
	var envEl = d.createElement("soap:Envelope");

	if (!soapURI)
		soapURI = AjxSoapDoc._SOAP_URI;
	envEl.setAttribute("xmlns:soap", soapURI);

	d.appendChild(envEl);

	var bodyEl = d.createElement("soap:Body");
	envEl.appendChild(bodyEl);

	sd._methodEl = d.createElement(method);
	if (namespaceId == null)
		sd._methodEl.setAttribute("xmlns", namespace);
	else
		sd._methodEl.setAttribute("xmlns:" + namespaceId, namespace);

	bodyEl.appendChild(sd._methodEl);
	return sd;
};

AjxSoapDoc.createFromDom =
function(doc) {
	var sd = new AjxSoapDoc();
	sd._xmlDoc = AjxXmlDoc.createFromDom(doc);
	sd._methodEl = sd._check(sd._xmlDoc);
	return sd;
};

AjxSoapDoc.createFromXml =
function(xml) {
	var sd = new AjxSoapDoc();
	sd._xmlDoc = AjxXmlDoc.createFromXml(xml);
	sd._methodEl = sd._check(sd._xmlDoc);
	return sd;
};

AjxSoapDoc.element2FaultObj =
function(el) {
	// If the element is not a SOAP fault, then return null
	var faultEl = el.firstChild;
	// Safari is bad at handling namespaces
	if (!AjxEnv.isSafari) {
		if (faultEl != null && faultEl.namespaceURI != AjxSoapDoc._SOAP_URI || faultEl.nodeName != (el.prefix + ":Fault"))
			return null;
	} else {
		if (faultEl != null && faultEl.nodeName != (el.prefix + ":Fault"))
			return null;
	}
	return new AjxSoapFault(faultEl);
};

AjxSoapDoc.prototype.setMethodAttribute =
function(name, value) {
	this._methodEl.setAttribute(name, value);
};

/**
 * Creates arguments to pass within the envelope.  "value" can be a JS object
 * or a scalar (string, number, etc.).
 *
 * When "value" is a JS object, set() will call itself recursively in order to
 * create a complex data structure.  Don't pass a "way-too-complicated" object
 * ("value" should only contain references to simple JS objects, or better put,
 * hashes--don't include a reference to the "window" object as it will kill
 * your browser).
 *
 * Example:
 *
 *    soapDoc.set("user_auth", {
 *       user_name : "foo",
 *       password  : "bar"
 *    });
 *
 * will create an XML like this under the method tag:
 *
 *    <user_auth>
 *      <user_name>foo</user_name>
 *      <password>bar</password>
 *    </user_auth>
 *
 * Of course, nesting other hashes is allowed and will work as expected.
 *
 * NOTE: you can pass null for "name", in which case "value" is expected to be
 * an object whose properties will be created directly under the method el.
 */
AjxSoapDoc.prototype.set = 
function(name, value, parent) {
	var	doc = this.getDoc();
	var	p = name
		? doc.createElement(name)
		: doc.createDocumentFragment();

	if (value != null) {
		if (typeof value == "object") {
			for (i in value)
				this.set(i, value[i], p);
		} else {
			if (AjxEnv.isSafari) value = AjxStringUtil.xmlEncode(value);
			p.appendChild(doc.createTextNode(value));
		}
	}
	if (!parent)
		parent = this._methodEl;
	return parent.appendChild(p);
};

AjxSoapDoc.prototype.getMethod =
function() {
	return this._methodEl;
};

AjxSoapDoc.prototype.createHeaderElement =
function() {
	var d = this._xmlDoc.getDoc();
	var envEl = d.firstChild;
	var header = this.getHeader();
	if (header != null) {
		throw new AjxSoapException("SOAP header already exists", AjxSoapException.ELEMENT_EXISTS, "AjxSoapDoc.prototype.createHeaderElement");
	}
	header = d.createElement("soap:Header")
	envEl.insertBefore(header, envEl.firstChild);
	return header;
};

AjxSoapDoc.prototype.getHeader =
function() {
	// would love to use getElementsByTagNameNS, but IE does not support it
	var d = this._xmlDoc.getDoc();
	var nodeList = AjxEnv.isIE
		? (d.getElementsByTagName(d.firstChild.prefix + ":Header"))
		: (d.getElementsByTagNameNS(AjxSoapDoc._SOAP_URI, "Header"));

	return nodeList ? nodeList[0] : null;
};

AjxSoapDoc.prototype.getBody =
function() {
	// would love to use getElementsByTagNameNS, but IE does not support it
	var d = this._xmlDoc.getDoc();
	var nodeList = AjxEnv.isIE
		? (d.getElementsByTagName(d.firstChild.prefix + ":Body"))
		: (d.getElementsByTagNameNS(AjxSoapDoc._SOAP_URI, "Body"));

	return nodeList ? nodeList[0] : null;
};

AjxSoapDoc.prototype.getByTagName =
function(type) {
	if (type.indexOf(":") == -1)
		type = "soap:" + type;

	var a = this.getDoc().getElementsByTagName(type);

	if (a.length == 1)		return a[0];
	else if (a.length > 0)	return a;
	else					return null;
};

// gimme a header, no exceptions.
AjxSoapDoc.prototype.ensureHeader =
function() {
	return (this.getByTagName("Header") || this.createHeaderElement());
};

AjxSoapDoc.prototype.getDoc =
function() {
	return this._xmlDoc.getDoc();
};

AjxSoapDoc.prototype.getXml =
function() {
	return AjxEnv.isSafari
		? (AjxXmlDoc.getXml(this._xmlDoc.getDoc()))
		: this._xmlDoc.getDoc().xml;
};

// Very simple checking of soap doc. Should be made more comprehensive
AjxSoapDoc.prototype._check =
function(xmlDoc) {
	var doc = xmlDoc.getDoc();
	if (doc.childNodes.length != 1)
		throw new AjxSoapException("Invalid SOAP PDU", AjxSoapException.INVALID_PDU, "AjxSoapDoc.createFromXml:1");

	// Check to make sure we have a soap envelope
	var el = doc.firstChild;

	// Safari is bad at handling namespaces
	if (!AjxEnv.isSafari) {
		if (el.namespaceURI != AjxSoapDoc._SOAP_URI ||
		    el.nodeName != (el.prefix + ":Envelope") ||
		    (el.childNodes.length < 1 || el.childNodes.length > 2))
		{
			DBG.println("<font color=red>XML PARSE ERROR on RESPONSE:</font>");
			DBG.printRaw(doc.xml);
			throw new AjxSoapException("Invalid SOAP PDU", AjxSoapException.INVALID_PDU, "AjxSoapDoc.createFromXml:2");
		}
	} else {
		if (el.nodeName != (el.prefix + ":Envelope"))
			throw new AjxSoapException("Invalid SOAP PDU", AjxSoapException.INVALID_PDU, "AjxSoapDoc.createFromXml:2");
	}
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a new AjxRpcRequest. The request object is an ActiveX object
* for IE, and an XMLHttpRequest object otherwise.
* @constructor
* @class
* This class represents an XML HTTP request, hiding differences between
* browsers. The internal request object depends on the browser.
*
* @param id		[string]	unique ID for this request
* @param ctxt	[_RpcCtxt]	owning context
**/
function AjxRpcRequest(id, ctxt) {
	if (!AjxRpcRequest._inited) 
		AjxRpcRequest._init();
	
	this.id = id;
	this.ctxt = ctxt;
	if (AjxEnv.isIE) {
		this._httpReq = new ActiveXObject(AjxRpcRequest._msxmlVers);
	} else if (AjxEnv.isSafari || AjxEnv.isNav) {
		this._httpReq =  new XMLHttpRequest();
	}
};

AjxRpcRequest._inited = false;
AjxRpcRequest._msxmlVers = null;

AjxRpcRequest.prototype.toString = 
function() {
	return "AjxRpcRequest";
};

/**
* Sends this request to the target URL. If there is a callback, the request is
* performed asynchronously.
*
* @param requestStr		[string]		HTTP request string/document
* @param serverUrl		[string]		request target
* @param requestHeaders	[Array]*		HTTP request headers
* @param callback		[AjxCallback]*	callback (for async requests)
* @param useGet			[boolean]*		if true use GET method, else use POST
*/
AjxRpcRequest.prototype.invoke =
function(requestStr, serverUrl, requestHeaders, callback, useGet, timeout) {

	var asyncMode = (callback != null);
	
	// exception here will be caught by AjxRpc.invoke
	this._httpReq.open((useGet) ? "get" : "post", serverUrl, asyncMode);

	if (asyncMode) {
		this._callback = callback;
		var tempThis = this;
		DBG.println(AjxDebug.DBG3, "Async RPC request");
		this._httpReq.onreadystatechange = function(ev) {AjxRpcRequest._handleResponse(tempThis, callback);};
	} else {
		// IE appears to run handler even on sync requests, so we need to clear it
		this._httpReq.onreadystatechange = function(ev) {};
	}

	if (requestHeaders) {
		for (var i in requestHeaders) {
			this._httpReq.setRequestHeader(i, requestHeaders[i]);
			DBG.println(AjxDebug.DBG3, "Async RPC request: Add header " + i + " - " + requestHeaders[i]);
		}
	}
	
	this._httpReq.send(requestStr);
	if (asyncMode) {
		return this.id;
	} else {
		if (this._httpReq.status == 200) {
			return {text: this._httpReq.responseText, xml: this._httpReq.responseXML, success: true};
		} else {
			return {text: this._httpReq.responseText, xml: this._httpReq.responseXML, success: false, status: this._httpReq.status};
		}
	}
};

/*
* Handler that runs when an asynchronous response has been received. It runs a
* callback to initiate the response handling.
*
* @param req		[AjxRpcRequest]		request that generated the response
* @param callback	[AjxCallback]		callback to run after response is received
*/
AjxRpcRequest._handleResponse =
function(req, callback) {
	if (!req) {
		// If IE receives a 500 error, the object reference can be lost
		DBG.println(AjxDebug.DBG1, "Async RPC request: Lost request object!!!");
		callback.run( {text: null, xml: null, success: false, status: 500} );
		return;
	}

	DBG.println(AjxDebug.DBG3, "Async RPC request: ready state = " + req._httpReq.readyState);
	if (req._httpReq.readyState == 4) {
		if (DBG.getDebugLevel() >= AjxDebug.DBG3)
			DBG.println("Async RPC request: HTTP status = " + req._httpReq.status);
		if (req._httpReq.status == 200) {
			callback.run( {text: req._httpReq.responseText, xml: req._httpReq.responseXML, success: true} );				
		} else {
			callback.run( {text: req._httpReq.responseText, xml: req._httpReq.responseXML, success: false, status: req._httpReq.status} );				
		}
		req.ctxt.busy = false;
	}
};

AjxRpcRequest.prototype.cancel =
function() {
	DBG.println(AjxDebug.DBG1, "Aborting HTTP request");
	this._httpReq.abort();
};

AjxRpcRequest._init =
function() {
	if (AjxEnv.isIE) {
		var msxmlVers = ["MSXML2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"];
		for (var i = 0; i < msxmlVers.length; i++) {
			try {
				// search for the xml version on user's machine
				var x = new ActiveXObject(msxmlVers[i]);
				AjxRpcRequest._msxmlVers = msxmlVers[i];
				break;
			} catch (ex) {
				// do nothing
			}
		}
		if (AjxRpcRequest._msxmlVers == null)
			throw new AjxException("MSXML not installed", AjxException.INTERNAL_ERROR, "AjxRpc._init");
	}
	AjxRpcRequest._inited = true;
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxRpc() {
};

// pool of RPC contexts
AjxRpc._rpcCache = [];

AjxRpc._RPC_CACHE_MAX = 100;	// maximum number of busy contexts we can have
AjxRpc._RPC_REAP_COUNT = 5;		// run reaper when number of busy contexts is multiple of this
AjxRpc._RPC_REAP_AGE = 300000;	// mark any context older than this (in ms) as free

/**
* Submits a request to a URL. The request is handled through a pool of request
* contexts (each a wrapped XmlHttpRequest). The context does the real work.
*
* @param requestStr		[string]		HTTP request string/document
* @param serverUrl		[string]		request target
* @param requestHeaders	[Array]			HTTP request headers
* @param callback		[AjxCallback]	callback (for async requests)
* @param useGet			[boolean]		if true use get method, else use post
*/
AjxRpc.invoke =
function(requestStr, serverUrl, requestHeaders, callback, useGet) {

	var asyncMode = (callback != null);
	var rpcCtxt = AjxRpc._getFreeRpcCtxt();

	try {
	 	var response = rpcCtxt.req.invoke(requestStr, serverUrl, requestHeaders, callback, useGet);
	} catch (ex) {
		var newEx = new AjxException();
		newEx.method = "AjxRpc.prototype._invoke";
		if (ex instanceof Error) {
			newEx.detail = ex.message;
			newEx.code = AjxException.NETWORK_ERROR;
			newEx.msg = "Network error";
		} else {
			newEx.detail = ex.toString();
			newEx.code = AjxException.UNKNOWN_ERROR;
			newEx.msg = "Unknown Error";
		}
		if (!asyncMode)		
			rpcCtxt.busy = false;
		throw newEx;
	}
	if (!asyncMode)
		rpcCtxt.busy = false;

	return response;
};

/*
* Factory method for getting context objects.
*/
AjxRpc._getFreeRpcCtxt = 
function() {

	var rpcCtxt = null;
	
	// See if we have one in the pool that's now free
	for (var i = 0; i < AjxRpc._rpcCache.length; i++) {
		rpcCtxt = AjxRpc._rpcCache[i];
		if (!rpcCtxt.busy) {
			DBG.println(AjxDebug.DBG1, "Found free RPC context: " + rpcCtxt.id);
			break;
		}
	}
	
	// If there's no free context available, create one
	if (i == AjxRpc._rpcCache.length) {
		if (AjxRpc._rpcCache.length == AjxRpc._RPC_CACHE_MAX) {
			DBG.println(AjxDebug.DBG1, "Out of RPC contexts");
			throw new AjxException("Out of RPC cache", AjxException.OUT_OF_RPC_CACHE, "ZmCsfeCommand._getFreeRpcCtxt");
		} else if (i > 0 && (i % AjxRpc._RPC_REAP_COUNT == 0)) {
			DBG.println(AjxDebug.DBG1, i + " busy RPC contexts");
			AjxRpc._reap();
		}
		var id = "_rpcCtxt_" + i;
		rpcCtxt = new _RpcCtxt(id);
		DBG.println(AjxDebug.DBG1, "Created RPC " + id);
		AjxRpc._rpcCache.push(rpcCtxt);
	}
	rpcCtxt.busy = true;
	rpcCtxt.timestamp = (new Date()).getTime();
	return rpcCtxt;
};

/**
* Returns the request from the RPC context with the given ID.
*
* @param id		[string]	RPC context ID
*/
AjxRpc.getRpcRequest = 
function(id) {
	for (var i = 0; i < AjxRpc._rpcCache.length; i++) {
		var rpcCtxt = AjxRpc._rpcCache[i];
		if (rpcCtxt.id == id)
			return rpcCtxt.req;
	}
	return null;
};

/*
* Frees up busy contexts that are older than a certain age.
*/
AjxRpc._reap =
function() {
	var time = (new Date()).getTime();
	for (var i = 0; i < AjxRpc._rpcCache.length; i++) {
		var rpcCtxt = AjxRpc._rpcCache[i];
		if (rpcCtxt.timestamp + AjxRpc._RPC_REAP_AGE < time) {
			DBG.println(AjxDebug.DBG1, "AjxRpc._reap: cleared RPC context " + rpcCtxt.id);
			rpcCtxt.req.cancel();
			rpcCtxt.busy = false;
		}
	}

};

/**
* Wrapper for a request context.
*
* @param id		unique ID for this context
*/
function _RpcCtxt(id) {
	this.id = id;
	this.req = new AjxRpcRequest(id, this);
	this.busy = false;
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxWindowOpener () {
	
}

AjxWindowOpener.PARAM_INSTANCE_ID = "id";
AjxWindowOpener.HELPER_URL = "";
AjxWindowOpener.QUESTION = "?";
AjxWindowOpener.EQUALS = "=";
AjxWindowOpener.QS_SEPARATOR = "&";
AjxWindowOpener.PARAM_ASYNC = "async";

AjxWindowOpener.getUrl = 
function (url) {
	if (!url || url == "") return "";

	var fullUrlArray = new Array();
	var idx = 0;
	
	fullUrlArray[idx++] = url;
	fullUrlArray[idx++] = AjxWindowOpener.QUESTION;
	fullUrlArray[idx++] = AjxWindowOpener.PARAM_INSTANCE_ID;
	fullUrlArray[idx++] = AjxWindowOpener.EQUALS;
	fullUrlArray[idx++] = arguments[1];
	fullUrlArray[idx++] = AjxWindowOpener.QS_SEPARATOR;
	fullUrlArray[idx++] = AjxWindowOpener.PARAM_ASYNC;
	fullUrlArray[idx++] = AjxWindowOpener.EQUALS;
	fullUrlArray[idx++] = arguments[2];
	return fullUrlArray.join("");
};

AjxWindowOpener.openBlank = 
function(windowName, windowArgs, openedCallback, callingObject, asyncCallback) {

	return AjxWindowOpener.open(AjxWindowOpener.HELPER_URL, windowName, 
							   windowArgs, openedCallback, 
							   callingObject, asyncCallback);
};

AjxWindowOpener.open = 
function(url, windowName, windowArgs, openedCallback, callingObject, asyncCallback) {
	var newWin;
	if (url && url != "") {
		var objWrapper = { obj: callingObject, callback: openedCallback };
		var async = asyncCallback || false;
		// only assign an id if we think there will be a callback.
		var id = url && url != "" ? AjxCore.assignId(objWrapper) : -1;
		var localUrl = AjxWindowOpener.getUrl(url, id, async);
		newWin = window.open(localUrl, windowName, windowArgs);
		// EMC: This is some magic that I don't understand. For some custom IE browsers 
		// browser, opening a new debug window, seems to call window.open in 
		// an infinite loop. This line seems to prevent that behavior. So what
		// ever you do ....
		// DON'T REMOVE THIS LINE
		window.status = "opening ...";
		objWrapper.window = newWin;
	} else {
		newWin = window.open("", windowName, windowArgs);
		if (openedCallback) {
			var ta = new AjxTimedAction(callingObject, openedCallback);
			AjxTimedAction.scheduleAction(ta, 0);
		}
	}
	
	return newWin
};

AjxWindowOpener.onWindowOpened = 
function (wrapperId) {
	var wrapper = AjxCore.objectWithId(wrapperId);
	AjxCore.unassignId(wrapperId);
	if (!wrapper.window.closed && wrapper.callback) {
		if (wrapper.obj) {
			wrapper.callback.call(wrapper.obj);
		} else {
			wrapper.callback();
		}
	}
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


// AjxVector class

function AjxVector() {
	this._array = new Array();
};

AjxVector.prototype.toString =
function(sep, compress) {
	if (compress !== true)
		return this._array.join(sep);

	var a = new Array();
	for (var i = 0; i < this._array.length; i++) {
		var x = this._array[i];
		if  (x != undefined && x != null && x != "")
			a.push(x);
	}
	return a.join(sep);
};

AjxVector.fromArray =
function(list) {
	var vec = new AjxVector();
	vec._array.length = 0;
	if (list instanceof Array) {
		vec._array = list;
	}
	return vec;
};

AjxVector.prototype.size =
function() {
	return this._array.length;
};

AjxVector.prototype.add =
function(obj, index) {
	// if index is out of bounds, 
	if (index == null || index < 0 || index >= this._array.length) {
		// append object to the end
		this._array.push(obj);
	} else {
		// otherwise, insert object
		this._array.splice(index, 0, obj);
	}
};

AjxVector.prototype.addList =
function(list) {
	if (!list) return;
	
	if ((list instanceof Array) && list.length)
		this._array = this._array.concat(list);
	else if ((list instanceof AjxVector) && list.size())
		this._array = this._array.concat(list._array);
};

AjxVector.prototype.remove = 
function(obj) {
	for (var i = 0; i < this._array.length; i++) {
		if (this._array[i] == obj) {
			this._array.splice(i,1);
			return true;
		}
	}
	return false;
};

AjxVector.prototype.removeAt =
function(index) {
	if (index >= this._array.length || index < 0)
		return null;
	
	var delArr = this._array.splice(index,1);
	var ret = null;
	if (delArr) {
		ret = delArr[0];
	}
	return ret;
};

AjxVector.prototype.removeAll = 
function() {
	// Actually blow away the array items so that garbage
	// collection can take place (XXX: does this really force GC?)
	for (var i = 0; i < this._array.length; i++)
		this._array[i] = null;
	this._array.length = 0;
};

AjxVector.prototype.removeLast = 
function() {
	return this._array.length > 0 ? this._array.pop() : null;
};

AjxVector.prototype.replace =
function(index, newObj) {
	var oldObj = this._array[index];
	this._array[index] = newObj;
	return oldObj;
};

/**
* Returns the index of the obj given w/in vector
*
* @param obj			the object being looked for
*/
AjxVector.prototype.indexOf = 
function(obj) {
	for (var i = 0; i < this._array.length; i++) {
		if (this._array[i] == obj)
			return i;
	}
	return -1;
};

AjxVector.prototype.clone =
function() {
	var vec = new AjxVector();
	vec.addList(this);
	return vec;
};

AjxVector.prototype.contains = 
function(obj) {
	for (var i = 0; i < this._array.length; i++) {
		if (this._array[i] == obj)
			return true;
	}
	return false;
};

/**
* Returns true if the vector contains the given object, using the given 
* function to compare objects. The comparison function should return a 
* type for which the equality test (==) is meaningful, such as a string 
* or a base type.
*
* @param obj			the object being looked for
* @param compareFunc	a function for comparing objects
*/
AjxVector.prototype.containsLike = 
function(obj, compareFunc) {
	var value = compareFunc.call(obj);
	for (var i = 0; i < this._array.length; i++) {
		var test = compareFunc.call(this._array[i]);
		if (test == value)
			return true;
	}
	return false;
};

AjxVector.prototype.get =
function(index) {
	return index >= this._array.length || index < 0
		? null : this._array[index];
};

AjxVector.prototype.getArray =
function() {
	return this._array;
};

AjxVector.prototype.getLast =
function() {
	return this._array.length == 0
		? null : this._array[this._array.length-1];
};

AjxVector.prototype.sort =
function(sortFunc) {
	if (!sortFunc) {
		sortFunc = AjxVector._defaultArrayComparator;
	}
	this._array.sort(sortFunc);
};

AjxVector.prototype.binarySearch = 
function(valueToFind, sortFunc) {
	if (!sortFunc) {
		sortFunc = AjxVector._defaultArrayComparator;
	}
	
	var l = 0;
	var arr = this._array;
	var u = arr.length - 1;

	while(true) {
		if (u < l) {
			return -1;
		}

		var i = Math.floor((l + u)/ 2);
		var comparisonResult = sortFunc(valueToFind, arr[i]);

		if (comparisonResult < 0) {
			u = i - 1;
		} else if (comparisonResult > 0) {
			l = i + 1;
		} else {
			return i;
		}
	}
};

AjxVector.prototype.merge =
function(offset, list) {

	if (offset < 0)
		return;
	
	var rawList = list instanceof AjxVector ? list.getArray() : list;
	
	var limit = this._array.length < (offset+rawList.length)
		? this._array.length 
		: offset+rawList.length;
		
	if (offset < this._array.length) {
		// replace any overlapping items in vector
		var count = 0;
		for (var i=offset; i<limit; i++)
			this._array[i] = rawList[count++];
		
		// and append the rest
		if (count < rawList.length)
			this._array = this._array.concat(rawList.slice(count));
	} else {
		// otherwise, just append the raw list to the end
		this._array = this._array.concat(rawList);
	}
};


// Static methods

AjxVector._defaultArrayComparator = 
function(a, b) {
	return a < b ? -1 : (a > b ? 1 : 0);
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Does nothing (static class).
* @constructor
* @class
* This class provides static methods to perform miscellaneous string-related utility functions.
*
* @author Ross Dargahi
* @author Roland Schemers
* @author Conrad Damon
*/
function AjxStringUtil() {
}

/**
* Removes white space from the beginning and end of a string, optionally compressing internal white space. By default, white
* space is defined as a sequence of  Unicode whitespace characters (\s in regexes). Optionally, the user can define what
* white space is by passing it as an argument.
*
* <p>TODO: add left/right options</p>
*
* @param str      	the string to trim
* @param compress 	whether to compress internal white space to one space
* @param space    	a string that represents a user definition of white space
* @returns			a trimmed string
*/

AjxStringUtil.TRIM_RE = /^\s+|\s+$/g;
AjxStringUtil.COMPRESS_RE = /\s+/g;
AjxStringUtil.ELLIPSIS = " ... ";

AjxStringUtil.makeString =
function(val) {
	return val ? String(val) : "";
};

AjxStringUtil.trim =
function(str, compress, space) {

	if (!str) return "";

	var trim_re = AjxStringUtil.TRIM_RE;

	var compress_re = AjxStringUtil.COMPRESS_RE;
	if (space) {
		trim_re = new RegExp("^" + space + "+|" + space + "+$", "g");
		compress_re = new RegExp(space + "+", "g");
	} else {
		space = " ";
	}
	str = str.replace(trim_re, '');
	if (compress)
		str = str.replace(compress_re, space);
	
	return str;		
}

/**
* Returns the string repeated the given number of times.
*
* @param str		a string
* @param num		number of times to repeat the string
*/
AjxStringUtil.repeat =
function(str, num) {
	var text = "";
	for (var i = 0; i < num; i++)
		text += str;
	return text;
}

AjxStringUtil.getUnitsFromSizeString = 
function(sizeString) {
	var units="px";
	if(typeof(sizeString) == "string") {
		var digitString=Number(parseInt(sizeString)).toString();
		if(sizeString.length > digitString.length) {
			units = sizeString.substr(digitString.length, (sizeString.length-digitString.length));
			if(!(units=="em" || units=="ex" || units=="px" || units=="in" || units=="cm" == units=="mm" || units=="pt" || units=="pc" || units=="%")) {
				units="px";
			}
		}
	}
	return units;
}

/**
* Splits a string, ignoring delimiters that are in quotes or parentheses. Comma 
* is the default split character, but the user can pass in a string of multiple 
* delimiters. It can handle nested parentheses, but not nested quotes.
*
* <p>TODO: handle escaped quotes</p>
*
* @param str	the string to split
* @param dels	an optional string of delimiter characters
* @returns		an array of strings
*/
AjxStringUtil.split =
function(str, dels) {

	if (!str) return new Array();

	dels = dels ? dels : ',';
	var isDel = new Object;
	if (typeof dels == 'string') {
		isDel[dels] = 1;
	} else {
		for (var i = 0; i < dels.length; i++) 
			isDel[dels[i]] = 1;
	}

	var q = false;
	var p = 0;
	var start = 0;
	var chunk;
	var chunks = new Array();
	var j = 0;
	for (var i = 0; i < str.length; i++) {
		var c = str.charAt(i);
		if (c == '"') {
			q = !q;
		} else if (c == '(') {
			p++;
		} else if (c == ')') {
			p--;
		} else if (isDel[c]) {
			if (!q && !p) {
				chunk = str.substring(start, i);
				chunks[j++] = chunk;
				start = i + 1;
			}
		}
	}
	chunk = str.substring(start, str.length);
	chunks[j++] = chunk;

	return chunks;
}

/**
* Wraps text to the given length and quotes it, breaking on space when possible. 
* Preserves line breaks. At this point, it assumes that the text to be wrapped 
* is raw text, not HTML, and that line returns are represented by '\n'. Wrapping 
* is optionally done across line returns that appear in paragraphs.
*
* @param text 		the text to be wrapped
* @param len		the desired line length of the wrapped text, defaults to 80
* @param pre		an optional string to prepend to each line (useful for quoting)
* @param eol		the eol sequence for each wrapped line, defaults to '\n'
* @param breakOkay	whether long words (longer than <code>len</code>) can be broken, default is false
* @param compress	remove single returns within a paragraph before wrapping
* @returns			the wrapped/quoted text
*/
AjxStringUtil.wordWrap = 
function(text, len, pre, eol, breakOkay, compress) {

	if (!text) return "";

	len = len ? len : 80;
	eol = eol ? eol : '\n';
	pre = pre ? pre : '';
	len -= pre.length;
	
	var chunks = new Array();
	var c = 0;
	
	// preprocess the text: remove leading/trailing space, space at the end of 
	// lines, and set up for wrapping paragraphs
	text = AjxStringUtil.trim(text, false);
	text = text.replace(/[ \t]+\n/g, '\n'); // optional tidying, could remove this step
	if (compress)
		text = text.replace(/\b\n\b/g, ' ');
	var textLen = text.length;
	// Wrap text by dividing it into chunks. We remember the last space we saw, 
	// and use it to begin a chunk when the length limit is reached.
	for (var i = 0, bk = 0, sp = -1; i < textLen; i++) {
		var ch = text.charAt(i);
		if (ch.match(/[ \t]/)) { // found a space
			sp = i;
		}
		if (ch == '\n') { // found a return
			chunks[c++] = pre + text.substring(bk, i);
			bk = i + 1; // skip the \n (those are added later in the join)
			sp = -1;
		}
		if (i - bk >= len) { // hit the limit
			if (sp == -1) { // current chunk is bigger than the limit (a 'long' word)
				if (breakOkay) {
					chunks[c++] = pre + text.substring(bk, i);
					bk = i;
					sp = -1;
				}
			} else {				
				chunks[c++] = pre + text.substring(bk, sp);
				bk = sp + 1;
				sp = -1;
			}
		}
	}
	// add remaining portion
	if (i > bk) {
		chunks[c++] = pre + text.substring(bk, i);
	}
	return chunks.join(eol) + eol;
}

/**
* Returns true if the character for the given key is considered printable.
*
* @param keycode	a numeric keycode (not a character code)
* @returns 			true if the character for the given key is considered printable
*/

AjxStringUtil.IS_PRINT_CODE = new Object();
var print_codes = [32,48,49,50,51,52,53,54,55,56,57,59,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
                   81,82,83,84,85,86,87,88,89,90,96,97,98,99,100,101,102,103,104,105,106,107,109,110,111,186,
                   187,188,189,190,191,192,219,220,221,222];
var l = print_codes.length;
for (var i = 0; i < l; i++) {
	AjxStringUtil.IS_PRINT_CODE[print_codes[i]] = true;
}

AjxStringUtil.isPrintKey =
function(keycode) {
	return AjxStringUtil.IS_PRINT_CODE[keycode];
}

/**
* Returns the character for the given key, taking the shift key into consideration.
*
* @param keycode	a numeric keycode (not a character code)
* @param shifted	whether the shift key is down
* @returns			a character
*/

AjxStringUtil.SHIFT_CHAR = { 48:')', 49:'!', 50:'@', 51:'#', 52:'$', 53:'%', 54:'^', 55:'&', 56:'*', 57:'(',
							59:':', 186:':', 187:'+', 188:'<', 189:'_', 190:'>', 191:'?', 192:'~',
							219:'{', 220:'|', 221:'}', 222:'"' }

AjxStringUtil.shiftChar =
function(keycode, shifted) {
	return shifted ? AjxStringUtil.SHIFT_CHAR[keycode] || String.fromCharCode(keycode) : String.fromCharCode(keycode);
}

/**
* Does a diff between two strings, returning the index of the first differing character.
*
* @param str1	a string
* @param str2	another string
* @returns		the index at which they first differ
*/
AjxStringUtil.diffPoint =
function(str1, str2) {
	if (!(str1 && str2))
		return 0;
	var len = Math.min(str1.length, str2.length);
	var i = 0;
	while (i < len && (str1.charAt(i) == str2.charAt(i)))
		i++;
	return i;
}

/**
* DEPRECATED
*
* Replaces variables in a string with values from a list. The variables are 
* denoted by a '$' followed by a number, starting from 0. For example, a string 
* of "Hello $0, meet $1" with a list of ["Harry", "Sally"] would result in the 
* string "Hello Harry, meet Sally".
*
* @param str		the string to resolve
* @param values	 	an array of values to interpolate
* @returns			a string with the variables replaced
*/
AjxStringUtil.resolve =
function(str, values) {
	DBG.println(AjxDebug.DBG1, "Call to deprecated function AjxStringUtil.resolve");
	return AjxMessageFormat.format(str, values);
/*
	if (!str) return "";
	if (!(values instanceof Array)) values = [values];
	if (!AjxEnv.isSafari)
		return str.replace(/\$(\d+)/g, function(str, num) { return values[num]; });

	//quick hack
	var match;
	while ((match = str.match(/\$(\d+)/)) != null) {
		var d = match[1];
		var re = new RegExp("\\$"+d);
		str = str.replace(re, values[d]);
	}
	return str;
*/
}

/**
* URL-encodes a string. Replace spaces with + then escape and any + become %2B 
* for for transport in URL's.
*
* @param str	the string to encode
*/

AjxStringUtil.urlEncode =
function(str) {
	if (!str) return "";
	return escape(str.replace(/ /g, '+')).replace(/[+]/g, '%2B');
}		

/**
* HTML-encodes a string.
*
* @param str	the string to encode
*/

AjxStringUtil.ENCODE_MAP = { '>' : '&gt;', '<' : '&lt;', '&' : '&amp;' };

AjxStringUtil.htmlEncode =
function(str, includeSpaces) {
	if (!str) return "";

	if (!AjxEnv.isSafari) {
		if (includeSpaces) 
			return str.replace(/[<>&]/g, function(htmlChar) { return AjxStringUtil.ENCODE_MAP[htmlChar]; }).replace(/  /g, ' &nbsp;');
		else
			return str.replace(/[<>&]/g, function(htmlChar) { return AjxStringUtil.ENCODE_MAP[htmlChar]; });
	} else {
		if (includeSpaces) 
			return str.replace(/[&]/g, '&amp;').replace(/  /g, ' &nbsp;').replace(/[<]/g, '&lt;').replace(/[>]/g, '&gt;');
		else
			return str.replace(/[&]/g, '&amp;').replace(/[<]/g, '&lt;').replace(/[>]/g, '&gt;');
	}
}		

AjxStringUtil.convertToHtml = function(str) {
	if (!str) return "";
	str = str
		.replace(/&/mg, "&amp;")
		.replace(/  /mg, " &nbsp;")
		.replace(/^ /mg, "&nbsp;")
		.replace(/\t/mg, "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;")
		.replace(/</mg, "&lt;")
		.replace(/>/mg, "&gt;")
		.replace(/\r?\n/mg, "<br />");
	return str;
};

/**
* HTML-encodes a string.
*
* @param str	the string to encode
*/

AjxStringUtil.SPACE_ENCODE_MAP = { ' ' : '&nbsp;', '>' : '&gt;', '<' : '&lt;', '&' : '&amp;' , '\n': '<br>'};

AjxStringUtil.htmlEncodeSpace =
function(str) {
	if (!str) return "";

	if (!AjxEnv.isSafari) {
		return str.replace(/[ <>&\n]/g, function(htmlChar) { return AjxStringUtil.SPACE_ENCODE_MAP[htmlChar]; });
	} else {
		return str.replace(/[&]/g, '&amp;').replace(/ /g, '&nbsp;').replace(/[<]/g, '&lt;').replace(/[>]/g, '&gt;');
	}
}

// this function makes sure a leading space is preservered, takes care of tabs, 
// then finally takes replaces newlines with <br>'s
AjxStringUtil.nl2br = 
function(str) {
	if (!str) return "";
	return str.replace(/^ /mg, "&nbsp;").replace(/\t/g, "<pre style='display:inline;'>\t</pre>").replace(/\n/g, "<br>");
}

AjxStringUtil.xmlEncode = 
function(str) {
	return str ? str.replace(/&/g,"&amp;").replace(/</g,"&lt;") : "";
}
AjxStringUtil.xmlDecode =
function(str) {
	return str ? str.replace(/&amp;/g,"&").replace(/&lt;/g,"<") : "";
}

AjxStringUtil.xmlAttrEncode =
function(str) {
	return str ? str.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\x22/g, '&quot;').replace(/\x27/g,"&apos;") : "";
}

AjxStringUtil.xmlAttrDecode =
function(str) {
	return str ? str.replace(/&amp;/g,"&").replace(/&lt;/g,"<").replace(/&quot;/g, '"').replace(/&apos;/g,"'") : "";
}

AjxStringUtil.regExEscape =
function(str) {
	return str.replace(/(\W)/g, "\\$1");
};

var AjxStringUtil_calcDIV = null; // used by 'clip()' and 'wrap()' functions

AjxStringUtil.calcDIV =
function() {
	if (AjxStringUtil_calcDIV == null) {
		AjxStringUtil_calcDIV = document.createElement("div");
		AjxStringUtil_calcDIV.style.zIndex = 0;
		AjxStringUtil_calcDIV.style.position = DwtControl.ABSOLUTE_STYLE;
		AjxStringUtil_calcDIV.style.visibility = "hidden";
		document.body.appendChild(AjxStringUtil_calcDIV);
	}
	return AjxStringUtil_calcDIV;
}

/**
 * Clips a string at "pixelWidth" using using "className" on hidden 'AjxStringUtil._calcDIV'.
 * Returns "origString" with "..." appended if clipped.
 *
 * NOTE: The same CSS style ("className") must be assigned to both the intended 
 * display area and the hidden 'AjxStringUtil._calcDIV'.  "className" is 
 * optional; if supplied, it will be assigned to 'AjxStringUtil._calcDIV' to 
 * handle different CSS styles ("className"s) on same page.
 *
 * NOTE2: MSIE Benchmark - clipping an average of 17 characters each over 190 
 * iterations averaged 27ms each (5.1 seconds total for 190)
 */
AjxStringUtil.clip =
function(origString, pixelWidth, className) {
	var calcDIV = AjxStringUtil.calcDIV();
	if (arguments.length == 3) calcDIV.className = className;
	//calcDIV.innerHTML = "<div>" + origString + "</div>"; // prevents screen flash in IE?
	calcDIV.innerHTML = origString;
	if (calcDIV.offsetWidth <= pixelWidth) return origString;

	for (var i=origString.length-1; i>0; i--) {
		var newString = origString.substr(0,i);
		calcDIV.innerHTML = newString + AjxStringUtil.ELLIPSIS;
		if (calcDIV.offsetWidth <= pixelWidth) return newString + AjxStringUtil.ELLIPSIS;
	}
	return origString;
}

/**
 * Forces a string to wrap at "pixelWidth" using "className" on hidden 'AjxStringUtil._calcDIV'.
 * Returns "origString" with "&lt;br&gt;" tags inserted to force wrapping.
 * Breaks string on embedded space characters, EOL ("/n") and "&lt;br&gt;" tags when possible.
 *
 * @returns		"origString" with "&lt;br&gt;" tags inserted to force wrapping.
 */
AjxStringUtil.wrap =
function(origString, pixelWidth, className) {
	var calcDIV = AjxStringUtil.calcDIV();
	if (arguments.length == 3) calcDIV.className = className;

	var newString = "";
	var newLine = "";
	textRows = origString.split("/n");
	for (var trCount=0; trCount<textRows.length; trCount++) {
		if (trCount != 0) {
			newString += newLine + "<br>";
			newLine = "";
		}
		htmlRows = textRows[trCount].split("<br>");
		for (var hrCount=0; hrCount<htmlRows.length; hrCount++) {
			if (hrCount != 0) {
				newString += newLine + "<br>";
				newLine = "";
			}
			words = htmlRows[hrCount].split(" ");
			var wCount=0;
			while (wCount<words.length) {
				calcDIV.innerHTML = newLine + " " + words[wCount];
				var newLinePixels = calcDIV.offsetWidth;
				if (newLinePixels > pixelWidth) {
					// whole "words[wCount]" won't fit on current "newLine" - insert line break, avoid incrementing "wCount"
					calcDIV.innerHTML = words[wCount];
					newLinePixels = newLinePixels - calcDIV.offsetWidth;
					if ( (newLinePixels >= pixelWidth) || (calcDIV.offsetWidth <= pixelWidth) ) {
						// either a) excess caused by <space> character or b) will fit completely on next line
						// so just break without incrementing "wCount" and append next time
						newString += newLine + "<br>";
						newLine = "";
					}
					else { // must break "words[wCount]"
						var keepLooping = true;
						var atPos = 0;
						while (keepLooping) {
							atPos++;
							calcDIV.innerHTML = newLine + " " + words[wCount].substring(0,atPos);
							keepLooping = (calcDIV.offsetWidth <= pixelWidth);
						}
						atPos--;
						newString += newLine + words[wCount].substring(0,atPos) + "<br>";
						words[wCount] = words[wCount].substr(atPos);
						newLine = "";
					}
				} else { // doesn't exceed pixelWidth, append to "newLine" and increment "wCount"
					newLine += " " + words[wCount];
					wCount++;
				}
			}
		}
	}
	newString += newLine;
	return newString;
}

// Regexes for finding non-quoted content
AjxStringUtil.MSG_SEP_RE = new RegExp("^\\s*--+\\s*(" + "Original Message" + "|" + "Forwarded Message" + ")\\s*--+", "i");
AjxStringUtil.SIG_RE = /^(- ?-+)|(__+)\r?$/;
AjxStringUtil.COLON_RE = /\S+:$/;
AjxStringUtil.PREFIX_RE = /^\s*(>|\|)/;
AjxStringUtil.BRACKET_RE = /^\s*\[.+\]\s*$/;
AjxStringUtil.LINE_RE = /^\s*_{30,}\s*$/;
AjxStringUtil.BLANK_RE = /^\s*$/;
AjxStringUtil.HDR_RE = /^\s*\w+:/;

/**
* Returns a list of chunks of top-level content in a message body. Top-level content is what was
* actually typed by the sender. We attempt to exclude quoted content and signatures.
*
* The following lines/blocks (and variants) and any text after them are ignored:
*
* 		----- Original Message -----
*
* 		----- Forwarded Message -----
*
*		-- 
*		some signature text
*
*		______________________________		|
*											| Outlook 2003 does this
*		From:								|
*
* Lines that begin with a prefix character ("&gt;" or "|") are ignored. The following
* lines/blocks are ignored if they precede a line that begins with a prefix character:
*
* 		Fred Flintstone <fred@bedrock.org> wrote:
*
* 		Fred Flintstone <fred@bedrock.org> wrote:
*		[snipped]
*
* Since quoted text may be interleaved with original text, we may return several chunks of
* original text. That is so they may be separated when they are quoted.
*
* @param text		a message body
* @param eol		the eol sequence, defaults to '\n'
*/
AjxStringUtil.getTopLevel =
function(text, eol) {
	eol = eol ? eol : '\n';
	text = AjxStringUtil._trimBlankLines(text, eol);
	var lines = text.split(eol);
	var len = lines.length;
	var i = 0, start = 0;
	var chunks = new Array();
	var skipping = false;
	while (i < len) {
		var wasSkipping = skipping;
		var skip = AjxStringUtil._linesToSkip(lines, i);
		skipping = (skip > 0);
		if (wasSkipping && !skipping)
			start = i;
		else if (!wasSkipping && skipping && i > start)
			chunks.push(AjxStringUtil._trimBlankLines(lines.slice(start, i).join(eol), eol) + eol);
		i += skipping ? skip : 1;
	}
	if (!skipping && i > start)
		chunks.push(AjxStringUtil._trimBlankLines(lines.slice(start, i).join(eol), eol) + eol);

	return chunks;
}

// Starting at a given line, returns the number of lines that should be skipped because
// they are quoted (or signature) content.
AjxStringUtil._linesToSkip =
function(lines, i) {
	var len = lines.length;
	var skip = 0;
	var start = i;
	if (AjxStringUtil.MSG_SEP_RE.test(lines[i])) {
		skip = len - i;
	} else if (AjxStringUtil.SIG_RE.test(lines[i])) {
		skip = len - i;
	} else if (AjxStringUtil.PREFIX_RE.test(lines[i])) {
		while (i < lines.length && (AjxStringUtil.PREFIX_RE.test(lines[i]) || AjxStringUtil.BLANK_RE.test(lines[i])))
			i++;
		skip = i - start;
	} else if (AjxStringUtil.COLON_RE.test(lines[i])) {
		var idx = AjxStringUtil._nextNonBlankLineIndex(lines, i + 1);
		var line1 = (idx != -1) ? lines[idx] : null;
		if (line1 && AjxStringUtil.PREFIX_RE.test(line1)) {
			skip = idx - i;
		} else {
			if (idx != -1)
				idx = AjxStringUtil._nextNonBlankLineIndex(lines, idx + 1);
			var line2 = (idx != -1) ? lines[idx] : null;
			if (line2 && AjxStringUtil.BRACKET_RE.test(line1) && AjxStringUtil.PREFIX_RE.test(line2))
				skip = idx - i;
		}
	} else if (AjxStringUtil.LINE_RE.test(lines[i])) {
		var idx = AjxStringUtil._nextNonBlankLineIndex(lines, i + 1);
		var line1 = (idx != -1) ? lines[idx] : null;
		if (line1 && AjxStringUtil.HDR_RE.test(line1))
			skip = len - i;
	}
	return skip;
}

// Returns the index of the next non-blank line
AjxStringUtil._nextNonBlankLineIndex =
function(lines, i) {
	while (i < lines.length && AjxStringUtil.BLANK_RE.test(lines[i]))
		i++;
	return ((i < lines.length) ? i : -1);
}

// Removes blank lines from the beginning and end of text
AjxStringUtil._trimBlankLines =
function(text, eol) {
	eol = eol ? eol : '\n';
	var lines = text.split(eol);
	var len = lines.length;
	var i = 0;
	while (i < len && AjxStringUtil.BLANK_RE.test(lines[i]))
		i++;
	var j = len;
	while (j > 0 && AjxStringUtil.BLANK_RE.test(lines[j - 1]))
		j--;
	if (i != 0 || j != len)
		text = lines.slice(i, j).join(eol) + eol;

	return text;
}

/**
* Converts a HTML document represented by a DOM tree  to text
*
* There has got to be a better way of doing this! 
*/

AjxStringUtil._NO_LIST = 0;
AjxStringUtil._ORDERED_LIST = 1;
AjxStringUtil._UNORDERED_LIST = 2;
AjxStringUtil._INDENT = "    ";
AjxStringUtil._NON_WHITESPACE = /\S+/;
AjxStringUtil._LF = /\n/;

AjxStringUtil.convertHtml2Text =
function(domRoot) {
	if (!domRoot) return null;
	var text = new Array();
	var idx = 0;
	var ctxt = new Object();
	this._traverse(domRoot, text, idx, AjxStringUtil._NO_LIST, 0, 0, ctxt);
	var textStr = text.join("");
	return textStr;
}

AjxStringUtil._traverse =
function(el, text, idx, listType, listLevel, bulletNum, ctxt) {
	var nodeName = el.nodeName.toLowerCase();

	if (nodeName == "#text") {
		if (el.nodeValue.search(AjxStringUtil._NON_WHITESPACE) != -1) {
			if (ctxt.lastNode == "ol" || ctxt.lastNode == "ul")
				text[idx++] = "\n";
			text[idx++] = AjxStringUtil.trim(el.nodeValue.replace(AjxStringUtil._LF, " "), true) + " ";
		}
	} else if (nodeName == "p") {
		text[idx++] = "\n\n";
	} else if (listType == AjxStringUtil._NO_LIST && (nodeName == "br" || nodeName == "hr")) {
		text[idx++] = "\n";
	} else if (nodeName == "ol" || nodeName == "ul") {
		text[idx++] = "\n";
		if (el.parentNode.nodeName.toLowerCase() != "li" && ctxt.lastNode != "br"
			&& ctxt.lastNode != "hr")
			text[idx++] = "\n";
		listType = (nodeName == "ol") ? AjxStringUtil._ORDERED_LIST : AjxStringUtil._UNORDERED_LIST;
		listLevel++;
		bulletNum = 0;
	} else if (nodeName == "li") {
		for (var i = 0; i < listLevel; i++)
			text[idx++] = AjxStringUtil._INDENT;
		if (listType == AjxStringUtil._ORDERED_LIST)
			text[idx++] = bulletNum + ". ";
		else
			text[idx++] = "\u2022 "; // TODO LmMsg.bullet
	} else if (nodeName == "img") {
		if (el.alt && el.alt != "")
			text[idx++] = el.alt; 
	} else if (nodeName == "tr" && el.parentNode.firstChild != el) {
		text[idx++] = "\n";
	} else if (nodeName == "td" && el.parentNode.firstChild != el) {
		text[idx++] = "\t";
	} else if (nodeName == "div") {
		text[idx++] = "\n";
	} else if (nodeName == "#comment" || 
			   nodeName == "script" || 
			   nodeName == "select" ||
			   nodeName == "style") {
		return idx;
	}
	
	var childNodes = el.childNodes;
	var len = childNodes.length;
	for (var i = 0; i < len; i++) {
		if (nodeName == "ol")
			bulletNum++;
		idx = this._traverse(childNodes[i], text, idx, listType, listLevel, bulletNum, ctxt);
	}

	if (nodeName == "h1" || nodeName == "h2" || nodeName == "h3" || nodeName == "h4" 
		|| nodeName == "h5" || nodeName == "h6") {
			text[idx++] = "\n";
			ctxt.list = false;
	} else if (nodeName == "li") {
		if (!ctxt.list)
			text[idx++] = "\n";
		ctxt.list = false;
	} else if (nodeName == "ol" || nodeName == "ul") {
		ctxt.list = true;
	} else if (nodeName != "#text") {
		ctxt.list = false;
	}
	
	ctxt.lastNode = nodeName;
	return idx;	
}

/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a new debug window. The document inside is not kept open.  All the 
  output goes into a single &lt;div&gt; element.
* @constructor
* @class
* This class pops up a debug window and provides functions to send output there 
* in various ways. The output is continuously appended to the bottom of the 
* window. The document is left unopened so that the browser doesn't think it's 
* continuously loading and keep its little icon flailing forever. Also, the DOM 
* tree can't be manipulated on an open document. All the output is added to the 
* window by appending it the DOM tree. Another method of appending output is to 
* open the document and use document.write(), but then the document is left open.
* <p>
* Any client that uses this class can turn off debugging by changing the first 
* argument to the constructor to AjxDebug.NONE.
*
* @author Conrad Damon
* @author Ross Dargahi
* @param level	 	debug level for the current debugger (no window will be displayed for a level of NONE)
* @param name 		the name of the window. Defaults to "debug_" prepended to the calling window's URL.
* @param showTime	a boolean that toggles the display of timestamps before debug messages
*/
function AjxDebug(level, name, showTime) {
	this._dbgName = "AjxDebugWin_" + location.hostname.replace(/\./g,'_');
	this._level = level;
	this._showTime = showTime;
	this._enabled = (this._level != AjxDebug.NONE);
	this._showTiming = false;
	this._startTimePt = this._lastTimePt = 0;
	this._dbgWindowInited = false;

	this._msgQueue = new Array();
	AjxDebug._CONTENT_FRAME_ID = AjxDebug._CONTENT_FRAME_ID;
	this._isPrevWinOpen = false;
	if (!this._enabled) return;

	this._openDebugWindow();
};


AjxDebug.NONE = "DBG0"; // no debugging (window will not come up)
AjxDebug.DBG1 = "DBG1"; // minimal debugging
AjxDebug.DBG2 = "DBG2"; // moderate debugging
AjxDebug.DBG3 = "DBG3"; // anything goes
AjxDebug.PERF = "PERF"; // performance timings

// map from number to debug level
AjxDebug.DBG = new Object();
AjxDebug.DBG[-1] = AjxDebug.PERF;
AjxDebug.DBG[0] = AjxDebug.NONE;
AjxDebug.DBG[1] = AjxDebug.DBG1;
AjxDebug.DBG[2] = AjxDebug.DBG2;
AjxDebug.DBG[3] = AjxDebug.DBG3;

// map from debug level to number
AjxDebug.GBD = {};
AjxDebug.GBD[AjxDebug.PERF] = -1;
AjxDebug.GBD[AjxDebug.NONE] = 0;
AjxDebug.GBD[AjxDebug.DBG1] = 1;
AjxDebug.GBD[AjxDebug.DBG2] = 2;
AjxDebug.GBD[AjxDebug.DBG3] = 3;

AjxDebug.MAX_OUT = 25000; // max length capable of outputting

AjxDebug._LINK_FRAME_ID = "AjxDebug_LF";
AjxDebug._CONTENT_FRAME_ID = "AjxDebug_CF";
AjxDebug._BUTTON_FRAME_ID = "AjxDebug_BF";

AjxDebug._id = 0;
AjxDebug._openErrors = 0;

AjxDebug.prototype.toString = 
function() {
	return "AjxDebug";
}

/**
* Set debug level. May open or close the debug window if moving to or from level NONE.
*
* @param level	 	debug level for the current debugger
*/
AjxDebug.prototype.setDebugLevel = 
function(level) {
	if (level == this._level) return;

	this._level = level;
	if (level == AjxDebug.NONE) {
		this._enabled = false;
		this._debugWindow.close();
		this._debugWindow = null;
	} else {
		this._enabled = true;
		if (this._debugWindow == null || this._debugWindow.closed)
			this._openDebugWindow();
	}
};

AjxDebug.prototype.getDebugLevel = 
function(level) {
	return this._level;
};

AjxDebug.prototype.isShowTiming = 
function() {
	return this._showTiming;
};

/**
* Turn the display of timing statements on/off. Timing starts over any time it's turned on.
*
* @param on		whether to display timing statements
*/
AjxDebug.prototype.showTiming = 
function(on, level, msg) {
	this._showTiming = on;

	if (on) {
		this._startTimePt = this._lastTimePt = 0;

		var a = [];
		for (var i = 1; i < arguments.length; i++)
			a.push(arguments[i]);

		var args = this._handleArgs(a);
		if (args) {
			var msgLevel = AjxDebug.DBG1;
			if (String(level).match(/^DBG|PERF/))
				msgLevel = level;

			this.println(msgLevel, " ----- " + args[0] + " ----- ");
		}
	}
	this._startTimePt = this._lastTimePt = new Date().getTime();
};

/**
* Prints a debug message. Any HTML will be rendered, and a line break is added.
*
* @param level	 	debug level for the current debugger
* @param msg		the text to display
*/
AjxDebug.prototype.println = 
function(level, msg, linkName) {
	if (this.isDisabled() || this._debugWindow.closed) return;
	var args = this._handleArgs(arguments, linkName);
	if (!args) return;

	msg = args.join("");
	/*** DEBUG ***
	if (String(level).match(/^DBG|PERF/)) {
		msg = level + ": " + msg;
	}
	/*** DEBUG ***/
	this._add(this._timestamp() + msg + "<br>", null, null, null, linkName);
};

AjxDebug.prototype.isDisabled = 
function () {
	return !this._enabled;
};

/**
* Prints an object into a table, with a column for properties and a column for values. Above the table is a header with the object
* class and the CSS class (if any). The properties are sorted (numerically if they're all numbers). Creating and appending table 
* elements worked in Mozilla but not IE. Using the insert* methods works for both. Properties that are function 
* definitions are skipped.
*
* @param level	 	debug level for the current debugger
* @param obj		the object to be printed
* @param showFuncs	whether to show props that are functions
*/
AjxDebug.prototype.dumpObj = 
function(level, obj, showFuncs, linkName) {
	if (this.isDisabled() || this._debugWindow.closed)return;
	var args = this._handleArgs(arguments, linkName);
	if (!args) return;
	obj = args[0];
	if (!obj) return;
	this._showFuncs = args[1];

	AjxDebug._visited = new AjxVector();
	this._add(null, obj);
	this._showFuncs = null;
};

/**
* Dumps a bunch of text into a &lt;textarea&gt;, so that it is wrapped and scrollable. HTML will not be rendered.
*
* @param level	 	debug level for the current debugger
* @param text		the text to output as is
*/
AjxDebug.prototype.printRaw = 
function(level, text, linkName) {
	if (this.isDisabled() || this._debugWindow.closed) return;
	var args = this._handleArgs(arguments, linkName);
	if (!args) return;
	text = args[0];
	
	this._add(null, text, false, true);
};

/**
* Pretty-prints a chunk of XML, doing color highlighting for different types of nodes.

* @param level	 	debug level for the current debugger
* @param text		some XML
*/
AjxDebug.prototype.printXML = 
function(level, text, linkName) {
	if (this.isDisabled() || this._debugWindow.closed) return;
	var args = this._handleArgs(arguments, linkName);
	if (!args) return;
	text = args[0];
	if (!text) return;
	
	// skip generating pretty xml if theres too much data
	if (AjxEnv.isSafari || text.length > AjxDebug.MAX_OUT) {
		this.printRaw(text);
		return;
	}
	this._add(null, text, true, false);
};

/**
* Reveals white space in text by replacing it with tags.
*
* @param level	 	debug level for the current debugger
* @param text		the text to be displayed
*/
AjxDebug.prototype.display =
function(level, text) {
	if (this.isDisabled() || this._debugWindow.closed) return;
	var args = this._handleArgs(arguments);
	if (!args) return;
	text = args[0];

	text = text.replace(/\r?\n/g, '[crlf]');
	text = text.replace(/ /g, '[space]');
	text = text.replace(/\t/g, '[tab]');
	this.printRaw(level, text);
};

AjxDebug.prototype.timePt =
function(level, msg) {
	if (!this._showTiming || !this._enabled || this._debugWindow.closed) return;
	
	var args = this._handleArgs(arguments);
	if (!args) return;
	var msg = args[0];
	
	var now = new Date().getTime();
	var elapsed = now - this._startTimePt;
	var interval = now - this._lastTimePt;
	this._lastTimePt = now;
	var text = "[" + elapsed + " / " + interval + "]";
	if (msg)
		text += " " + msg;
	html = "<div>" + text + "</div>";
	extraType = typeof(text);

    var myMsg = new DebugMessage(html);
	
    // Add the message to our stack
    this._addMessage(myMsg);
	return interval;
};


// Private methods

AjxDebug.prototype._getHtmlForObject = 
function(anObj, isXml, isRaw) {
	var html = new Array();
	var idx = 0;

	if (AjxUtil.isUndefined(anObj)) {
		html[idx++] = "<span>Undefined</span>";
	} else if (AjxUtil.isNull(anObj)) {
		html[idx++] = "<span>NULL</span>";
	} else if (AjxUtil.isBoolean(anObj)) {
		html[idx++] = "<span>" + anObj + "</span>";
	} else if (AjxUtil.isNumber(anObj)) {
		html[idx++] = "<span>" + anObj +"</span>";
	} else {
		if (isRaw) {
			html[idx++] = this._timestamp();
			html[idx++] = "<textarea rows='25' style='width:100%' readonly='true'>";
			html[idx++] = anObj;
			html[idx++] = "</textarea>";
			html[idx++] = "<p></p>";
		} else if (isXml) {
			var xmldoc = new AjxDebugXmlDocument;
			var doc = xmldoc.create();
			doc.loadXML(anObj);
			html[idx++] = "<div style='border-width:2px; border-style:inset; width:100%; height:300px; overflow:auto'>";
			html[idx++] = this._createXmlTree(doc, 0);
			html[idx++] = "</div>";
		} else {
			html[idx++] = "<div style='border-width:2px; border-style:inset; width:100%; height:300px; overflow:auto'>";
			html[idx++] = "<pre>";
			html[idx++] = this._dump(anObj, true);
			html[idx++] = "</div>";
			html[idx++] = "</pre>";
		}
	}
	return html.join("");
};

// Pretty-prints a Javascript object
AjxDebug.prototype._dump =
function(obj, recurse) {

	var indentLevel = 0;
	var showBraces = false;
	var stopRecursion = false;
	if (arguments.length > 2) {
		indentLevel = arguments[2];
		showBraces = arguments[3];
		stopRecursion = arguments[4];
	}

	if (AjxUtil.isObject(obj)) {
		if (obj.toString() == "ZmAppCtxt"){
			return "[ZmAppCtxt]";
		}
		if (AjxDebug._visited.contains(obj))
			return "[visited object]";
		else
			AjxDebug._visited.add(obj);
	}	

	var indent = AjxStringUtil.repeat(" ", indentLevel);
	var text = "";
	
	if (AjxUtil.isUndefined(obj)) {
		text += "[undefined]";
	} else if (AjxUtil.isNull(obj)) {
		text += "[null]";
	} else if (AjxUtil.isBoolean(obj)) {
		text += obj ? "true" : "false";
	} else if (AjxUtil.isString(obj)) {
	//	obj = obj.replace(/\r/g, "\\r");
	//	obj = obj.replace(/\n/g, "\\n");
	//	obj = obj.replace(/\t/g, "\\t");
		text += '"' + AjxDebug._escapeForHTML(obj) + '"';
	} else if (AjxUtil.isNumber(obj)) {
		text += obj;
	} else if (AjxUtil.isObject(obj)) {
		var isArray = AjxUtil.isArray(obj);
		if (stopRecursion) {
			text += isArray ? "[Array]" : obj.toString();
		} else {
			stopRecursion = !recurse;
			var keys = new Array();
			for (var i in obj)
				keys.push(i);

			isArray ? keys.sort(function(a,b) {return a - b;}) : keys.sort();	
	

			if (showBraces)
				text += isArray ? "[" : "{";
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				var nextObj = obj[key];
				var value = null;
				// 5/31/05 EMC:
				// For dumping events, and dom elements, though I may not want to
				// traverse the node, I do want to know what the attribute is.
				if (nextObj == window || nextObj == document || (!AjxEnv.isIE && nextObj instanceof Node)){
					value = nextObj.toString();
				} 
				if ((typeof(nextObj) == "function")){
					if (this._showFuncs) {
						value = "[function]";
					} else {
						continue;
					}
				}

				if (i > 0) text += ",";
				text += "\n" + indent;
				if (value != null) {
					text += key + ": " + value;
				} else {
					text += key + ": " + this._dump(nextObj, recurse, indentLevel + 2, true, stopRecursion);
				}
			}
			if (i > 0)
				text += "\n" + AjxStringUtil.repeat(" ", indentLevel - 1);
			if (showBraces)
				text += isArray ? "]" : "}";
		}
	}
	return text;
};

// If the first arg is a debug level, check it and then strip it.
AjxDebug.prototype._handleArgs =
function(args, linkNameSpecified) {
	if (this._level == AjxDebug.NONE) return;
	
	var levelSpecified = false;
	var curLevel = AjxDebug.GBD[this._level];
	var msgLevel = AjxDebug.GBD[AjxDebug.DBG1];
	if (typeof args[0] == "string" && String(args[0]).match(/^DBG|PERF/)) {
		msgLevel = AjxDebug.GBD[args[0]];
		levelSpecified = true;
	}
	if (msgLevel > curLevel) return;
	
	// NOTE: Can't just slice the items we want because args is not an Array
	var array = new Array(args.length);
	var len = (linkNameSpecified) ? args.length - 1 : args.length;
	for (var i = 0; i < len; i++) {
		array[i] = args[i];
	}
	if (levelSpecified) { array.shift(); }
	return array;
};

AjxDebug.prototype._getCookieVal =
function (cookieName) {
	var myRE = cookieName  + "=([^;]+)";
	var myVals = document.cookie.match(new RegExp(myRE));
	var val = null;
	// Return the last value defined (if found)
	if (myVals && (myVals.length > 0)) {
		var valStr = myVals[myVals.length-1];
		if (valStr == "true") {
			val = true;
		} else if (valStr == "false") {
			val = false;
		} else {
			val = valStr;
		}
	}
	return val;
};

AjxDebug.prototype._openDebugWindow =
function() {
	this._enabled = true;
	// check if there is a debug window already open
	this._isPrevWinOpen = this._getCookieVal("AjxDebugWinOpen");
	if (!this._isPrevWinOpen) {
		this._debugWindow = AjxWindowOpener.openBlank(this._dbgName, "width=600,height=400,resizable=yes,scrollbars=yes", this._initWindow, this);
	} else {
		this._debugWindow = window.open("" , this._dbgName, "width=600,height=400,resizable=yes,scrollbars=yes");
		this._initWindow();
	}
};


AjxDebug.prototype._initWindow =
function() {
	if (this._debugWindow == null) {
		this._enabled = false;
		return;
	}
	
	try {
		this._document = this._debugWindow.document;
		this._document.title = "Debug";

		if (!this._isPrevWinOpen) {
			this._document.write([
				"<html>",
					"<head>",
						"<script>",
							"function blank() {return [",
								"'<html><head><style type=\"text/css\">',",
									"'P, TD, DIV, SPAN, SELECT, INPUT, TEXTAREA, BUTTON {',",
											"'font-family: Tahoma, Arial, Helvetica, sans-serif;',",
											"'font-size:11px;}',",
									"'.Link {cursor: pointer;color:blue;text-decoration:underline;white-space:nowrap;width:100%;}',",		
									"'.Mark {color:white; background-color:black; width:100%;font-size:14px;font-weight:bold;}',",
									"'.MarkLink {cursor: pointer;color:white;background-color:black;text-decoration:underline;font-weight:bold;white-space:nowrap;width:100%;}',",
									"'.Run {color:black; background-color:red;width:100%;font-size:18px;font-weight:bold;}',",
									"'.RunLink {cursor: pointer;color:black;background-color:red;text-decoration:underline;font-weight:bold;white-space:nowrap;width:100%;}',",
								"'</style></head><body></body></html>'].join(\"\");}",
						"</script>",
					"</head>",
					"<frameset cols='125, *'>",
						"<frameset rows='*,40'>",
							"<frame name='", AjxDebug._LINK_FRAME_ID, "' id='", AjxDebug._LINK_FRAME_ID, "' src='javascript:parent.parent.blank();'>",
							"<frame name='", AjxDebug._BUTTON_FRAME_ID, "' id='", AjxDebug._BUTTON_FRAME_ID, "' src='javascript:parent.parent.blank();'>",
						"</frameset>",
						"<frame name='", AjxDebug._CONTENT_FRAME_ID, "' id='", AjxDebug._CONTENT_FRAME_ID, "' src='javascript:parent.blank();'>",
					"</frameset>",
				"</html>"].join(""));
			var ta = new AjxTimedAction(this, AjxDebug.prototype._finishInitWindow);
			AjxTimedAction.scheduleAction(ta, 250);
		} else {
			this._contentFrame = this._document.getElementById(AjxDebug._CONTENT_FRAME_ID);
			this._linkFrame = this._document.getElementById(AjxDebug._LINK_FRAME_ID);
			this._createLinkNContent(this, "RunLink", "NEW RUN", "Run", "NEW RUN");
			
			// Firefox allows us to attach an event listener, and runs it even
			// though the window with the code is gone ... odd, but nice. IE,
			// though will not run the handler, so we make sure, even if we're
			// coming back to the window, to attach the onunload handler. In general
			// reattach all handlers for IE
			if (AjxEnv.isIE) {
				this._debugWindow.attachEvent('onunload', AjxDebug.unloadHandler);
				this._markBtn.onclick = AjxDebug._mark;
				this._clearBtn.onclick = AjxDebug._clear;
			}		
				
			this._dbgWindowInited = true;
			// show any messages that have been queued up, while the window loaded.
			this._showMessages();
		}
	} catch (ex) {
		AjxDebug.deleteWindowCookie();
		this._debugWindow.close();

		// If we've exceeded a certain # of errors, just close window and bail.
		if (AjxDebug._openErrors < 5) {
			AjxDebug._openErrors++;
			this._openDebugWindow();
		}
	}
};

AjxDebug.prototype._finishInitWindow =
function() {
	this._contentFrame = this._document.getElementById(AjxDebug._CONTENT_FRAME_ID);
	this._linkFrame = this._document.getElementById(AjxDebug._LINK_FRAME_ID);

	// Create the mark and clear buttons
	var buttonFrame = this._document.getElementById(AjxDebug._BUTTON_FRAME_ID);
	var buttonFrameDoc = buttonFrame.contentWindow.document;
	var buttonFrameBody = buttonFrameDoc.body;
	
	var markBtn = this._markBtn = buttonFrameDoc.createElement("button");
	markBtn.innerHTML = "Mark";
	markBtn._dbg = this;
	markBtn.onclick = AjxDebug._mark;

	var clearBtn = this._markBtn = buttonFrameDoc.createElement("button");
	clearBtn._contentFrameId = AjxDebug._CONTENT_FRAME_ID;
	clearBtn._linkFrameId = AjxDebug._LINK_FRAME_ID;
	clearBtn.innerHTML = "Clear";
	clearBtn._dbg = this;
	clearBtn.onclick = AjxDebug._clear;
	
	buttonFrameBody.appendChild(markBtn);
	buttonFrameBody.appendChild(buttonFrameDoc.createTextNode(" "));
	buttonFrameBody.appendChild(clearBtn);


	// If we're not using a div
	// Set a cookie telling ourselves that a debug window is already open
	document.cookie = "AjxDebugWinOpen=true";
	
	// setup an onunload method
	if (!AjxEnv.isIE) {
		this._debugWindow.onunload = AjxDebug.unloadHandler;
		window.addEventListener('unload', AjxDebug.myWindowUnloadHandler, true);
	} else {
		this._debugWindow.attachEvent('onunload', AjxDebug.unloadHandler);
		window.attachEvent = AjxDebug.myWindowUnloadHandler;
	}

	this._dbgWindowInited = true;
	this._showMessages();
};


/**
* Scrolls to the bottom of the window. How it does that depends on the browser.
*
* @private
*/
AjxDebug.prototype._scrollToBottom = 
function() {
	if (AjxEnv.isIE) {
		this._contentFrame.contentWindow.document.body.scrollIntoView(false);
		this._linkFrame.contentWindow.document.body.scrollIntoView(false);
	} else {
		this._contentFrame.contentWindow.scrollTo(0, this._contentFrame.contentWindow.document.body.offsetHeight);
		this._linkFrame.contentWindow.scrollTo(0, this._linkFrame.contentWindow.document.body.offsetHeight);
	}
};

/**
* Returns a timestamp string, if we are showing them.
* @private
*/
AjxDebug.prototype._timestamp = 
function() {
	return this._showTime 
		? AjxDateFormat.getTimeInstance().format(new Date()) + ": " 
		: "";
};

AjxDebug.prototype.setShowTimestamps = 
function(show) {
	this._showTime = show;
};

// this function takes an xml node and returns an html string that displays that node
// the indent argument is used to describe what depth the node is at so that
// the html code can create a nice indention
AjxDebug.prototype._createXmlTree = 
function (node, indent) {

	if (node == null)
		return "";
	var str = "";
	
	switch (node.nodeType) {
		case 1:	// Element
			str += "<div style='color: blue; padding-left: 16px;'>&lt;<span style='color: DarkRed;'>" + node.nodeName + "</span>";
			
			var attrs = node.attributes;
			for (var i = 0; i < attrs.length; i++)
				str += this._createXmlAttribute(attrs[i]);
			
			if (!node.hasChildNodes())
				return str + "/&gt;</div>";
			
			str += "&gt;<br />";
			
			var cs = node.childNodes;
			for (var i = 0; i < cs.length; i++)
				str += this._createXmlTree(cs[i], indent + 3);
			
			str += "&lt;/<span style='color: DarkRed;'>" + node.nodeName + "</span>&gt;</div>";
			break;
	
		case 9:	// Document
			var cs = node.childNodes;
			for (var i = 0; i < cs.length; i++)
				str += this._createXmlTree(cs[i], indent);
			break;
	
		case 3:	// Text
			if (!/^\s*$/.test(node.nodeValue)) {
				var val = node.nodeValue.replace(/</g, "&lt;").replace(/>/g, "&gt;");
				str += "<span style='color: WindowText; padding-left: 16px;'>" + val + "</span><br />";
			}
			break;
	
		case 7:	// ProcessInstruction
			str += "&lt;?" + node.nodeName;
		
			var attrs = node.attributes;
			for (var i = 0; i < attrs.length; i++)
				str += this._createXmlAttribute(attrs[i]);
			
			str+= "?&gt;<br />"
			break;
	
		case 4:	// CDATA
			str = "<div style=''>&lt;![CDATA[<span style='color: WindowText; font-family: \"Courier New\"; white-space: pre; display: block; border-left: 1px solid Gray; padding-left: 16px;'>" + 
				node.nodeValue +
			"</span>]" + "]></div>";
			break;
			
		case 8:	// Comment
			str = "<div style='color: blue; padding-left: 16px;'>&lt;!--<span style='white-space: pre; font-family: \"Courier New\"; color: Gray; display: block;'>" + 
				node.nodeValue +
			"</span>--></div>";
			break;
		
		case 10:
				str = "<div style='color: blue; padding-left: 16px'>&lt;!DOCTYPE " + node.name;
				if (node.publicId) {
					str += " PUBLIC \"" + node.publicId + "\"";
					if (node.systemId) 
						str += " \"" + node.systemId + "\"";
				}
				else if (node.systemId) {
					str += " SYSTEM \"" + node.systemId + "\"";
				}
				str += "&gt;</div>";
				
				// TODO: Handle custom DOCTYPE declarations (ELEMENT, ATTRIBUTE, ENTITY)
				
				break;
		
		default:
			//alert(node.nodeType + "\n" + node.nodeValue);
			this._inspect(node);
	}
	
	return str;
};

AjxDebug.prototype._createXmlAttribute = 
function(a) {
	return " <span style='color: red'>" + a.nodeName + "</span><span style='color: blue'>=\"" + a.nodeValue + "\"</span>";
};

AjxDebug.prototype._inspect = 
function(obj) {
	var str = "";
	for (var k in obj)
		str += "obj." + k + " = " + obj[k] + "\n";
	window.alert(str);
};

AjxDebug.prototype._add = 
function (aMsg, extraInfo, isXml, isRaw, linkName){
	var extraType = typeof(extraInfo);

	if (AjxUtil.isSpecified(extraInfo))
		extraInfo = this._getHtmlForObject(extraInfo, isXml, isRaw);

    // Add the message to our stack
    this._addMessage(new DebugMessage(aMsg, null, null, null, extraInfo, linkName));

};

AjxDebug.prototype._addMessage = 
function (aMsg) {
	this._msgQueue[this._msgQueue.length] = aMsg;
	this._showMessages();
};

donola=false;
AjxDebug.prototype._showMessages = 
function () {
	if (!this._dbgWindowInited) {
		// For now, don't show the messages-- assuming that this case only 
		// happens at startup, and many  messages will be written
		return;
	}
	
	if (this._msgQueue.length > 0) {
		var msg;
		var contentDiv;
		var linkDiv;
		var contentFrameDoc = this._contentFrame.contentWindow.document;
		var linkFrameDoc = this._linkFrame.contentWindow.document;
		
		for (var i = 0 ; i < this._msgQueue.length ; ++i ) {
			var now = new Date();
			msg = this._msgQueue[i];
			contentDiv = contentFrameDoc.createElement('div');
			contentDiv.innerHTML = [msg.message, msg.eHtml].join("");
			if (msg.linkName) {
				linkDiv = linkFrameDoc.createElement('div');
				linkDiv._targetId = contentDiv.id = [AjxDebug._getNextId(), now.getMilliseconds()].join("");
				linkDiv._dbg = this;
				linkDiv.className = "Link";
				linkDiv.onclick = AjxDebug._linkClicked;
				linkDiv.innerHTML = msg.linkName  + " - [" + AjxDebug._getTimeStamp(now) + "]";;	
				linkFrameDoc.body.appendChild(linkDiv);
				//linkFrameDoc.body.appendChild(linkFrameDoc.createElement("br"));
			}
			contentFrameDoc.body.appendChild(contentDiv);		
		}
	}

	this._msgQueue.length = 0;
	this._scrollToBottom();
};

AjxDebug._linkClicked =
function() {
	var el = this._dbg._contentFrame.contentWindow.document.getElementById(this._targetId);
	var y = 0;
	while (el) {
		y += el.offsetTop;
		el = el.offsetParent;
	}
	
	this._dbg._contentFrame.contentWindow.scrollTo(0, y);	
};

AjxDebug._getNextId =
function() {
	return "AjxDebug_" + AjxDebug._id++;
};

AjxDebug.prototype._parseHtmlFragment = 
function (htmlStr) {
	var div = this._contentFrame.contentWindow.document.createElement('div');	
	div.innerHTML = htmlStr;
	return div;
};


// Static methods

AjxDebug._mark = 
function() {
	this._dbg._createLinkNContent(this._dbg, "MarkLink", "MARK", "Mark", "MARK");
};

AjxDebug.prototype._createLinkNContent =
function(ajxDbgObj, linkClass, linkLabel, contentClass, contentLabel) {
	var now = new Date();
	var timeStamp = [" - [", AjxDebug._getTimeStamp(now), "]"].join("");
	var linkFrameDoc = ajxDbgObj._linkFrame.contentWindow.document;
	var div = linkFrameDoc.createElement("div");
	div.className = linkClass;
	div.innerHTML = linkLabel + timeStamp;
	var id = "Lnk_" + now.getMilliseconds();
	div._targetId = id;
	div._dbg = ajxDbgObj;
	div.onclick = AjxDebug._linkClicked
	linkFrameDoc.body.appendChild(div);
	//linkFrameDoc.body.appendChild(linkFrameDoc.createElement("br"));
	
	var contentFrameDoc = ajxDbgObj._contentFrame.contentWindow.document;
	div = contentFrameDoc.createElement("div");
	div.className = contentClass;
	div.id = id;
	div.innerHTML = contentLabel + timeStamp;
	div._dbg = ajxDbgObj;
	contentFrameDoc.body.appendChild(contentFrameDoc.createElement("p"));
	contentFrameDoc.body.appendChild(div);
	contentFrameDoc.body.appendChild(contentFrameDoc.createElement("p"));
};

AjxDebug._clear = 
function() {
	this._dbg._contentFrame.contentWindow.document.body.innerHTML = "";
	this._dbg._linkFrame.contentWindow.document.body.innerHTML = "";	
};

AjxDebug.myWindowUnloadHandler = 
function() {
	if (AjxEnv.isNav) {
		DBG._debugWindow.onunload = null;
	} else {
		DBG._debugWindow.detachEvent('onunload', AjxDebug.unloadHandler);
	}
};

AjxDebug.unloadHandler = 
function() {
	try {
		window.AjxDebug.deleteWindowCookie();
	} catch (ex) {
		// do nothing. This might be caused by the unload handler
		// firing while the window is changing domains.
	}
};

AjxDebug.deleteWindowCookie = 
function() {
    var expiredDate = new Date('Fri, 31 Dec 1999 23:59:59 GMT'); // I18n???
	document.cookie = "AjxDebugWinOpen=false;expires=" + expiredDate.toGMTString();
};

AjxDebug._escapeForHTML = 
function(str){
	if (typeof(str) != 'string') return str;
	var s = str;
	s = s.replace(/\&/g, '&amp;');
	s = s.replace(/\</g, '&lt;');
	s = s.replace(/\>/g, '&gt;');
	s = s.replace(/\"/g, '&quot;');
	s = s.replace(/\xA0/g, '&nbsp;');	
	return s;
};

AjxDebug._getTimeStamp =
function(date) {
	date = (date) ? date : new Date();
	return AjxStringUtil.htmlEncode([AjxDateUtil.getTimeStr(date, "%H:%m:%s"), ".", date.getMilliseconds()].join(""), true);
};

/**
 * Simple wrapper for log messages
 */
DebugMessage = function(aMsg, aType, aCategory, aTime, extraHtml, linkName) {
    this.message = (AjxUtil.isSpecified(aMsg)) ? aMsg : '';
    this.type = aType ? aType : null;
    this.category = aCategory ? aCategory : '';
    this.time = aTime ? aTime : (new Date().getTime());
    this.eHtml = extraHtml ? extraHtml : '';
    this.linkName = linkName;
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


// XmlDocument factory
function AjxDebugXmlDocument() {
}

// used to find the Automation server name
function getDomDocumentPrefix() {
	if (getDomDocumentPrefix.prefix)
		return getDomDocumentPrefix.prefix;
	
	var prefixes = ["MSXML2", "Microsoft", "MSXML", "MSXML3"];
	var o;
	for (var i = 0; i < prefixes.length; i++) {
		try {
			// try to create the objects
			o = new ActiveXObject(prefixes[i] + ".DomDocument");
			return getDomDocumentPrefix.prefix = prefixes[i];
		}
		catch (ex) {};
	}
	
	throw new Error("Could not find an installed XML parser");
}

AjxDebugXmlDocument.prototype.create = 
function () {
	try {
		// DOM2
		if (document.implementation && document.implementation.createDocument) {
			var doc = document.implementation.createDocument("", "", null);
			
			// some versions of Moz do not support the readyState property
			// and the onreadystate event so we patch it!
			if (doc.readyState == null) {
				doc.readyState = 1;
				doc.addEventListener("load", function () {
					doc.readyState = 4;
					if (typeof doc.onreadystatechange == "function")
						doc.onreadystatechange();
				}, false);
			}
			
			return doc;
		}
		if (window.ActiveXObject)
			return new ActiveXObject(getDomDocumentPrefix() + ".DomDocument");
	}
	catch (ex) {}
	throw new Error("Your browser does not support XmlDocument objects");
}

// Create the loadXML method and xml getter for Mozilla
if (window.DOMParser &&
	window.XMLSerializer &&
	window.Node && Node.prototype && Node.prototype.__defineGetter__) {
	// XMLDocument did not extend the Document interface in some versions
	// of Mozilla. Extend both!
	AjxDebugXmlDocument.prototype.loadXML = function(s) {
	//Document.prototype.loadXML = function (s) {
		
		// parse the string to a new doc	
		var doc2 = (new DOMParser()).parseFromString(s, "text/xml");
		
		// remove all initial children
		while (this.hasChildNodes())
			this.removeChild(this.lastChild);
			
		// insert and import nodes
		for (var i = 0; i < doc2.childNodes.length; i++)
			this.appendChild(this.importNode(doc2.childNodes[i], true));
	};
	
	
	/*
	 * xml getter
	 * This serializes the DOM tree to an XML String
	 * Usage: var sXml = oNode.xml
	 */
	// XMLDocument did not extend the Document interface in some versions
	// of Mozilla. Extend both!
	AjxDebugXmlDocument.prototype.__defineGetter__("xml", function () {
		return (new XMLSerializer()).serializeToString(this);
	});
	/*
	Document.prototype.__defineGetter__("xml", function () {
		return (new XMLSerializer()).serializeToString(this);
	});
	*/
}
/*
 * Copyright (C) 2006, The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// Don't directly instantiate AjxXmlDoc, use one of the create factory methods instead
function AjxXmlDoc() {
	if (!AjxXmlDoc._inited)
		AjxXmlDoc._init();
}

AjxXmlDoc.prototype.toString =
function() {
	return "AjxXmlDoc";
}

AjxXmlDoc._inited = false;
AjxXmlDoc._msxmlVers = null;

AjxXmlDoc.create =
function() {
	var xmlDoc = new AjxXmlDoc();
	var newDoc = null;
	if (AjxEnv.isIE) {
		newDoc = new ActiveXObject(AjxXmlDoc._msxmlVers);
		newDoc.async = true; // Force Async loading
		if (AjxXmlDoc._msxmlVers == "MSXML2.DOMDocument.4.0") {
			newDoc.setProperty("SelectionLanguage", "XPath");
			newDoc.setProperty("SelectionNamespaces", "xmlns:zimbra='urn:zimbra' xmlns:mail='urn:zimbraMail' xmlns:account='urn:zimbraAccount'");
		}
	} else if (document.implementation && document.implementation.createDocument) {
		newDoc = document.implementation.createDocument("", "", null);
	} else {
		throw new AjxException("Unable to create new Doc", AjxException.INTERNAL_ERROR, "AjxXmlDoc.create");
	}
	xmlDoc._doc = newDoc;
	return xmlDoc;
}

AjxXmlDoc.createFromDom =
function(doc) {
	var xmlDoc = new AjxXmlDoc();
	xmlDoc._doc = doc;
	return xmlDoc;
}

AjxXmlDoc.createFromXml =
function(xml) {
	var xmlDoc = AjxXmlDoc.create();
	xmlDoc.loadFromString(xml);
	return xmlDoc;
}

AjxXmlDoc.getXml =
function(node) {
	var ser = new XMLSerializer();
	return ser.serializeToString(node);
}

AjxXmlDoc.prototype.getDoc =
function() {
	return this._doc;
}

AjxXmlDoc.prototype.loadFromString =
function(str) {
	var doc = this._doc;
	doc.loadXML(str);
	if (AjxEnv.isIE) {
		if (doc.parseError.errorCode != 0)
			throw new AjxException(doc.parseError.reason, AjxException.INVALID_PARAM, "AjxXmlDoc.loadFromString");
	}
}

AjxXmlDoc.prototype.loadFromUrl =
function(url) {
	this._doc.load(url);
}

/**
 * This function tries to create a JavaScript representation of the DOM.  Why,
 * because it's so much fun to work with JS objets rather than do DOM lookups
 * using getElementsByTagName 'n stuff.
 *
 * Rules:
 *
 *   1. The top-level tag gets lost; only it's content is seen important.
 *   2. Each node will be represented as a JS object.  It's textual content
 *      will be saved in node.__msh_content (returned by toString()).
 *   3. Attributes get discarded; this might not be good in general but it's OK
 *      for the application I have in mind now.  IAE, I'll be able to fix this if
 *      anyone requires--mail mihai@zimbra.com.
 *   4. Each subnode will map to a property with its tagName in the parent
 *      node.  So, parent[subnode.tagName] == subnode.
 *   5. If multiple nodes with the same tagName have the same parent node, then
 *      parent[tagName] will be an array containing the objects, rather than a
 *      single object.
 *
 * So what this function allows us to do is for instance this:
 *
 * XML doc:
 *
 * <error>
 *   <code>404</code>
 *   <name>Not Found</name>
 *   <description>Page wasn't found on this server.</description>
 * </error>
 *
 * var obj = AjxXmlDoc.createFromXml(XML).toJSObject();
 * alert(obj.code + " " + obj.name + " " + obj.description);
 *
 * Here's an array example:
 *
 * <return>
 *   <item>
 *     <name>John Doe</name>
 *     <email>foo@bar.com</email>
 *   </item>
 *   <item>
 *     <name>Johnny Bravo</name>
 *     <email>bravo@cartoonnetwork.com</email>
 *   </item>
 * </return>
 *
 * var obj = AjxXmlDoc.createFromXml(XML).toJSObject();
 * for (var i = 0; i < obj.item.length; ++i) {
 *   alert(obj.item[i].name + " / " + obj.item[i].email);
 * }
 *
 * Note that if there's only one <item> tag, then obj.item will be an object
 * rather than an array.  And if there is no <item> tag, then obj.item will be
 * undefined.  These are cases that the calling application must take care of.
 */
AjxXmlDoc.prototype.toJSObject = 
function(dropns, lowercase, withAttrs) {
	function _node() { this.__msh_content = ''; };
	_node.prototype.toString = function() { return this.__msh_content; };
	function rec(i, o) {
		var tags = {}, t, n;
		for (i = i.firstChild; i; i = i.nextSibling) {
			if (i.nodeType == 1) {
				t = i.tagName;
				if (dropns)      t = t.replace(/^.*?:/, "");
				if (lowercase)   t = t.toLowerCase();
				n = new _node();
				if (tags[t]) {
					if (tags[t] == 1) {
						o[t] = [ o[t] ];
						tags[t] = 2;
					}
					o[t].push(n);
				} else {
					o[t] = n;
					tags[t] = 1;
				}
				//do attributes
				if(withAttrs) {
					if(i.attributes && i.attributes.length) {
						for(var ix = 0;ix<i.attributes.length;ix++) {
							attr = i.attributes[ix];
							n[attr.name] = AjxUtil.isNumeric(attr.value) ? attr.value : String(attr.value);
						}
					}
				}
				rec(i, n);
			} else if (i.nodeType == 3)
				o.__msh_content += i.nodeValue;
		}
	};
	var o = new _node();
	rec(this._doc.documentElement, o);
	return o;
};

AjxXmlDoc.prototype.getElementsByTagNameNS = 
function(ns, tag) {
	var doc = this.getDoc();
	return AjxEnv.isIE
		? doc.getElementsByTagName(ns + ":" + tag)
		: doc.getElementsByTagNameNS(ns, tag);
};

AjxXmlDoc.prototype.getFirstElementByTagNameNS = 
function(ns, tag) {
	return this.getElementsByTagNameNS(ns, tag)[0];
};

AjxXmlDoc._init =
function() {
	if (AjxEnv.isIE) {
		var msxmlVers = ["MSXML4.DOMDocument", "MSXML3.DOMDocument", "MSXML2.DOMDocument.4.0",
				 "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument",
				 "Microsoft.XmlDom"];
		for (var i = 0; i < msxmlVers.length; i++) {
			try {
				new ActiveXObject(msxmlVers[i]);
				AjxXmlDoc._msxmlVers = msxmlVers[i];
				break;
			} catch (ex) {
			}
		}
		if (AjxXmlDoc._msxmlVers == null)
			throw new AjxException("MSXML not installed", AjxException.INTERNAL_ERROR, "AjxXmlDoc._init");
	} else if (AjxEnv.isNav) {
		// add loadXML to Document's API
		Document.prototype.loadXML = function(str) {
			var domParser = new DOMParser();
			var domObj = domParser.parseFromString(str, "text/xml");
			// remove old child nodes since we recycle DOMParser and append new
			while (this.hasChildNodes())
				this.removeChild(this.lastChild);
			for (var i = 0; i < domObj.childNodes.length; i++) {
				var importedNode = this.importNode(domObj.childNodes[i], true);
				this.appendChild(importedNode);
			}
		}

		_NodeGetXml = function() {
			var ser = new XMLSerializer();
			return ser.serializeToString(this);
		}
		Node.prototype.__defineGetter__("xml", _NodeGetXml);
	} else if (AjxEnv.isSafari) {
		// add loadXML to Document's API
		document.__proto__.loadXML = function(str) {
			var domParser = new DOMParser();
			var domObj = domParser.parseFromString(str, "text/xml");
			// remove old child nodes since we recycle DOMParser and append new
			while (this.hasChildNodes())
				this.removeChild(this.lastChild);
			for (var i = 0; i < domObj.childNodes.length; i++) {
				var importedNode = this.importNode(domObj.childNodes[i], true);
				this.appendChild(importedNode);
			}
		}
	}

	AjxXmlDoc._inited = true;
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxEnv() {
}

AjxEnv._inited = false;


AjxEnv.reset = function () {
	AjxEnv.browserVersion = -1;
	AjxEnv.geckoDate = 0;
	AjxEnv.mozVersion = -1;
	AjxEnv.isMac = false;
	AjxEnv.isWindows = false;
	AjxEnv.isLinux = false;
	AjxEnv.isNav  = false;
	AjxEnv.isIE = false;
	AjxEnv.isNav4 = false;
	AjxEnv.trueNs = true;
	AjxEnv.isNav6 = false;
	AjxEnv.isNav6up = false;
	AjxEnv.isNav7 = false;
	AjxEnv.isIE3 = false;
	AjxEnv.isIE4 = false;
	AjxEnv.isIE4up = false;
	AjxEnv.isIE5 = false;
	AjxEnv.isIE5_5 = false;
	AjxEnv.isIE5up = false;
	AjxEnv.isIE5_5up = false;
	AjxEnv.isIE6  = false;
	AjxEnv.isIE6up = false;
	AjxEnv.isNormalResolution = false;
	AjxEnv.ieScaleFactor = 1;
	AjxEnv.isFirefox = false;
	AjxEnv.isFirefox1up = false;
	AjxEnv.isFirefox1_5up = false;
	AjxEnv.isMozilla = false;
	AjxEnv.isMozilla1_4up = false;
	AjxEnv.isSafari = false;
	AjxEnv.isGeckoBased = false;
	AjxEnv.isOpera = false;
	AjxEnv.useTransparentPNGs = false;

	// screen resolution - ADD MORE RESOLUTION CHECKS AS NEEDED HERE:
	AjxEnv.is800x600orLower = screen.width <= 800 && screen.height <= 600;
};

AjxEnv.parseUA = function (userAgent) {
	var agt = userAgent.toLowerCase();
	var agtArr = agt.split(" ");
	var i = 0;
	var index = -1;
	var token = null;
	var isSpoofer = false;
	var isWebTv = false;
	var isHotJava = false;
	var beginsWithMozilla = false;
	var isCompatible = false;
	if (agtArr != null) {
		if ( (index = agtArr[0].search(/^\s*mozilla\//) )!= -1){
			beginsWithMozilla = true;
			AjxEnv.browserVersion = parseFloat(agtArr[0].substring(index + 8));
			AjxEnv.isNav = true;
		}
		for ( ; i < agtArr.length; ++i ){
			token = agtArr[i];
			if (token.indexOf('compatible') != -1 ) {
				isCompatible = true;
				AjxEnv.isNav = false;
			} else if ((token.indexOf('opera')) != -1){
				AjxEnv.isOpera = true;
				AjxEnv.isNav = false;
				AjxEnv.browserVersion = parseFloat(agtArr[i+1]);
			} else if ((token.indexOf('spoofer')) != -1){
				isSpoofer = true;
				AjxEnv.isNav = false;
			} else if ((token.indexOf('webtv')) != -1) {
				isWebTv = true;
				AjxEnv.isNav = false;
			} else if ((token.indexOf('hotjava')) != -1) {
				isHotJava = true;
				AjxEnv.isNav = false;
			} else if ((index = token.indexOf('msie')) != -1) {
				AjxEnv.isIE = true;
				AjxEnv.browserVersion = parseFloat(agtArr[i+1]);
			} else if ((index = token.indexOf('gecko/')) != -1){
				AjxEnv.isGeckoBased = true;
				AjxEnv.geckoDate = parseFloat(token.substr(index + 6));
			} else if ((index = token.indexOf('rv:')) != -1){
				AjxEnv.mozVersion = parseFloat(token.substr(index + 3));
				AjxEnv.browserVersion = AjxEnv.mozVersion;
			} else if ((index = token.indexOf('firefox/')) != -1){
				AjxEnv.isFirefox = true;
				AjxEnv.browserVersion = parseFloat(token.substr(index + 8));
			} else if ((index = token.indexOf('netscape6/')) != -1){
				AjxEnv.trueNs = true;
				AjxEnv.browserVersion = parseFloat(token.substr(index + 10));
			} else if ((index = token.indexOf('netscape/')) != -1){
				AjxEnv.trueNs = true;
				AjxEnv.browserVersion = parseFloat(token.substr(index + 9));
			} else if ((index = token.indexOf('safari/')) != -1){
				AjxEnv.isSafari = true;
				AjxEnv.browserVersion = parseFloat(token.substr(index + 7));
			} else if (token.indexOf('windows') != -1){
				AjxEnv.isWindows = true;
			} else if ((token.indexOf('macintosh') != -1) ||
					   (token.indexOf('mac_') != -1)){
				AjxEnv.isMac = true;
			} else if (token.indexOf('linux') != -1){
				AjxEnv.isLinux = true;
			}
		}
		// Note: Opera and WebTV spoof Navigator.  
		// We do strict client detection.
		AjxEnv.isNav  = (beginsWithMozilla && !isSpoofer && !isCompatible && 
						!AjxEnv.isOpera && !isWebTv && !isHotJava &&
						!AjxEnv.isSafari);

		AjxEnv.isIE = (AjxEnv.isIE && !AjxEnv.isOpera);

		AjxEnv.isNav4 = (AjxEnv.isNav && (AjxEnv.browserVersion  == 4) &&
						(!AjxEnv.isIE));
		AjxEnv.isNav6 = (AjxEnv.isNav && AjxEnv.trueNs && 
						(AjxEnv.browserVersion >=6.0) && 
						(AjxEnv.browserVersion < 7.0));
		AjxEnv.isNav6up = (AjxEnv.isNav && AjxEnv.trueNs && 
						  (AjxEnv.browserVersion >= 6.0));
		AjxEnv.isNav7 = (AjxEnv.isNav && AjxEnv.trueNs && 
						(AjxEnv.browserVersion == 7.0));

		AjxEnv.isIE3 = (AjxEnv.isIE && (AjxEnv.browserVersion < 4));
		AjxEnv.isIE4 = (AjxEnv.isIE && (AjxEnv.browserVersion == 4) && 
					 (AjxEnv.browserVersion == 4.0));
		AjxEnv.isIE4up = (AjxEnv.isIE && (AjxEnv.browserVersion >= 4));
		AjxEnv.isIE5 = (AjxEnv.isIE && (AjxEnv.browserVersion == 4) && 
					 (AjxEnv.browserVersion == 5.0));
		AjxEnv.isIE5_5 = (AjxEnv.isIE && (AjxEnv.browserVersion == 4) && 
						 (AjxEnv.browserVersion == 5.5));
		AjxEnv.isIE5up = (AjxEnv.isIE && (AjxEnv.browserVersion >= 5.0));
		AjxEnv.isIE5_5up =(AjxEnv.isIE && (AjxEnv.browserVersion >= 5.5));
		AjxEnv.isIE6  = (AjxEnv.isIE && (AjxEnv.browserVersion == 6.0));
		AjxEnv.isIE6up = (AjxEnv.isIE && (AjxEnv.browserVersion >= 6.0));

		AjxEnv.isMozilla = ((AjxEnv.isNav && AjxEnv.mozVersion && 
							AjxEnv.isGeckoBased && (AjxEnv.geckoDate != 0)));
		AjxEnv.isMozilla1_4up = (AjxEnv.isMozilla && (AjxEnv.mozVersion >= 1.4));
		AjxEnv.isFirefox = ((AjxEnv.isMozilla && AjxEnv.isFirefox));
		AjxEnv.isFirefox1up = (AjxEnv.isFirefox && AjxEnv.browserVersion >= 1.0);
		AjxEnv.isFirefox1_5up = (AjxEnv.isFirefox && AjxEnv.browserVersion >= 1.5);

	}
	// setup some global setting we can check for high resolution
	if (AjxEnv.isIE){
		AjxEnv.isNormalResolution = true;
		AjxEnv.ieScaleFactor = screen.deviceXDPI / screen.logicalXDPI;
		if (AjxEnv.ieScaleFactor > 1) {
			AjxEnv.isNormalResolution = false;
		}
	}
	// show transparent PNGs on platforms that support them well
	//	(eg: all but IE and Linux)
	//	MOW: having trouble getting safari to render transparency for shadows, skipping there, too
	AjxEnv.useTransparentPNGs = !AjxEnv.isIE && !AjxEnv.isLinux && !AjxEnv.isSafari;
	AjxEnv._inited = !AjxEnv.isIE;
};

AjxEnv.reset();
AjxEnv.parseUA(navigator.userAgent);

// COMPATIBILITY

// Safari doesn't support string.replace(/regexp/, function);
if (AjxEnv.isSafari) {
	if (!String.prototype._AjxOldReplace) {
		String.prototype._AjxOldReplace = String.prototype.replace;
		String.prototype.replace = function(re, val) {
			if (typeof val != "function")
				return this._AjxOldReplace(re, val);
			else {
				// TODO: investigate if it's possible to use the array.join approach
				var str = this.slice(0), v, l, a;
				while (a = re.exec(str)) {
					v = val.apply(null, a);
					l = a[0].length;
					re.lastIndex -= l - v.length;
					str = str.substr(0, a.index) + v + str.substr(a.index + l);
					if (!re.global)
						break;
				}
				return str;
			}
		};
	}
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* @class
* This static class provides basic image support by using CSS and background 
* images rather than &lt;img&gt; tags. 
* @author Conrad Damon
* @author Ross Dargahi
*/
function AjxImg() {
}
AjxImg.prototype = new Object;
AjxImg.prototype.constructor = null;

AjxImg.ICON = 1;
AjxImg.HORIZ_BORDER = 2;
AjxImg.VERT_BORDER = 3;
AjxImg.BACKGROUND = 4;

AjxImg._VIEWPORT_ID = "AjxImg_VP";

/**
* This method will set the image for <i>parentEl</i>. <i>parentEl</i> should 
* only contain this image and no other children
*
* @param parentEl 		The parent element for the image
* @param imageName 		The name of the image.  The CSS entry for the image will be "Img<imageName>".
* @param useParenEl 	If true will use the parent element as the root for the image and will not create an intermediate DIV
*/
AjxImg.setImage =
function(parentEl, imageName, style, useParentEl) {
	var className = AjxImg.getClassForImage(imageName);

	if (useParentEl) {
		parentEl.className = className;
	} else {
		if (parentEl.firstChild == null) {
			parentEl.innerHTML = className 
			   ? ["<div class='", className, "'></div>"].join("")
			   : "<div></div>";
   		}
		else {
			parentEl.firstChild.className = className;
		}
	}
}

AjxImg.getClassForImage =
function(imageName) {
	return "Img" + imageName;
}

AjxImg.getImageClass =
function(parentEl) {
	return parentEl.firstChild ? parentEl.firstChild.className : parentEl.className;
}

AjxImg.getImageElement =
function(parentEl) {
	return parentEl.firstChild ? parentEl.firstChild : parentEl;
}

AjxImg.getParentElement =
function(imageEl) {
	return imageEl.parentNode;
}

/**
* Gets the "image" as an HTML string. 
*
* @param styleStr	additional style info e.g. "display:inline"
* @param attrStr	additional attributes eg. "id=X748"
*/
AjxImg.getImageHtml = 
function(imageName, styleStr, attrStr, wrapInTable) {
	attrStr = (!attrStr) ? "" : attrStr;
	var className = AjxImg.getClassForImage(imageName);
	styleStr = styleStr ? "style='" + styleStr + "' " : "";
	var pre = wrapInTable ? "<table style='display:inline' cellpadding=0 cellspacing=0 border=0><tr><td align=center valign=bottom>" : "";
	var post = wrapInTable ? "</td></tr></table>" : "";
	if (className) {
		return [pre, "<div class='", className, "' ", styleStr, " ", attrStr, "></div>", post].join("");
	}
	return [pre, "<div ", styleStr, " ", attrStr, "></div>", post].join("");
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxException(msg, code, method, detail) {
	if (arguments.length == 0) return;
	this.msg = msg;
	this.code = code;
	this.method = method;
	this.detail = detail;
}

AjxException.prototype.toString = 
function() {
	return "AjxException";
}

AjxException.prototype.dump = 
function() {
	return "AjxException: msg="+this.msg+" code="+this.code+" method="+this.method+" detail="+this.detail;
}
AjxException.INVALIDPARENT 			= "AjxException.INVALIDPARENT";
AjxException.INVALID_OP 			= "AjxException.INVALID_OP";
AjxException.INTERNAL_ERROR 		= "AjxException.INTERNAL_ERROR";
AjxException.INVALID_PARAM 			= "AjxException.INVALID_PARAM";
AjxException.UNIMPLEMENTED_METHOD 	= "AjxException.UNIMPLEMENTED_METHOD";
AjxException.NETWORK_ERROR 			= "AjxException.NETWORK_ERROR";
AjxException.OUT_OF_RPC_CACHE		= "AjxException.OUT_OF_RPC_CACHE";
AjxException.UNSUPPORTED 			= "AjxException.UNSUPPORTED";
AjxException.UNKNOWN_ERROR 			= "AjxException.UNKNOWN_ERROR";
AjxException.CANCELED				= "AjxException.CANCELED";
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a callback which consists of at least a function reference, and possibly also
* an object to call it from.
* @constructor
* @class
* This class represents a callback function which can be called standalone, or from a
* given object. What the callback takes as arguments and what it returns are left to the
* client.
*
* @author Conrad Damon
* @param obj	[Object]				the object to call the function from
* @param func	[function]				the callback function
* @param args   [primitive or Array]	default arguments
*/
function AjxCallback(obj, func, args) {
	if (arguments.length == 0) return;

	this.obj = obj;
	this.func = func;
	this.args = args;
}

AjxCallback.prototype.toString =
function() {
	return "AjxCallback";
}

/**
* Runs the callback function, from within the object if there is one. The
* called function passed arguments are the concatenation of the argument
* array passed to this object's constructor and the argument array passed
* to the <code>run</code> method. Whatever the called function returns is
* returned to the caller.
*
* @param arg1	The first argument which will be appended to the argument
*				array passed to this object's constructor. Any number of
*				arguments may be passed to the <code>run</code> method.
*/
AjxCallback.prototype.run =
function(/* arg1 ... argN */) {
	// combine original args with new ones
	var args = [];

	// sometimes we want to pass a null or false argument, so simply
	// checking for if (this.args) won't do.
	if (typeof this.args != "undefined") {
		if (this.args instanceof Array)
			// NOTE: We must NOT use this.args directly if this method's
			//       params are gonna be pushed onto the array because it
			//       will change the original args!
			args = arguments.length > 0 ? args.concat(this.args) : this.args;
		else
			args.push(this.args);
	}

	for (var i = 0; i < arguments.length; ++i)
		args.push(arguments[i]);

	// invoke function
	return this.func.apply(this.obj || window, args);
};

/**
 * The following function is what an AjxCallback should be *all* about.  It
 * returns a plain function that will call your supplied "func" in the context
 * of "obj" and pass to it, in this order, any additional arguments that you
 * pass to simpleClosure and the arguments that were passed to it at the call
 * time.
 *
 * An example should do:
 *
 *   div.onclick = AjxCallback.simpleClosure(this.handler, this, "some data");
 *   ...
 *   this.handler = function(data, event) {
 *      // event will be passed for DOM2 compliant browsers
 *      // and data is "some data"
 *   };
 *
 * [this is one of the most useful functions I ever wrote :D  -mihai@zimbra.com]
 */
AjxCallback.simpleClosure = function(func, obj) {
	var args = [];
	for (var i = 2; i < arguments.length; ++i)
		args.push(arguments[i]);
	return function() {
		var args2 = [];
		for (var i = 0; i < arguments.length; ++i)
			args2.push(arguments[i]);
		func.apply(obj || this, args.concat(args2));
	};
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxTimedAction(obj, func, args) {
	AjxCallback.call(this, obj, func, args);
	this._tid = -1;
	this._id = -1;
}
AjxTimedAction.prototype = new AjxCallback;
AjxTimedAction.prototype.constructor = AjxTimedAction;

AjxTimedAction.prototype.toString = 
function() {
	return "AjxTimedAction";
};

AjxTimedAction._pendingActions = new Object();
AjxTimedAction._nextActionId = 0;

AjxTimedAction.scheduleAction =
function(action, timeout){
	// if tid already exists, cancel previous timeout before setting a new one
	if (action._tid) {
		AjxTimedAction.cancelAction(action._id);
	}

	var id = action._id = AjxTimedAction._nextActionId++;
	AjxTimedAction._pendingActions[id] = action;
	var actionStr = "AjxTimedAction._exec(" + id + ")";
	action._tid = window.setTimeout(actionStr, timeout ? timeout : 0); // mac no like null/void
	return action._id;
};

AjxTimedAction.cancelAction =
function(actionId) {
	var action = AjxTimedAction._pendingActions[actionId];
	if (action) {
		window.clearTimeout(action._tid);
		delete AjxTimedAction._pendingActions[actionId];
		delete action._tid;
	}
};

AjxTimedAction._exec =
function(actionId) {
	var action = AjxTimedAction._pendingActions[actionId];
	delete AjxTimedAction._pendingActions[actionId];
	delete action._tid;
	action.run();
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxEvent() {
}

AjxEvent.prototype.toString = 
function() {
	return "AjxEvent";
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxEventMgr() {
	this._listeners = new Object();
}

AjxEventMgr.prototype.toString = 
function() {
	return "AjxEventMgr";
}

AjxEventMgr.prototype.addListener =
function(eventType, listener) {
	var lv = this._listeners[eventType];
	if (lv == null) {
		lv = this._listeners[eventType] = new AjxVector();
	}         	 
	if (!lv.contains(listener)) {
		if (this._notifyingListeners) {
			lv = this._listeners[eventType] = lv.clone();
		}
		lv.add(listener);
		return true;
	}
	return false;
}

AjxEventMgr.prototype.notifyListeners =
function(eventType, event) {
	this._notifyingListeners = true;
	var lv = this._listeners[eventType];
	if (lv != null) {
		var a = lv.getArray();
		var s = lv.size();
		var retVal = null;
		var c = null;
		for (var i = 0; i < s; i++) {
			c = a[i];
			retVal = c.handleEvent ? c.handleEvent(event) : c(event);
			if (retVal === false) {
				break;
			}
		}
	}	
	this._notifyingListeners = false;
}

AjxEventMgr.prototype.isListenerRegistered =
function(eventType) {
	var lv = this._listeners[eventType];
	return (lv != null && lv.size() > 0);
}

AjxEventMgr.prototype.removeListener = 
function(eventType, listener) {
	var lv = this._listeners[eventType];
	if (lv != null) {
		if (this._notifyingListeners) {
			lv = this._listeners[eventType] = lv.clone();
		}
		lv.remove(listener);
		return true;
	}
	return false;
}

AjxEventMgr.prototype.removeAll = 
function(eventType) {
	var lv = this._listeners[eventType];
	if (lv != null) {
		if (this._notifyingListeners) {
			lv = this._listeners[eventType] = lv.clone();
		}
		lv.removeAll();
		return true;
	}
	return false;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a new listener.
* @constructor
* @class
* This class represents a listener, which is a function to be called in response to an event.
* A listener is a slightly specialized callback: it has a handleEvent() method, and it doesn't
* return a value.
*
* @author Ross Dargahi
* @param obj	(optional) the object to call the function from
* @param func	the listener function
*/
function AjxListener(obj, method, args) {
	AjxCallback.call(this, obj, method, args);
}

AjxListener.prototype = AjxCallback;
AjxListener.prototype.constructor = AjxListener;

AjxListener.prototype.toString = 
function() {
	return "AjxListener";
}

/**
* Invoke the listener function.
*
* @param ev		the event object that gets passed to an event handler
*/
AjxListener.prototype.handleEvent =
function(ev) {
	return AjxCallback.prototype.run.call(this, ev);
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function AjxDateUtil() {
};

AjxDateUtil.YEAR = 1;
AjxDateUtil.MONTH = 2;
AjxDateUtil.WEEK = 3;
AjxDateUtil.DAY = 4;

AjxDateUtil.MSEC_PER_FIFTEEN_MINUTES = 900000;
AjxDateUtil.MSEC_PER_HALF_HOUR = 1800000;
AjxDateUtil.MSEC_PER_HOUR = 3600000;
AjxDateUtil.MSEC_PER_DAY = 24 * AjxDateUtil.MSEC_PER_HOUR;

AjxDateUtil.WEEKDAY_SHORT = AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.SHORT];
AjxDateUtil.WEEKDAY_MEDIUM = AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.MEDIUM];
AjxDateUtil.WEEKDAY_LONG = AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.LONG];

AjxDateUtil.MONTH_SHORT = AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.SHORT];
AjxDateUtil.MONTH_MEDIUM = AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.MEDIUM];
AjxDateUtil.MONTH_LONG = AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.LONG];

AjxDateUtil.FREQ_TO_DISPLAY = {
	SEC: [AjxMsg.second,AjxMsg.seconds],
	MIN: [AjxMsg.minute,AjxMsg.minutes], 
	HOU: [AjxMsg.hour, 	AjxMsg.hours],
	DAI: [AjxMsg.day, 	AjxMsg.days],
	WEE: [AjxMsg.week, 	AjxMsg.weeks],
	MON: [AjxMsg.month, AjxMsg.months],
	YEA: [AjxMsg.year, 	AjxMsg.years]
};

AjxDateUtil._daysPerMonth = {
	0:31,
	1:29,
	2:31,
	3:30,
	4:31,
	5:30,
	6:31,
	7:31,
	8:30,
	9:31,
	10:30,
	11:31
};

AjxDateUtil._12hour = "12";
AjxDateUtil._24hour = "24";

AjxDateUtil._init =
function() {                                           
	AjxDateUtil._dateFormat = AjxDateFormat.getDateInstance(AjxDateFormat.SHORT).clone();
	var segments = AjxDateUtil._dateFormat.getSegments();
	for (var i = 0; i < segments.length; i++) {
		if (segments[i] instanceof AjxDateFormat.YearSegment) {
			segments[i] = new AjxDateFormat.YearSegment(AjxDateUtil._dateFormat, "yyyy");
		}
	}
	AjxDateUtil._dateTimeFormat = 
		new AjxDateFormat(AjxDateUtil._dateFormat.toPattern() + " " + AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT));
	
	AjxDateUtil._dateFormatNoYear = new AjxDateFormat(AjxMsg.formatDateMediumNoYear);
};

AjxDateUtil._init();                    

/* return true if the specified date (yyyy|yy, m (0-11), d (1-31)) 
 * is valid or not.
 */
AjxDateUtil.validDate =
function(y, m, d) {
	var date = new Date(y, m, d);
	var year = y > 999 ? date.getFullYear() : date.getYear();
	return date.getMonth() == m && date.getDate() == d && year == y;
};

/* return number of days (1-31) in specified month (yyyy, mm (0-11))
 */
AjxDateUtil.daysInMonth =
function(y, m) {
	var date = new Date(y, m, 1, 12);
	date.setMonth(date.getMonth()+1);
	date.setDate(date.getDate()-1);
	return date.getDate();
};

/* return true if year is a leap year
 */
AjxDateUtil.isLeapYear =
function(y) {
	return (new Date(y, 1, 29)).getMonth() == 1;
};

/**
 * rolls the month/year. If the day of month in the date passed in is greater
 * then the max day in the new month, set it to the max. The date passed in is
 * modified and also returned.
 */
AjxDateUtil.roll = 
function(date, field, offset) {
	var d = date.getDate();
	 // move back to first day before rolling in case previous
	 // month/year has less days

	if (field == AjxDateUtil.MONTH) {
		date.setDate(1);	
		date.setMonth(date.getMonth() + offset);
		var max = AjxDateUtil.daysInMonth(date.getFullYear(), date.getMonth());
		date.setDate(Math.min(d, max));		
	} else if (field == AjxDateUtil.YEAR) {
		date.setDate(1);		
		date.setFullYear(date.getFullYear() + offset);
		var max = AjxDateUtil.daysInMonth(date.getFullYear(), date.getMonth());
		date.setDate(Math.min(d, max));		
	} else if (field == AjxDateUtil.WEEK) {
		date.setDate(date.getDate() + 7*offset);
	} else if (field == AjxDateUtil.DAY) {
		date.setDate(date.getDate() + offset);		
	} else {
		return date;
	}
	return date;
};

// Computes the difference between now and <dateMSec>. Returns a string describing
// the difference
AjxDateUtil.computeDateDelta =
function(dateMSec) {
	var deltaMSec = (new Date()).getTime() - dateMSec;

	// bug fix #2203 - if delta is less than zero, dont bother computing
	if (deltaMSec < 0) return null;

	var years =  Math.floor(deltaMSec / (AjxDateUtil.MSEC_PER_DAY * 365));
	if (years != 0)
		deltaMSec -= years * AjxDateUtil.MSEC_PER_DAY * 365;
	var months = Math.floor(deltaMSec / (AjxDateUtil.MSEC_PER_DAY * 30.42));
	if (months > 0)
		deltaMSec -= Math.floor(months * AjxDateUtil.MSEC_PER_DAY * 30.42);
	var days = Math.floor(deltaMSec / AjxDateUtil.MSEC_PER_DAY);
	if (days > 0)
		deltaMSec -= days * AjxDateUtil.MSEC_PER_DAY;
	var hours = Math.floor(deltaMSec / AjxDateUtil.MSEC_PER_HOUR);
	if (hours > 0) 
		deltaMSec -= hours * AjxDateUtil.MSEC_PER_HOUR;
	var mins = Math.floor(deltaMSec / 60000);
	if (mins > 0)
		deltaMSec -= mins * 60000;
	var secs = Math.floor(deltaMSec / 1000);
	
	var deltaStr = "";
	if (years > 0) {
		deltaStr =  years + " ";
		deltaStr += (years > 1) ? AjxMsg.years : AjxMsg.year;
		if (years <= 3 && months > 0) {
    		deltaStr += " " + months;
    		deltaStr += " " + ((months > 1) ? AjxMsg.months : AjxMsg.months);
		}
	} else if (months > 0) {
		deltaStr =  months + " ";
		deltaStr += (months > 1) ? AjxMsg.months : AjxMsg.month;
		if (months <= 3 && days > 0) {
    		deltaStr += " " + days;
    		deltaStr += " " + ((days > 1) ? AjxMsg.days : AjxMsg.day);
		}
	} else if (days > 0) {
		deltaStr = days + " ";
		deltaStr += (days > 1) ? AjxMsg.days : AjxMsg.day;
		if (days <= 2 && hours > 0) {
    		deltaStr += " " + hours;
    		deltaStr += " " + ((hours > 1) ? AjxMsg.hours : AjxMsg.hour);
		}
	} else if (hours > 0) {
		deltaStr = hours + " ";
		deltaStr += (hours > 1) ? AjxMsg.hours : AjxMsg.hour;
		if (hours < 5 && mins > 0) {
    		deltaStr += " " + mins;
    		deltaStr += " " + ((mins > 1) ? AjxMsg.minutes : AjxMsg.minute);
		}
	} else if (mins > 0) {
		deltaStr = mins + " ";
		deltaStr += ((mins > 1) ? AjxMsg.minutes : AjxMsg.minute);
		if (mins < 5 && secs > 0) {
    		deltaStr += " " + secs;
    		deltaStr += " " + ((secs > 1) ? AjxMsg.seconds : AjxMsg.second);
		}
	} else {
		deltaStr = secs;
		deltaStr += " " + ((secs > 1) ? AjxMsg.seconds : AjxMsg.second);
	}
	deltaStr += " " + AjxMsg.ago;
	return deltaStr;
};

AjxDateUtil.simpleComputeDateStr = 
function(date, stringToPrepend) {
	var dateStr = AjxDateUtil._dateFormat.format(date);
	return stringToPrepend ? stringToPrepend + dateStr : dateStr;
};
AjxDateUtil.simpleParseDateStr =
function(dateStr) {
	return AjxDateUtil._dateFormat.parse(dateStr);
};

AjxDateUtil.simpleComputeDateTimeStr = 
function(date, stringToPrepend) {
	var dateTimeStr = AjxDateUtil._dateTimeFormat.format(date);
	return stringToPrepend ? stringToPrepend + dateTimeStr : dateTimeStr;
};
AjxDateUtil.simpleParseDateTimeStr =
function(dateTimeStr) {
	return AjxDateUtil._dateTimeFormat.parse(dateTimeStr);
};

AjxDateUtil.longComputeDateStr = 
function(date) {
	var formatter = AjxDateFormat.getDateInstance(AjxDateFormat.FULL);
	return formatter.format(date);
}

AjxDateUtil.computeDateStr =
function(now, dateMSec) {
	if (dateMSec == null)
		return "";

	var date = new Date(dateMSec);
	if (now.getTime() - dateMSec < AjxDateUtil.MSEC_PER_DAY && 
		now.getDay() == date.getDay()) {
		return AjxDateUtil.computeTimeString(date);
	} 
	
	if (now.getFullYear() == date.getFullYear()) {
		return AjxDateUtil._dateFormatNoYear.format(date);
	}
	
	return AjxDateUtil.simpleComputeDateStr(date);
};

AjxDateUtil.computeTimeString =
function(date) {
	var formatter = AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT);
	return formatter.format(date);
};


AjxDateUtil._getHoursStr = 
function(date, pad, useMilitary) {
	var myVal = date.getHours();
	if (!useMilitary) {
		myVal %= 12;
		if (myVal == 0) myVal = 12;
	}
	return pad ? AjxDateUtil._pad(myVal) : myVal;
};

AjxDateUtil._getMinutesStr = 
function(date) {
	return AjxDateUtil._pad(date.getMinutes());
};

AjxDateUtil._getSecondsStr = 
function(date) {
	return AjxDateUtil._pad(date.getSeconds());
};

AjxDateUtil._getAMPM = 
function (date, upper) {
	var myHour = date.getHours();
	return (myHour < 12) ? (upper ? 'AM' : 'am') : (upper ? 'PM' : 'pm');
};

AjxDateUtil._getMonthName = 
function(date, abbreviated) {
	return abbreviated
		? AjxDateUtil.MONTH_MEDIUM[date.getMonth()]
		: AjxDateUtil.MONTH_LONG[date.getMonth()];
};

AjxDateUtil._getMonth = 
function(date, pad) {
	var myMonth = date.getMonth() + 1;
	if (pad) {
		return AjxDateUtil._pad(myMonth);
	} else {
		return myMonth;
	}
};

AjxDateUtil._getDate = 
function(date, pad) {
	var myVal = date.getDate();
	return pad == true ? AjxDateUtil._pad(myVal) : myVal;
};

AjxDateUtil._getWeekday =
function (date) {
	var myVal = date.getDay();
	return AjxDateUtil.WEEKDAY_LONG[myVal];
};

AjxDateUtil._getFullYear = 
function(date) {
	return date.getFullYear();
};

AjxDateUtil.getTimeStr = 
function(date, format) {
	var s = format;
	s = s.replace(/%d/g, AjxDateUtil._getDate(date, true));				// zero padded day of the month
	s = s.replace(/%D/g, AjxDateUtil._getDate(date, false));			// day of the month without padding
	s = s.replace(/%w/g, AjxDateUtil._getWeekday(date));				// day of the week
	s = s.replace(/%M/g, AjxDateUtil._getMonthName(date));				// full month name
	s = s.replace(/%t/g, AjxDateUtil._getMonthName(date, true));		// abbr. month name
	s = s.replace(/%n/g, AjxDateUtil._getMonth(date, true));		    // zero padded month
	s = s.replace(/%Y/g, AjxDateUtil._getFullYear(date));				// full year
	s = s.replace(/%h/g, AjxDateUtil._getHoursStr(date, false, false));	// non-padded hours
	s = s.replace(/%H/g, AjxDateUtil._getHoursStr(date, true, false ));	// padded hours
	s = s.replace(/%m/g, AjxDateUtil._getMinutesStr(date));				// padded minutes
	s = s.replace(/%s/g, AjxDateUtil._getSecondsStr(date));				// padded seconds
	s = s.replace(/%P/g, AjxDateUtil._getAMPM(date, true));				// upper case AM PM
	s = s.replace(/%p/g, AjxDateUtil._getAMPM(date, false));			// lower case AM PM
	return s;
};

AjxDateUtil.getRoundedMins = 
function (date, roundTo) {
	var mins = date.getMinutes();
	if (mins != 0 && roundTo)
		mins = (Math.ceil( (mins/roundTo) )) * roundTo;
	return mins;
};

AjxDateUtil.roundTimeMins = 
function(date, roundTo) {
	var mins = date.getMinutes();
	var hours = date.getHours();
	if (mins != 0 && roundTo){
		mins = (Math.ceil( (mins/roundTo) )) * roundTo;
		if (mins == 60) {
			mins = 0;
			hours++;
		}
		date.setMinutes(mins);
		date.setHours(hours);
	}
	return date;
};

AjxDateUtil.isInRange = 
function(startTime1, endTime1, startTime2, endTime2) {
	return (startTime1 < endTime2 && endTime1 > startTime2);
}

AjxDateUtil.getSimpleDateFormat =
function() {
	return AjxDateUtil._dateFormat;
};

/**
 * The following are helper routines for processing server date/time which comes
 * in this format: YYYYMMDDTHHMMSSZ
*/
AjxDateUtil.getServerDate = 
function(date) {
	if (!AjxDateUtil._serverDateFormatter) {
		AjxDateUtil._serverDateFormatter = new AjxDateFormat("yyyyMMdd");
	}
	return AjxDateUtil._serverDateFormatter.format(date);
};

AjxDateUtil.getServerDateTime = 
function(date, useUTC) {
	var newDate = date;
	var formatter = null;

	if (useUTC) {
		if (!AjxDateUtil._serverDateTimeFormatterUTC) {
			AjxDateUtil._serverDateTimeFormatterUTC = new AjxDateFormat("yyyyMMdd'T'HHmmss'Z'");
		}
		formatter = AjxDateUtil._serverDateTimeFormatterUTC;
		// add timezone offset to this UTC date
		newDate = new Date(date.getTime());
		newDate.setMinutes(newDate.getMinutes() + newDate.getTimezoneOffset());
	} else {
		if (!AjxDateUtil._serverDateTimeFormatter) {
			AjxDateUtil._serverDateTimeFormatter = new AjxDateFormat("yyyyMMdd'T'HHmmss");
		}
		formatter = AjxDateUtil._serverDateTimeFormatter;
	}

	return formatter.format(newDate);
};

AjxDateUtil.parseServerTime = 
function(serverStr, date) {
	if (serverStr.charAt(8) == 'T') {
		var hh = parseInt(serverStr.substr(9,2), 10);
		var mm = parseInt(serverStr.substr(11,2), 10);
		var ss = parseInt(serverStr.substr(13,2), 10);
		if (serverStr.charAt(15) == 'Z') {
			mm += AjxTimezone.getOffset(AjxTimezone.DEFAULT, date);
		}
		date.setHours(hh, mm, ss, 0);
	}
	return date;
};

AjxDateUtil.parseServerDateTime = 
function(serverStr) {
	if (serverStr == null) return null;

	var d = new Date();
	var yyyy = parseInt(serverStr.substr(0,4), 10);
	var MM = parseInt(serverStr.substr(4,2), 10);
	var dd = parseInt(serverStr.substr(6,2), 10);
	d.setFullYear(yyyy);
	d.setMonth(MM - 1);
	d.setMonth(MM - 1); // DON'T remove second call to setMonth (see bug #3839)
	d.setDate(dd);
	AjxDateUtil.parseServerTime(serverStr, d);
	return d;
};

AjxDateUtil._pad = 
function(n) {
	return n < 10 ? ('0' + n) : n;
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
 * This class stores mappings between client and server identifiers for
 * timezones as well as attempting to guess the default timezone. The 
 * application can override this value, through a user preference perhaps, 
 * by setting the <code>DEFAULT</code> property's value. The default 
 * timezone is specified using the client identifier (e.g. "US/Pacific").
 * <p>
 * <strong>Note:</strong>
 * The client timezone identifiers are the same identifiers used in the
 * Java TimeZone class. Only a subset of the timezones available in Java
 * are actually used in this class, though.
 */
function AjxTimezone () {}

// Static methods

AjxTimezone.getServerId = function(clientId) {
	return AjxTimezone._CLIENT2SERVER[clientId];
};
AjxTimezone.getClientId = function(serverId) {
	return AjxTimezone._SERVER2CLIENT[serverId];
};

AjxTimezone.getShortName = function(clientId) {
	return AjxTimezone._SHORT_NAMES[clientId];
};
AjxTimezone.getMediumName = function(clientId) {
	return "GMT"+AjxTimezone.getShortName(clientId);
};
AjxTimezone.getLongName = function(clientId) {
	return AjxTimezone.getMediumName(clientId)+" ("+I18nMsg["timezoneName"+clientId]+")";
};

AjxTimezone.getRule = function(clientId) {
	return AjxTimezone._CLIENT2RULE[clientId];
};

AjxTimezone.getOffset = function(clientId, date) {
	var rule = AjxTimezone.getRule(clientId);
	var offset = rule ? rule.stdOffset : 0;
	if (rule && rule.dstOffset) {
		var month = date.getMonth();
		var day = date.getDate();
		if ((month == rule.changeD[1] && day >= rule.changeD[2]) ||
			(month == rule.changeStd[1] && day < rule.changeStd[2]) ||
			(month > rule.changeD[1] && month < rule.changeStd[1])) {
			offset = rule.dstOffset;
		}
	}
	return offset;
};

// Constants

/** Client identifier for GMT. */
AjxTimezone.GMT = "Europe/London";

/** 
 * The default timezone is set by guessing the machine timezone later
 * in this file. See the static initialization section below for details.
 */
AjxTimezone.DEFAULT;

/** Server identifier for fallback timezone. */
AjxTimezone._FALLBACK = "(GMT-08.00) Pacific Time (US & Canada) / Tijuana";

AjxTimezone._CLIENT2SERVER = {};
AjxTimezone._SERVER2CLIENT = {};
AjxTimezone._SHORT_NAMES = {};
AjxTimezone._CLIENT2RULE = {};

/** 
 * The data is specified using the server identifiers for historical
 * reasons. Perhaps in the future we'll use the client (i.e. Java)
 * identifiers on the server as well.
 */
AjxTimezone._ruleLists = {
	noDSTList: [
		{ name:"(GMT-12.00) International Date Line West",				stdOffset: -720,hasDOffset: false },
		{ name:"(GMT-11.00) Midway Island / Samoa", 					stdOffset: -660,hasDOffset: false },
		{ name:"(GMT-10.00) Hawaii", 									stdOffset: -600,hasDOffset: false },
		{ name:"(GMT-07.00) Arizona",									stdOffset: -420,hasDOffset: false },
		{ name:"(GMT-06.00) Central America",							stdOffset: -360,hasDOffset: false },
		{ name:"(GMT-06.00) Saskatchewan",								stdOffset: -360,hasDOffset: false },
		{ name:"(GMT-05.00) Indiana (East)", 							stdOffset: -300,hasDOffset: false },
		{ name:"(GMT-04.00) Atlantic Time (Canada)", 					stdOffset: -300,hasDOffset: false },
		{ name:"(GMT-05.00) Bogota / Lima / Quito", 					stdOffset: -300,hasDOffset: false },
		{ name:"(GMT-04.00) Caracas / La Paz", 							stdOffset: -240,hasDOffset: false },
		{ name:"(GMT-03.00) Buenos Aires / Georgetown", 				stdOffset: -180,hasDOffset: false },
		{ name:"(GMT-01.00) Cape Verde Is.", 							stdOffset: -60, hasDOffset: false },
		{ name:"(GMT) Casablanca / Monrovia",							stdOffset: 0, 	hasDOffset: false },
		{ name:"(GMT+01.00) West Central Africa",						stdOffset: 60, 	hasDOffset: false },
		{ name:"(GMT+02.00) Harare / Pretoria", 						stdOffset: 120, hasDOffset: false },
		{ name:"(GMT+02.00) Jerusalem", 								stdOffset: 120, hasDOffset: false },
		{ name:"(GMT+03.00) Kuwait / Riyadh", 							stdOffset: 180, hasDOffset: false },
		{ name:"(GMT+03.00) Nairobi", 									stdOffset: 180, hasDOffset: false },
		{ name:"(GMT+04.00) Abu Dhabi / Muscat", 						stdOffset: 240, hasDOffset: false },
		{ name:"(GMT+04.30) Kabul", 									stdOffset: 270, hasDOffset: false },
		{ name:"(GMT+05.00) Islamabad / Karachi / Tashkent",			stdOffset: 300, hasDOffset: false },
		{ name:"(GMT+05.30) Chennai / Kolkata / Mumbai / New Delhi", 	stdOffset: 330, hasDOffset: false },
		{ name:"(GMT+05.45) Kathmandu", 								stdOffset: 345, hasDOffset: false },
		{ name:"(GMT+06.00) Astana / Dhaka", 							stdOffset: 360, hasDOffset: false },
		{ name:"(GMT+06.00) Sri Jayawardenepura", 						stdOffset: 360, hasDOffset: false },
		{ name:"(GMT+06.30) Rangoon", 									stdOffset: 390, hasDOffset: false },
		{ name:"(GMT+07.00) Bangkok / Hanoi / Jakarta", 				stdOffset: 420, hasDOffset: false },
		{ name:"(GMT+08.00) Kuala Lumpur / Singapore", 					stdOffset: 480, hasDOffset: false },
		{ name:"(GMT+08.00) Perth", 									stdOffset: 480, hasDOffset: false },
		{ name:"(GMT+08.00) Taipei", 									stdOffset: 480, hasDOffset: false },
		{ name:"(GMT+08.00) Beijing / Chongqing / Hong Kong / Urumqi",	stdOffset: 480, hasDOffset: false },
		{ name:"(GMT+09.00) Osaka / Sapporo / Tokyo", 					stdOffset: +540,hasDOffset: false },
		{ name:"(GMT+09.00) Seoul", 									stdOffset: 540, hasDOffset: false },
		{ name:"(GMT+09.30) Darwin", 									stdOffset: 570, hasDOffset: false },
		{ name:"(GMT+10.00) Brisbane", 									stdOffset: 600, hasDOffset: false },
		{ name:"(GMT+10.00) Guam / Port Moresby", 						stdOffset: 600, hasDOffset: false },
		{ name:"(GMT+11.00) Magadan / Solomon Is. / New Calenodia", 	stdOffset: 660, hasDOffset: false },
		{ name:"(GMT+12.00) Fiji / Kamchatka / Marshall Is.", 			stdOffset: 720, hasDOffset: false },
		{ name:"(GMT+13.00) Nuku'alofa", 								stdOffset: 780, hasDOffset: false }
	],

	DSTList: [
		{ name:"(GMT-09.00) Alaska", 
			stdOffset: -540, changeStd:[2005, 9, 30], 
			dstOffset: -480, changeD:[2005, 3, 3] },
		{ name:"(GMT-08.00) Pacific Time (US & Canada) / Tijuana", 
			stdOffset: -480, changeStd:[2005, 9, 30],
			dstOffset: -420, changeD: [2005, 3, 3]},
		{ name:"(GMT-07.00) Mountain Time (US & Canada)", 
			stdOffset: -420, changeStd:[2005, 9, 30], 
			dstOffset: -360, changeD: [2005, 3, 3]},
		{ name:"(GMT-06.00) Central Time (US & Canada)", 
			stdOffset: -360, changeStd: [2005, 9, 30], 
			dstOffset: -300, changeD: [2005, 3, 3]},
		{ name:"(GMT-05.00) Eastern Time (US & Canada)", 
			stdOffset: -300, changeStd: [2005, 9, 30],
			dstOffset: -240, changeD: [2005, 3, 3] },
		{ name:"(GMT-04.00) Santiago", 
			stdOffset: -240, changeStd: [2005, 2, 13],
			dstOffset: -180, changeD: [2005, 9, 9] },
		{ name:"(GMT-03.30) Newfoundland", 
			stdOffset: -210, changeStd: [2005, 9, 30],
			dstOffset: -150, changeD: [2005, 3, 3] },
		{ name:"(GMT-03.00) Brasilia", 
			stdOffset: -180, changeStd: [2005, 1, 20],
			dstOffset: -120, changeD: [2005, 9, 16] },
		{ name:"(GMT-03.00) Greenland", 
			stdOffset: -180, changeStd: [2005, 9, 30],
			dstOffset: -120, changeD: [2005, 3, 3] },
		{ name:"(GMT-02.00) Mid-Atlantic", 
			stdOffset: -120, changeStd: [2005, 8, 25],
			dstOffset: -60, changeD: [2005, 2, 27] },
		{ name:"(GMT-01.00) Azores", 
			stdOffset: -60, changeStd: [2005, 9, 30], 
			dstOffset: 0, changeD: [2005, 2, 27] },
		{ name:"(GMT) Greenwich Mean Time - Dublin / Edinburgh / Lisbon / London", 
			stdOffset: 0, changeStd: [2005, 9, 30],
			dstOffset: 60, changeD: [2005, 2, 27] },
		{ name:"(GMT+01.00) Amsterdam / Berlin / Bern / Rome / Stockholm / Vienna", 
			stdOffset: 60, changeStd: [2005, 9, 30],
			dstOffset: 120, changeD: [2005, 2, 27] },
		{ name:"(GMT+02.00) Athens / Beirut / Istanbul / Minsk", 
			stdOffset: 120, changeStd: [2005, 9, 30],
			dstOffset: 180, changeD: [2005, 2, 27] },
		{ name:"(GMT+02.00) Cairo", 
			stdOffset: 120, changeStd:  [2005, 8, 28],
			dstOffset: 180, changeD:  [2005, 4, 6] },
		{ name:"(GMT+03.00) Baghdad", 
			stdOffset: 180, changeStd: [2005, 9, 2],
			dstOffset: 240, changeD: [2005, 3, 3]},
		{ name:"(GMT+03.00) Moscow / St. Petersburg / Volgograd", 
			stdOffset: 180, changeStd: [2005, 9, 30],
			dstOffset: 240, changeD: [2005, 2, 27] },
		{ name:"(GMT+03.30) Tehran",
			stdOffset: 210, changeStd:  [2005, 8, 28], 
			dstOffset: 270, changeD:  [2005, 2, 6] },
		{ name:"(GMT+04.00) Baku / Tbilisi / Yerevan", 
			stdOffset: 240, changeStd: [2005, 9, 30],
			dstOffset: 300, changeD: [2005, 2, 27] },
		{ name:"(GMT+05.00) Ekaterinburg", 
			stdOffset: 300, changeStd:  [2005, 9, 30],
			dstOffset: 360, changeD:  [2005, 2, 27]},
		{ name:"(GMT+06.00) Almaty / Novosibirsk", 
			stdOffset: 360, changeStd:  [2005, 9, 30],
			dstOffset: 420, changeD:  [2005, 2, 27]},
		{ name:"(GMT+07.00) Krasnoyarsk", 
			stdOffset: 420, changeStd:  [2005, 9, 30],
			dstOffset: 480, changeD:  [2005, 2, 27] },
		{ name:"(GMT+08.00) Irkutsk / Ulaan Bataar", 
			stdOffset: 480, changeStd:  [2005, 9, 30],
			dstOffset: 540, changeD:  [2005, 2, 27] },
		{ name:"(GMT+09.00) Yakutsk", 
			stdOffset: 540, changeStd:  [2005, 9, 30],
			dstOffset: 600, changeD:  [2005, 2, 27] },
		{ name:"(GMT+09.30) Adelaide", 
			stdOffset: 570, changeStd:  [2005, 2, 27], 
			dstOffset: 630, changeD:  [2005, 9, 30] },
		{ name:"(GMT+10.00) Canberra / Melbourne / Sydney", 
			stdOffset: 600, changeStd: [2005, 2, 27],
			dstOffset: 660, changeD: [2005, 9, 30] },
		{ name:"(GMT+10.00) Hobart", 
			stdOffset: 600, changeStd: [2005, 2, 27],
			dstOffset: 660, changeD: [2005, 9, 2] },
		{ name:"(GMT+10.00) Vladivostok", 
			stdOffset: 600, changeStd: [2005, 9, 30], 
			dstOffset: 660, changeD: [2005, 2, 27] },
		{ name:"(GMT+12.00) Auckland / Wellington", 
			stdOffset: 720, changeStd: [2005, 2, 20],
			dstOffset: 780, changeD: [2005, 9, 2] }
	]
};

/**
 * One problem with firefox, is if the timezone on the machine changes,
 * the browser isn't updated. You have to restart firefox for it to get the 
 * new machine timezone.
 */
AjxTimezone._guessMachineTimezone = 
function() {
	var dec1 = new Date(2005, 12, 1, 0, 0, 0);
	var jun1 = new Date(2005, 6, 1, 0, 0, 0);
	var dec1offset = dec1.getTimezoneOffset();
	var jun1offset = jun1.getTimezoneOffset();
	var pos = ((dec1.getHours() - dec1.getUTCHours()) > 0);
	if (!pos) {
		dec1offset = dec1offset * -1;
		jun1offset = jun1offset * -1;
	}
	var tz = null;
	// if the offset for jun is the same as the offset in december,
	// then we have a timezone that doesn't deal with daylight savings.
	if (jun1offset == dec1offset) {
		var list = AjxTimezone._ruleLists.noDSTList;
 		for (var i = 0; i < list.length ; ++i ) {
			if (list[i].stdOffset == jun1offset) {
				tz = list[i];
				break;
			}
		}
	} else {
		// we need to find a rule that matches both offsets
		var list = AjxTimezone._ruleLists.DSTList;
		var dst = Math.max(dec1offset, jun1offset);
		var std = Math.min(dec1offset, jun1offset);
		var rule;
 		for (var i = 0; i < list.length ; ++i ) {
			rule = list[i];
			if (rule.stdOffset == std && rule.dstOffset == dst) {
				if (AjxTimezone._compareRules(rule, std, dst, pos)) {
					tz = rule;
					break;
				}
			}
		}
	}
	return tz ? tz.name : AjxTimezone._FALLBACK;
};

AjxTimezone._compareRules = 
function(rule, std, dst, pos) {
	var equal = false;
	var d = new Date(rule.changeStd[0], rule.changeStd[1], (rule.changeStd[2] -1)).getTimezoneOffset();
	var s = new Date(rule.changeStd[0], rule.changeStd[1], (rule.changeStd[2] + 1)).getTimezoneOffset();
	if (!pos) {
		s = s * -1;
		d = d * -1;
	}
	//alert("name = " + rule.name + ' s = ' + s + " d = " + d + " std = " + std + " dst = " + dst);
	if ( (std == s) && (dst == d) ) {
		s = new Date(rule.changeD[0], rule.changeD[1], (rule.changeD[2] -1)).getTimezoneOffset();
		d = new Date(rule.changeD[0], rule.changeD[1], (rule.changeD[2] + 1)).getTimezoneOffset();
		if (!pos) {
			s = s * -1;
			d = d * -1;
		}
		//alert("name = " + rule.name + ' s = ' + s + " d = " + d + " std = " + std + " dst = " + dst);
		if ((std == s) && (dst == d))
			equal = true;
	}
	return equal;
};

// Static initialization

var length = "timezoneMap".length;
for (var prop in I18nMsg) {
	if (prop.match(/^timezoneMap/)) {
		var clientId = prop.substring(length);
		var serverId = I18nMsg[prop];
		AjxTimezone._CLIENT2SERVER[clientId] = serverId;
		AjxTimezone._SERVER2CLIENT[serverId] = clientId;
	}
}

var lists = [ AjxTimezone._ruleLists.noDSTList, AjxTimezone._ruleLists.DSTList ];
for (var i = 0; i < lists.length; i++) {
	var list = lists[i];
	for (var j = 0; j < list.length; j++) {
		var rule = list[j];
		var serverId = rule.name;
		var clientId = AjxTimezone.getClientId(serverId);
		var sign = rule.stdOffset < 0 ? "-" : "+";
		var stdOffset = Math.abs(rule.stdOffset);
		var hours = stdOffset / 60;
		var minutes = stdOffset % 60;
		hours = hours < 10 ? '0' + hours : hours;
		minutes = minutes < 10 ? '0' + minutes : minutes;
		AjxTimezone._SHORT_NAMES[clientId] = sign + hours + minutes;
		AjxTimezone._CLIENT2RULE[clientId] = rule;
	}
}
AjxTimezone.DEFAULT = AjxTimezone.getClientId(AjxTimezone._guessMachineTimezone());
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Does nothing (static class).
* @constructor
* @class
* This class provides static methods to perform miscellaneous string-related utility functions.
*
* @author Ross Dargahi
* @author Roland Schemers
* @author Conrad Damon
*/
function AjxStringUtil() {
}

/**
* Removes white space from the beginning and end of a string, optionally compressing internal white space. By default, white
* space is defined as a sequence of  Unicode whitespace characters (\s in regexes). Optionally, the user can define what
* white space is by passing it as an argument.
*
* <p>TODO: add left/right options</p>
*
* @param str      	the string to trim
* @param compress 	whether to compress internal white space to one space
* @param space    	a string that represents a user definition of white space
* @returns			a trimmed string
*/

AjxStringUtil.TRIM_RE = /^\s+|\s+$/g;
AjxStringUtil.COMPRESS_RE = /\s+/g;
AjxStringUtil.ELLIPSIS = " ... ";

AjxStringUtil.makeString =
function(val) {
	return val ? String(val) : "";
};

AjxStringUtil.trim =
function(str, compress, space) {

	if (!str) return "";

	var trim_re = AjxStringUtil.TRIM_RE;

	var compress_re = AjxStringUtil.COMPRESS_RE;
	if (space) {
		trim_re = new RegExp("^" + space + "+|" + space + "+$", "g");
		compress_re = new RegExp(space + "+", "g");
	} else {
		space = " ";
	}
	str = str.replace(trim_re, '');
	if (compress)
		str = str.replace(compress_re, space);
	
	return str;		
}

/**
* Returns the string repeated the given number of times.
*
* @param str		a string
* @param num		number of times to repeat the string
*/
AjxStringUtil.repeat =
function(str, num) {
	var text = "";
	for (var i = 0; i < num; i++)
		text += str;
	return text;
}

AjxStringUtil.getUnitsFromSizeString = 
function(sizeString) {
	var units="px";
	if(typeof(sizeString) == "string") {
		var digitString=Number(parseInt(sizeString)).toString();
		if(sizeString.length > digitString.length) {
			units = sizeString.substr(digitString.length, (sizeString.length-digitString.length));
			if(!(units=="em" || units=="ex" || units=="px" || units=="in" || units=="cm" == units=="mm" || units=="pt" || units=="pc" || units=="%")) {
				units="px";
			}
		}
	}
	return units;
}

/**
* Splits a string, ignoring delimiters that are in quotes or parentheses. Comma 
* is the default split character, but the user can pass in a string of multiple 
* delimiters. It can handle nested parentheses, but not nested quotes.
*
* <p>TODO: handle escaped quotes</p>
*
* @param str	the string to split
* @param dels	an optional string of delimiter characters
* @returns		an array of strings
*/
AjxStringUtil.split =
function(str, dels) {

	if (!str) return new Array();

	dels = dels ? dels : ',';
	var isDel = new Object;
	if (typeof dels == 'string') {
		isDel[dels] = 1;
	} else {
		for (var i = 0; i < dels.length; i++) 
			isDel[dels[i]] = 1;
	}

	var q = false;
	var p = 0;
	var start = 0;
	var chunk;
	var chunks = new Array();
	var j = 0;
	for (var i = 0; i < str.length; i++) {
		var c = str.charAt(i);
		if (c == '"') {
			q = !q;
		} else if (c == '(') {
			p++;
		} else if (c == ')') {
			p--;
		} else if (isDel[c]) {
			if (!q && !p) {
				chunk = str.substring(start, i);
				chunks[j++] = chunk;
				start = i + 1;
			}
		}
	}
	chunk = str.substring(start, str.length);
	chunks[j++] = chunk;

	return chunks;
}

/**
* Wraps text to the given length and quotes it, breaking on space when possible. 
* Preserves line breaks. At this point, it assumes that the text to be wrapped 
* is raw text, not HTML, and that line returns are represented by '\n'. Wrapping 
* is optionally done across line returns that appear in paragraphs.
*
* @param text 		the text to be wrapped
* @param len		the desired line length of the wrapped text, defaults to 80
* @param pre		an optional string to prepend to each line (useful for quoting)
* @param eol		the eol sequence for each wrapped line, defaults to '\n'
* @param breakOkay	whether long words (longer than <code>len</code>) can be broken, default is false
* @param compress	remove single returns within a paragraph before wrapping
* @returns			the wrapped/quoted text
*/
AjxStringUtil.wordWrap = 
function(text, len, pre, eol, breakOkay, compress) {

	if (!text) return "";

	len = len ? len : 80;
	eol = eol ? eol : '\n';
	pre = pre ? pre : '';
	len -= pre.length;
	
	var chunks = new Array();
	var c = 0;
	
	// preprocess the text: remove leading/trailing space, space at the end of 
	// lines, and set up for wrapping paragraphs
	text = AjxStringUtil.trim(text, false);
	text = text.replace(/[ \t]+\n/g, '\n'); // optional tidying, could remove this step
	if (compress)
		text = text.replace(/\b\n\b/g, ' ');
	var textLen = text.length;
	// Wrap text by dividing it into chunks. We remember the last space we saw, 
	// and use it to begin a chunk when the length limit is reached.
	for (var i = 0, bk = 0, sp = -1; i < textLen; i++) {
		var ch = text.charAt(i);
		if (ch.match(/[ \t]/)) { // found a space
			sp = i;
		}
		if (ch == '\n') { // found a return
			chunks[c++] = pre + text.substring(bk, i);
			bk = i + 1; // skip the \n (those are added later in the join)
			sp = -1;
		}
		if (i - bk >= len) { // hit the limit
			if (sp == -1) { // current chunk is bigger than the limit (a 'long' word)
				if (breakOkay) {
					chunks[c++] = pre + text.substring(bk, i);
					bk = i;
					sp = -1;
				}
			} else {				
				chunks[c++] = pre + text.substring(bk, sp);
				bk = sp + 1;
				sp = -1;
			}
		}
	}
	// add remaining portion
	if (i > bk) {
		chunks[c++] = pre + text.substring(bk, i);
	}
	return chunks.join(eol) + eol;
}

/**
* Returns true if the character for the given key is considered printable.
*
* @param keycode	a numeric keycode (not a character code)
* @returns 			true if the character for the given key is considered printable
*/

AjxStringUtil.IS_PRINT_CODE = new Object();
var print_codes = [32,48,49,50,51,52,53,54,55,56,57,59,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
                   81,82,83,84,85,86,87,88,89,90,96,97,98,99,100,101,102,103,104,105,106,107,109,110,111,186,
                   187,188,189,190,191,192,219,220,221,222];
var l = print_codes.length;
for (var i = 0; i < l; i++) {
	AjxStringUtil.IS_PRINT_CODE[print_codes[i]] = true;
}

AjxStringUtil.isPrintKey =
function(keycode) {
	return AjxStringUtil.IS_PRINT_CODE[keycode];
}

/**
* Returns the character for the given key, taking the shift key into consideration.
*
* @param keycode	a numeric keycode (not a character code)
* @param shifted	whether the shift key is down
* @returns			a character
*/

AjxStringUtil.SHIFT_CHAR = { 48:')', 49:'!', 50:'@', 51:'#', 52:'$', 53:'%', 54:'^', 55:'&', 56:'*', 57:'(',
							59:':', 186:':', 187:'+', 188:'<', 189:'_', 190:'>', 191:'?', 192:'~',
							219:'{', 220:'|', 221:'}', 222:'"' }

AjxStringUtil.shiftChar =
function(keycode, shifted) {
	return shifted ? AjxStringUtil.SHIFT_CHAR[keycode] || String.fromCharCode(keycode) : String.fromCharCode(keycode);
}

/**
* Does a diff between two strings, returning the index of the first differing character.
*
* @param str1	a string
* @param str2	another string
* @returns		the index at which they first differ
*/
AjxStringUtil.diffPoint =
function(str1, str2) {
	if (!(str1 && str2))
		return 0;
	var len = Math.min(str1.length, str2.length);
	var i = 0;
	while (i < len && (str1.charAt(i) == str2.charAt(i)))
		i++;
	return i;
}

/**
* DEPRECATED
*
* Replaces variables in a string with values from a list. The variables are 
* denoted by a '$' followed by a number, starting from 0. For example, a string 
* of "Hello $0, meet $1" with a list of ["Harry", "Sally"] would result in the 
* string "Hello Harry, meet Sally".
*
* @param str		the string to resolve
* @param values	 	an array of values to interpolate
* @returns			a string with the variables replaced
*/
AjxStringUtil.resolve =
function(str, values) {
	DBG.println(AjxDebug.DBG1, "Call to deprecated function AjxStringUtil.resolve");
	return AjxMessageFormat.format(str, values);
/*
	if (!str) return "";
	if (!(values instanceof Array)) values = [values];
	if (!AjxEnv.isSafari)
		return str.replace(/\$(\d+)/g, function(str, num) { return values[num]; });

	//quick hack
	var match;
	while ((match = str.match(/\$(\d+)/)) != null) {
		var d = match[1];
		var re = new RegExp("\\$"+d);
		str = str.replace(re, values[d]);
	}
	return str;
*/
}

/**
* URL-encodes a string. Replace spaces with + then escape and any + become %2B 
* for for transport in URL's.
*
* @param str	the string to encode
*/

AjxStringUtil.urlEncode =
function(str) {
	if (!str) return "";
	return escape(str.replace(/ /g, '+')).replace(/[+]/g, '%2B');
}		

/**
* HTML-encodes a string.
*
* @param str	the string to encode
*/

AjxStringUtil.ENCODE_MAP = { '>' : '&gt;', '<' : '&lt;', '&' : '&amp;' };

AjxStringUtil.htmlEncode =
function(str, includeSpaces) {
	if (!str) return "";

	if (!AjxEnv.isSafari) {
		if (includeSpaces) 
			return str.replace(/[<>&]/g, function(htmlChar) { return AjxStringUtil.ENCODE_MAP[htmlChar]; }).replace(/  /g, ' &nbsp;');
		else
			return str.replace(/[<>&]/g, function(htmlChar) { return AjxStringUtil.ENCODE_MAP[htmlChar]; });
	} else {
		if (includeSpaces) 
			return str.replace(/[&]/g, '&amp;').replace(/  /g, ' &nbsp;').replace(/[<]/g, '&lt;').replace(/[>]/g, '&gt;');
		else
			return str.replace(/[&]/g, '&amp;').replace(/[<]/g, '&lt;').replace(/[>]/g, '&gt;');
	}
}		

AjxStringUtil.convertToHtml = function(str) {
	if (!str) return "";
	str = str
		.replace(/&/mg, "&amp;")
		.replace(/  /mg, " &nbsp;")
		.replace(/^ /mg, "&nbsp;")
		.replace(/\t/mg, "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;")
		.replace(/</mg, "&lt;")
		.replace(/>/mg, "&gt;")
		.replace(/\r?\n/mg, "<br />");
	return str;
};

/**
* HTML-encodes a string.
*
* @param str	the string to encode
*/

AjxStringUtil.SPACE_ENCODE_MAP = { ' ' : '&nbsp;', '>' : '&gt;', '<' : '&lt;', '&' : '&amp;' , '\n': '<br>'};

AjxStringUtil.htmlEncodeSpace =
function(str) {
	if (!str) return "";

	if (!AjxEnv.isSafari) {
		return str.replace(/[ <>&\n]/g, function(htmlChar) { return AjxStringUtil.SPACE_ENCODE_MAP[htmlChar]; });
	} else {
		return str.replace(/[&]/g, '&amp;').replace(/ /g, '&nbsp;').replace(/[<]/g, '&lt;').replace(/[>]/g, '&gt;');
	}
}

// this function makes sure a leading space is preservered, takes care of tabs, 
// then finally takes replaces newlines with <br>'s
AjxStringUtil.nl2br = 
function(str) {
	if (!str) return "";
	return str.replace(/^ /mg, "&nbsp;").replace(/\t/g, "<pre style='display:inline;'>\t</pre>").replace(/\n/g, "<br>");
}

AjxStringUtil.xmlEncode = 
function(str) {
	return str ? str.replace(/&/g,"&amp;").replace(/</g,"&lt;") : "";
}
AjxStringUtil.xmlDecode =
function(str) {
	return str ? str.replace(/&amp;/g,"&").replace(/&lt;/g,"<") : "";
}

AjxStringUtil.xmlAttrEncode =
function(str) {
	return str ? str.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\x22/g, '&quot;').replace(/\x27/g,"&apos;") : "";
}

AjxStringUtil.xmlAttrDecode =
function(str) {
	return str ? str.replace(/&amp;/g,"&").replace(/&lt;/g,"<").replace(/&quot;/g, '"').replace(/&apos;/g,"'") : "";
}

AjxStringUtil.regExEscape =
function(str) {
	return str.replace(/(\W)/g, "\\$1");
};

var AjxStringUtil_calcDIV = null; // used by 'clip()' and 'wrap()' functions

AjxStringUtil.calcDIV =
function() {
	if (AjxStringUtil_calcDIV == null) {
		AjxStringUtil_calcDIV = document.createElement("div");
		AjxStringUtil_calcDIV.style.zIndex = 0;
		AjxStringUtil_calcDIV.style.position = DwtControl.ABSOLUTE_STYLE;
		AjxStringUtil_calcDIV.style.visibility = "hidden";
		document.body.appendChild(AjxStringUtil_calcDIV);
	}
	return AjxStringUtil_calcDIV;
}

/**
 * Clips a string at "pixelWidth" using using "className" on hidden 'AjxStringUtil._calcDIV'.
 * Returns "origString" with "..." appended if clipped.
 *
 * NOTE: The same CSS style ("className") must be assigned to both the intended 
 * display area and the hidden 'AjxStringUtil._calcDIV'.  "className" is 
 * optional; if supplied, it will be assigned to 'AjxStringUtil._calcDIV' to 
 * handle different CSS styles ("className"s) on same page.
 *
 * NOTE2: MSIE Benchmark - clipping an average of 17 characters each over 190 
 * iterations averaged 27ms each (5.1 seconds total for 190)
 */
AjxStringUtil.clip =
function(origString, pixelWidth, className) {
	var calcDIV = AjxStringUtil.calcDIV();
	if (arguments.length == 3) calcDIV.className = className;
	//calcDIV.innerHTML = "<div>" + origString + "</div>"; // prevents screen flash in IE?
	calcDIV.innerHTML = origString;
	if (calcDIV.offsetWidth <= pixelWidth) return origString;

	for (var i=origString.length-1; i>0; i--) {
		var newString = origString.substr(0,i);
		calcDIV.innerHTML = newString + AjxStringUtil.ELLIPSIS;
		if (calcDIV.offsetWidth <= pixelWidth) return newString + AjxStringUtil.ELLIPSIS;
	}
	return origString;
}

/**
 * Forces a string to wrap at "pixelWidth" using "className" on hidden 'AjxStringUtil._calcDIV'.
 * Returns "origString" with "&lt;br&gt;" tags inserted to force wrapping.
 * Breaks string on embedded space characters, EOL ("/n") and "&lt;br&gt;" tags when possible.
 *
 * @returns		"origString" with "&lt;br&gt;" tags inserted to force wrapping.
 */
AjxStringUtil.wrap =
function(origString, pixelWidth, className) {
	var calcDIV = AjxStringUtil.calcDIV();
	if (arguments.length == 3) calcDIV.className = className;

	var newString = "";
	var newLine = "";
	textRows = origString.split("/n");
	for (var trCount=0; trCount<textRows.length; trCount++) {
		if (trCount != 0) {
			newString += newLine + "<br>";
			newLine = "";
		}
		htmlRows = textRows[trCount].split("<br>");
		for (var hrCount=0; hrCount<htmlRows.length; hrCount++) {
			if (hrCount != 0) {
				newString += newLine + "<br>";
				newLine = "";
			}
			words = htmlRows[hrCount].split(" ");
			var wCount=0;
			while (wCount<words.length) {
				calcDIV.innerHTML = newLine + " " + words[wCount];
				var newLinePixels = calcDIV.offsetWidth;
				if (newLinePixels > pixelWidth) {
					// whole "words[wCount]" won't fit on current "newLine" - insert line break, avoid incrementing "wCount"
					calcDIV.innerHTML = words[wCount];
					newLinePixels = newLinePixels - calcDIV.offsetWidth;
					if ( (newLinePixels >= pixelWidth) || (calcDIV.offsetWidth <= pixelWidth) ) {
						// either a) excess caused by <space> character or b) will fit completely on next line
						// so just break without incrementing "wCount" and append next time
						newString += newLine + "<br>";
						newLine = "";
					}
					else { // must break "words[wCount]"
						var keepLooping = true;
						var atPos = 0;
						while (keepLooping) {
							atPos++;
							calcDIV.innerHTML = newLine + " " + words[wCount].substring(0,atPos);
							keepLooping = (calcDIV.offsetWidth <= pixelWidth);
						}
						atPos--;
						newString += newLine + words[wCount].substring(0,atPos) + "<br>";
						words[wCount] = words[wCount].substr(atPos);
						newLine = "";
					}
				} else { // doesn't exceed pixelWidth, append to "newLine" and increment "wCount"
					newLine += " " + words[wCount];
					wCount++;
				}
			}
		}
	}
	newString += newLine;
	return newString;
}

// Regexes for finding non-quoted content
AjxStringUtil.MSG_SEP_RE = new RegExp("^\\s*--+\\s*(" + "Original Message" + "|" + "Forwarded Message" + ")\\s*--+", "i");
AjxStringUtil.SIG_RE = /^(- ?-+)|(__+)\r?$/;
AjxStringUtil.COLON_RE = /\S+:$/;
AjxStringUtil.PREFIX_RE = /^\s*(>|\|)/;
AjxStringUtil.BRACKET_RE = /^\s*\[.+\]\s*$/;
AjxStringUtil.LINE_RE = /^\s*_{30,}\s*$/;
AjxStringUtil.BLANK_RE = /^\s*$/;
AjxStringUtil.HDR_RE = /^\s*\w+:/;

/**
* Returns a list of chunks of top-level content in a message body. Top-level content is what was
* actually typed by the sender. We attempt to exclude quoted content and signatures.
*
* The following lines/blocks (and variants) and any text after them are ignored:
*
* 		----- Original Message -----
*
* 		----- Forwarded Message -----
*
*		-- 
*		some signature text
*
*		______________________________		|
*											| Outlook 2003 does this
*		From:								|
*
* Lines that begin with a prefix character ("&gt;" or "|") are ignored. The following
* lines/blocks are ignored if they precede a line that begins with a prefix character:
*
* 		Fred Flintstone <fred@bedrock.org> wrote:
*
* 		Fred Flintstone <fred@bedrock.org> wrote:
*		[snipped]
*
* Since quoted text may be interleaved with original text, we may return several chunks of
* original text. That is so they may be separated when they are quoted.
*
* @param text		a message body
* @param eol		the eol sequence, defaults to '\n'
*/
AjxStringUtil.getTopLevel =
function(text, eol) {
	eol = eol ? eol : '\n';
	text = AjxStringUtil._trimBlankLines(text, eol);
	var lines = text.split(eol);
	var len = lines.length;
	var i = 0, start = 0;
	var chunks = new Array();
	var skipping = false;
	while (i < len) {
		var wasSkipping = skipping;
		var skip = AjxStringUtil._linesToSkip(lines, i);
		skipping = (skip > 0);
		if (wasSkipping && !skipping)
			start = i;
		else if (!wasSkipping && skipping && i > start)
			chunks.push(AjxStringUtil._trimBlankLines(lines.slice(start, i).join(eol), eol) + eol);
		i += skipping ? skip : 1;
	}
	if (!skipping && i > start)
		chunks.push(AjxStringUtil._trimBlankLines(lines.slice(start, i).join(eol), eol) + eol);

	return chunks;
}

// Starting at a given line, returns the number of lines that should be skipped because
// they are quoted (or signature) content.
AjxStringUtil._linesToSkip =
function(lines, i) {
	var len = lines.length;
	var skip = 0;
	var start = i;
	if (AjxStringUtil.MSG_SEP_RE.test(lines[i])) {
		skip = len - i;
	} else if (AjxStringUtil.SIG_RE.test(lines[i])) {
		skip = len - i;
	} else if (AjxStringUtil.PREFIX_RE.test(lines[i])) {
		while (i < lines.length && (AjxStringUtil.PREFIX_RE.test(lines[i]) || AjxStringUtil.BLANK_RE.test(lines[i])))
			i++;
		skip = i - start;
	} else if (AjxStringUtil.COLON_RE.test(lines[i])) {
		var idx = AjxStringUtil._nextNonBlankLineIndex(lines, i + 1);
		var line1 = (idx != -1) ? lines[idx] : null;
		if (line1 && AjxStringUtil.PREFIX_RE.test(line1)) {
			skip = idx - i;
		} else {
			if (idx != -1)
				idx = AjxStringUtil._nextNonBlankLineIndex(lines, idx + 1);
			var line2 = (idx != -1) ? lines[idx] : null;
			if (line2 && AjxStringUtil.BRACKET_RE.test(line1) && AjxStringUtil.PREFIX_RE.test(line2))
				skip = idx - i;
		}
	} else if (AjxStringUtil.LINE_RE.test(lines[i])) {
		var idx = AjxStringUtil._nextNonBlankLineIndex(lines, i + 1);
		var line1 = (idx != -1) ? lines[idx] : null;
		if (line1 && AjxStringUtil.HDR_RE.test(line1))
			skip = len - i;
	}
	return skip;
}

// Returns the index of the next non-blank line
AjxStringUtil._nextNonBlankLineIndex =
function(lines, i) {
	while (i < lines.length && AjxStringUtil.BLANK_RE.test(lines[i]))
		i++;
	return ((i < lines.length) ? i : -1);
}

// Removes blank lines from the beginning and end of text
AjxStringUtil._trimBlankLines =
function(text, eol) {
	eol = eol ? eol : '\n';
	var lines = text.split(eol);
	var len = lines.length;
	var i = 0;
	while (i < len && AjxStringUtil.BLANK_RE.test(lines[i]))
		i++;
	var j = len;
	while (j > 0 && AjxStringUtil.BLANK_RE.test(lines[j - 1]))
		j--;
	if (i != 0 || j != len)
		text = lines.slice(i, j).join(eol) + eol;

	return text;
}

/**
* Converts a HTML document represented by a DOM tree  to text
*
* There has got to be a better way of doing this! 
*/

AjxStringUtil._NO_LIST = 0;
AjxStringUtil._ORDERED_LIST = 1;
AjxStringUtil._UNORDERED_LIST = 2;
AjxStringUtil._INDENT = "    ";
AjxStringUtil._NON_WHITESPACE = /\S+/;
AjxStringUtil._LF = /\n/;

AjxStringUtil.convertHtml2Text =
function(domRoot) {
	if (!domRoot) return null;
	var text = new Array();
	var idx = 0;
	var ctxt = new Object();
	this._traverse(domRoot, text, idx, AjxStringUtil._NO_LIST, 0, 0, ctxt);
	var textStr = text.join("");
	return textStr;
}

AjxStringUtil._traverse =
function(el, text, idx, listType, listLevel, bulletNum, ctxt) {
	var nodeName = el.nodeName.toLowerCase();

	if (nodeName == "#text") {
		if (el.nodeValue.search(AjxStringUtil._NON_WHITESPACE) != -1) {
			if (ctxt.lastNode == "ol" || ctxt.lastNode == "ul")
				text[idx++] = "\n";
			text[idx++] = AjxStringUtil.trim(el.nodeValue.replace(AjxStringUtil._LF, " "), true) + " ";
		}
	} else if (nodeName == "p") {
		text[idx++] = "\n\n";
	} else if (listType == AjxStringUtil._NO_LIST && (nodeName == "br" || nodeName == "hr")) {
		text[idx++] = "\n";
	} else if (nodeName == "ol" || nodeName == "ul") {
		text[idx++] = "\n";
		if (el.parentNode.nodeName.toLowerCase() != "li" && ctxt.lastNode != "br"
			&& ctxt.lastNode != "hr")
			text[idx++] = "\n";
		listType = (nodeName == "ol") ? AjxStringUtil._ORDERED_LIST : AjxStringUtil._UNORDERED_LIST;
		listLevel++;
		bulletNum = 0;
	} else if (nodeName == "li") {
		for (var i = 0; i < listLevel; i++)
			text[idx++] = AjxStringUtil._INDENT;
		if (listType == AjxStringUtil._ORDERED_LIST)
			text[idx++] = bulletNum + ". ";
		else
			text[idx++] = "\u2022 "; // TODO LmMsg.bullet
	} else if (nodeName == "img") {
		if (el.alt && el.alt != "")
			text[idx++] = el.alt; 
	} else if (nodeName == "tr" && el.parentNode.firstChild != el) {
		text[idx++] = "\n";
	} else if (nodeName == "td" && el.parentNode.firstChild != el) {
		text[idx++] = "\t";
	} else if (nodeName == "div") {
		text[idx++] = "\n";
	} else if (nodeName == "#comment" || 
			   nodeName == "script" || 
			   nodeName == "select" ||
			   nodeName == "style") {
		return idx;
	}
	
	var childNodes = el.childNodes;
	var len = childNodes.length;
	for (var i = 0; i < len; i++) {
		if (nodeName == "ol")
			bulletNum++;
		idx = this._traverse(childNodes[i], text, idx, listType, listLevel, bulletNum, ctxt);
	}

	if (nodeName == "h1" || nodeName == "h2" || nodeName == "h3" || nodeName == "h4" 
		|| nodeName == "h5" || nodeName == "h6") {
			text[idx++] = "\n";
			ctxt.list = false;
	} else if (nodeName == "li") {
		if (!ctxt.list)
			text[idx++] = "\n";
		ctxt.list = false;
	} else if (nodeName == "ol" || nodeName == "ul") {
		ctxt.list = true;
	} else if (nodeName != "#text") {
		ctxt.list = false;
	}
	
	ctxt.lastNode = nodeName;
	return idx;	
}

/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
 * This requires an "owner" which is the object that owns the full set of items, implmenting:
 * getItemCount() to return the number of items
 * getItem(index) to return the item at a given index.
 * 
 * And optionally implementing
 * itemSelectionChanged(item, index, isSelected) which is called
 *         for each item that is selected or deselected
 * selectionChanged() which is called after a batch of items have
 *         been selected or deselected with select()
 *
 */
	
AjxSelectionManager = function(anOwner) {
	this._owner = anOwner;
};

// -----------------------------------------------------------
// Constants
// -----------------------------------------------------------

// Actions for select()
AjxSelectionManager.SELECT_ONE_CLEAR_OTHERS = 0;
AjxSelectionManager.TOGGLE_ONE_LEAVE_OTHERS = 1;
AjxSelectionManager.SELECT_TO_ANCHOR = 2;
AjxSelectionManager.DESELECT_ALL = 3;
AjxSelectionManager.SELECT_ALL = 4;

// -----------------------------------------------------------
// API Methods
// -----------------------------------------------------------

/**
 * returns an AjxVector
 */
AjxSelectionManager.prototype.getItems = function() {
	if (this._selectedItems == null) {
		this._selectedItems = this._createItemsCollection();
	}
	return this._selectedItems;
};

/**
 * returns the number of selected items
 */	
AjxSelectionManager.prototype.getLength = function() {
	return this.getItems().length;
};
	
/**
 * returns the anchor, unless nothing is selected
 */
AjxSelectionManager.prototype.getAnchor = function() {
	if (this._anchor == null) {
		var items = this.getItems();
		if (items.length > 0) {
			this._anchor = items[0];
		}
	}
	return this._anchor;
};
    
/**
 * The cursor probably changes when the users navigates with 
 * the keyboard. This returns the item that is currently the cursor,
 * and null if nothing is selected.
 */
AjxSelectionManager.prototype.getCursor = function() {
	if (this._cursor == null) {
		this._cursor = this.getAnchor();
	}
	return this._cursor;
};
    
    
/**
 * Returns true if the given item is selected.
 */
AjxSelectionManager.prototype.isSelected = function(item) {
	return this.getItems().binarySearch(item) != -1;
};
    
AjxSelectionManager.prototype.selectOneItem = function(item) {
	this.select(item, AjxSelectionManager.SELECT_ONE_CLEAR_OTHERS);
};
    
AjxSelectionManager.prototype.toggleItem = function(item) {
	this.select(item, AjxSelectionManager.TOGGLE_ONE_LEAVE_OTHERS);
};
	
AjxSelectionManager.prototype.selectFromAnchorToItem = function(item) {
	this.select(item, AjxSelectionManager.SELECT_TO_ANCHOR);
};
    
AjxSelectionManager.prototype.deselectAll = function() {
	this.select(null, AjxSelectionManager.DESELECT_ALL);
};
	
AjxSelectionManager.prototype.selectAll = function() {
	this.select(null, AjxSelectionManager.SELECT_ALL);
};
    
    
/**
 * This method will notify the owner of any changes by calling
 * itemSelectionChanged() (if the owner defines it) for each item whose
 * selection changes and also by calling selectionChanged() (if the
 * owner defines it) once at the end, if anything changed selection.
 *
 */
AjxSelectionManager.prototype.select = function(item, action) {
	
	// Update the anchor and cursor, if necessary
	this._setAnchorAndCursor(item, action);
    
	// save off the old set of selected items
	var oldItems = this._selectedItems;
	var oldItemsCount = (oldItems == null) ? 0 : oldItems.length;
	
	// create a fresh set of selected items
	this._selectedItems = null;
	this._selectedItems = this._createItemsCollection();
	
	// Now update the selection
	var itemCount = this._owner.getItemCount();
	var needsSort = false;
	var selectionChanged = false;
	var selecting = false;
	for (var i = 0; i < itemCount; ++i) {
		var testItem = this._owner.getItem(i);
		var oldSelectionExists = this._isItemOldSelection(testItem, oldItems);
		var newSelectionExists = oldSelectionExists;
		
		switch (action) {
		case AjxSelectionManager.SELECT_TO_ANCHOR:
			if (this._anchor == null) {
				// If we have no anchor, let it be the first item
				// in the list
				this._anchor = testItem;
			}
			var atEdge = (testItem == this._anchor || testItem == item);
			var changed = false;
			// mark the beginning of the selection for the iteration
			if (!selecting && atEdge) {
				selecting = true;
				changed = true;
			}
			newSelectionExists = selecting;
			// mark the end of the selection if we're there
			if ((!changed || this._anchor == item) 
				&& selecting && atEdge) {
				selecting = false;
			}

			break;
		case AjxSelectionManager.SELECT_ONE_CLEAR_OTHERS:
			newSelectionExists = (testItem == item);
			break;
		case AjxSelectionManager.TOGGLE_ONE_LEAVE_OTHERS:
			if (testItem == item) {
				newSelectionExists = !oldSelectionExists ;
			}
			break;
		case AjxSelectionManager.DESELECT_ALL:
			newSelectionExists = false;
			break;
		case AjxSelectionManager.SELECT_ALL:
			newSelectionExists = true;
			break;
		}

		if (newSelectionExists) {
			this._selectedItems.add(testItem);
			needsSort = (this._selectedItems.length > 1);
		}

		if ( newSelectionExists != oldSelectionExists) {
			// Something changed so notify the owner.
			if (this._owner.itemSelectionChanged != null) {
				this._owner.itemSelectionChanged(testItem, 
												 i, newSelectionExists);
			}
			selectionChanged = true;
		}
	}
	selectionChanged = selectionChanged || (oldItemsCount != 
											this._selectedItems.length);

	if (needsSort) this._selectedItems.sort();
	
	if (selectionChanged && this._owner.selectionChanged != null) {
		this._owner.selectionChanged(item);
	}
};

/**
 * Remove an item from the selection managers selected items
 * collection if it exists.
 */
AjxSelectionManager.prototype.removeItem = function(item) {
	if (this._selectedItems) {
		var index = this._selectedItems.binarySearch(item);
		if (index > -1) this._selectedItems.removeAt(index);
	}
};

// -----------------------------------------------------------
// Internal Methods
// -----------------------------------------------------------
	
/**
 * Creates an array suitable for use as the sorted list of selected
 * items and returns it.
 */
AjxSelectionManager.prototype._createItemsCollection = function() {
	return new AjxVector();
};

AjxSelectionManager.prototype._isItemOldSelection = function (testItem, oldItems) {
	var ret = false;
	if (oldItems) {
		var oldSelectionIndex = oldItems.binarySearch(testItem);
		if (oldSelectionIndex > -1) {
			oldItems.removeAt(oldSelectionIndex);
		}
		ret = (oldSelectionIndex != -1);
	}
	return ret;
};

AjxSelectionManager.prototype._setAnchorAndCursor = function (item, action) {
	switch (action) {
	case AjxSelectionManager.SELECT_TO_ANCHOR:
		this._cursor = item;
		break;
	case AjxSelectionManager.SELECT_ONE_CLEAR_OTHERS:		
		this._anchor = item;
		this._cursor = item;
		break;
	case AjxSelectionManager.TOGGLE_ONE_LEAVE_OTHERS:
		this._anchor = item;
		this._cursor = item;
		break;
	case AjxSelectionManager.DESELECT_ALL:
		this._anchor = null;
		this._cursor = null;
		break;
	case AjxSelectionManager.SELECT_ALL:
		return;
	}
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Resets the AjxPost object.
* @constructor
* @class
* This singleton class makes an HTTP POST to the server and receives the response, passing returned data
* to a callback. This class is used to upload files from the client browser to the server using the file
* upload feature of POST.
*
* @author Conrad Damon
*/
function AjxPost(iframeId) {
	this._callback = null;
	this._iframeId = iframeId;
}


// Globals

AjxPost._reqIds = 0;
AjxPost._outStandingRequests = new Object();


// Consts 

// Common HttpServletResponse error codes
// - see full list: http://java.sun.com/products/servlet/2.2/javadoc/javax/servlet/http/HttpServletResponse.html
AjxPost.SC_CONTINUE					= 100;
AjxPost.SC_OK						= 200;
AjxPost.SC_ACCEPTED 				= 202;
AjxPost.SC_BAD_REQUEST				= 400;
AjxPost.SC_UNAUTHORIZED				= 401;
AjxPost.SC_REQUEST_TIMEOUT			= 408;
AjxPost.SC_CONFLICT					= 409;
AjxPost.SC_REQUEST_ENTITY_TOO_LARGE = 413;
AjxPost.SC_INTERNAL_SERVER_ERROR	= 500;
AjxPost.SC_BAD_GATEWAY 				= 502;
AjxPost.SC_SERVICE_UNAVAILABLE		= 503;


// Public methods

/**
* Submits the form.
*
* @param callback		function to return to after the HTTP response is received
* @param formId			DOM ID of the form
*/
AjxPost.prototype.execute =
function(callback, form, optionalTimeout) {
	form.target = this._iframeId;
	this._callback = callback;
	var req = new AjxPostRequest(form);
	var failureAction = new AjxTimedAction(this, this._onFailure, [req.id]);
	var timeout = optionalTimeout? optionalTimeout: 5000;
	AjxPost._outStandingRequests[req.id] = req;
	req.send(failureAction, timeout);
};


// Private methods

AjxPost.prototype._onFailure =
function (reqId){
	var req = AjxPost._outStandingRequests[reqId];
	req.cancel();
	delete AjxPost._outStandingRequests[reqId];
	if (this._callback) {
		this._callback.run([404]);
		this._callback = null;
	}
};



/**
* Processes the HTTP response from the form post. The server needs to make sure this function is
* called and passed the appropriate args. Something like the following should do the trick:
* <code>
*        out.println("<html><head></head><body onload=\"window.parent._uploadManager.loaded(" + results +");\"></body></html>");
* </code>
*
* @param status		an HTTP status
* @param id			the id for any attachments that were uploaded
*/
AjxPost.prototype.loaded =
function(status, reqId, id) {
	//alert(document.getElementById(this._iframeId).contentWindow.document.documentElement.innerHTML);
	var req = AjxPost._outStandingRequests[reqId];
	if (req && !req.hasBeenCancelled()) {
		req.cancelTimeout();
	}
	delete AjxPost._outStandingRequests[reqId];
	if (this._callback) {
		this._callback.run(status, id);
		this._callback = null;
	}
};

function AjxPostRequest (form) {
	this.id = AjxPost._reqIds++;
	this._cancelled = false;
	this._form = form;
	var inp = form.elements.namedItem("requestId");
	if (!inp) {
		inp = form.ownerDocument.createElement('input');
		inp.type = "hidden";
		inp.name = "requestId";
	}
	inp.value = this.id;
	form.appendChild(inp);
};

AjxPostRequest.prototype.send =
function(failureAction, timeout) {
	this._form.submit();
};

AjxPostRequest.prototype.hasBeenCancelled =
function() {
	return this._cancelled;
};

AjxPostRequest.prototype.cancelTimeout =
function() {
	AjxTimedAction.cancelAction(this._timeoutId);
};

AjxPostRequest.prototype.cancel =
function() {
	this._cancelled = true;
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* @class
* Use this class to implement an efficient String Buffer.
*	It is especially useful for assembling HTML.
*
*	Useage:
* 	1) For a small amount of text, call it statically as:
*
*		AjxBuffer.concat("a", 1, "b", this.getFoo(), ...);
*
*	2) Or create an instance and use that to assemble a big pile of HTML:
*
*		var buffer = new AjxBuffer();
*		buffer.append("foo", myObject.someOtherFoo(), ...);
*		...
*		buffer.append(fooo.yetMoreFoo());
*		return buffer.toString()
*
*	It is useful (and quicker!) to create a single buffer and then pass that to subroutines
*	that are doing assembly of HTML pieces for you.
*
*	Note that in both modes you can pass as many arguments you like to the
*	methods -- this is quite a bit faster than concatenating the arguments
*	with the + sign (eg: don't do  buffer.append("a" + b.foo());	)
*
* @author Owen Williams
*/

function AjxBuffer() {
	this.clear();
	if (arguments.length > 0) {
		arguments.join = this.buffer.join;
		this.buffer[this.buffer.length] = arguments.join("");
	}
}
AjxBuffer.prototype.toString = function () {
	return this.buffer.join("");
}
AjxBuffer.prototype.join = function (delim) {
	if (delim == null) delim = "";
	return this.buffer.join(delim);
}
AjxBuffer.prototype.append = function () {
	arguments.join = this.buffer.join;
	this.buffer[this.buffer.length] = arguments.join("");
}
AjxBuffer.prototype.join = function (str) {
	return this.buffer.join(str);
}
AjxBuffer.prototype.set = function(str) {
	this.buffer = [str];
}
AjxBuffer.prototype.clear = function() {
	this.buffer = [];
}
AjxBuffer.concat = function() {
	arguments.join = Array.prototype.join;
	return arguments.join("");
}
AjxBuffer.append = AjxBuffer.concat;
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a new, empty cache.
* @constructor
* @class
* This class represent a simple cache. So far, the cache does not do any management
* such as LRU, TTL, etc.
*
* @author Conrad Damon
*/
function AjxCache() {
	this._cache = new Object();
}

/**
* Adds a value with the given key to the cache.
*
* @param key	[primitive]		unique key
* @param value	[any]			value
*/
AjxCache.prototype.set =
function(key, value) {
	this._cache[key] = value;
}

/**
* Returns the value with the given key.
*
* @param key	[primitive]		unique key
*/
AjxCache.prototype.get =
function(key) {
	return this._cache[key];
}

/**
* Returns a list of all the values which have a certain value
* for a certain property.
*
* @param prop	[string]		a property
* @param value	[primitive]		a value
*/
AjxCache.prototype.getByProperty =
function(prop, value) {
	var list = new Array();
	for (var key in this._cache) {
		var obj = this._cache[key];
		if (obj instanceof Object && obj[prop] == value)
			list.push(obj);
	}
	return list;
}

/**
* Clears the cache.
*/
AjxCache.prototype.clearAll =
function() {
	for (var key in this._cache)
		this._cache[key] = null;
	this._cache = new Object();
}

/*
* Removes the value with the given key from the cache.
*
* @param key	[primitive]		unique key
*/
AjxCache.prototype.clear =
function(key) {
	this._cache[key] = null;
}

/*
* Removes all values which have a certain property with a certain value.
*
* @param prop	[string]		a property
* @param value	[primitive]		a value
*/
AjxCache.prototype.clearByProperty =
function(prop, value) {
	for (var key in this._cache) {
		var obj = this._cache[key];
		if (obj[prop] == value)
			this._cache[key] = null
	}
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/*
 * Based on code by Paul Johnston:
 *
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

// Namespace for common functions
// Members are initialized at the end of this file
// Do NOT instantiate.  Call class members like this:
//
//    var md5_hash = AjxMD5.hex_md5('foo bar');
//
// See the available methods at EOF (look for "this").
var AjxMD5 = function() {

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
	var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
	var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
	var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * Add integers, wrapping at 2^32.  Uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
	function safe_add(x, y) {
		var lsw = (x & 0xFFFF) + (y & 0xFFFF);
		var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		return (msw << 16) | (lsw & 0xFFFF);
	};

/*
 * Bitwise rotate a 32-bit number to the left.
 */
	function bit_rol(num, cnt) {
		return (num << cnt) | (num >>> (32 - cnt));
	};

/*
 * These functions implement the four basic operations the algorithm uses.
 */
	function md5_cmn(q, a, b, x, s, t) {
		return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	};

	function md5_ff(a, b, c, d, x, s, t) {
		return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	};

	function md5_gg(a, b, c, d, x, s, t) {
		return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	};

	function md5_hh(a, b, c, d, x, s, t) {
		return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	};

	function md5_ii(a, b, c, d, x, s, t) {
		return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	};

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
	function core_md5(x, len) {
		/* append padding */
		x[len >> 5] |= 0x80 << ((len) % 32);
		x[(((len + 64) >>> 9) << 4) + 14] = len;

		var a =  1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d =  271733878;

		for (var i = 0; i < x.length; i += 16) {
			var olda = a;
			var oldb = b;
			var oldc = c;
			var oldd = d;

			a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
			d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
			c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
			b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
			a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
			d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
			c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
			b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
			a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
			d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
			c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
			b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
			a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
			d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
			c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
			b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

			a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
			d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
			c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
			b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
			a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
			d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
			c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
			b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
			a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
			d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
			c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
			b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
			a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
			d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
			c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
			b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

			a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
			d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
			c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
			b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
			a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
			d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
			c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
			b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
			a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
			d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
			c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
			b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
			a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
			d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
			c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
			b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

			a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
			d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
			c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
			b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
			a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
			d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
			c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
			b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
			a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
			d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
			c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
			b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
			a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
			d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
			c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
			b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

			a = safe_add(a, olda);
			b = safe_add(b, oldb);
			c = safe_add(c, oldc);
			d = safe_add(d, oldd);
		}
		return Array(a, b, c, d);
	};

/*
 * Convert a string to an array of little-endian words
 * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
 */
	function str2binl(str) {
		var bin = Array();
		var mask = (1 << chrsz) - 1;
		for (var i = 0; i < str.length * chrsz; i += chrsz)
			bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);
		return bin;
	};

/*
 * Calculate the HMAC-MD5, of a key and some data
 */
	function core_hmac_md5(key, data) {
		var bkey = str2binl(key);
		if(bkey.length > 16) bkey = core_md5(bkey, key.length * chrsz);

		var ipad = Array(16), opad = Array(16);
		for (var i = 0; i < 16; i++) {
			ipad[i] = bkey[i] ^ 0x36363636;
			opad[i] = bkey[i] ^ 0x5C5C5C5C;
		}

		var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);
		return core_md5(opad.concat(hash), 512 + 128);
	};

/*
 * Convert an array of little-endian words to a string
 */
	function binl2str(bin) {
		var str = "";
		var mask = (1 << chrsz) - 1;
		for (var i = 0; i < bin.length * 32; i += chrsz)
			str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);
		return str;
	};

/*
 * Convert an array of little-endian words to a hex string.
 */
	function binl2hex(binarray) {
		var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
		var str = "";
		for (var i = 0; i < binarray.length * 4; i++) {
			str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
				hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
		}
		return str;
	};

/*
 * Convert an array of little-endian words to a base-64 string
 */
	function binl2b64(binarray) {
		var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		var str = "";
		for (var i = 0; i < binarray.length * 4; i += 3) {
			var triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16)
				| (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 )
				|  ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);
			for (var j = 0; j < 4; j++) {
				if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
				else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
			}
		}
		return str;
	};

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
	function hex_md5(s) { return binl2hex(core_md5(str2binl(s), s.length * chrsz)); };
	function b64_md5(s) { return binl2b64(core_md5(str2binl(s), s.length * chrsz)); };
	function str_md5(s) { return binl2str(core_md5(str2binl(s), s.length * chrsz)); };
	function hex_hmac_md5(key, data) { return binl2hex(core_hmac_md5(key, data)); };
	function b64_hmac_md5(key, data) { return binl2b64(core_hmac_md5(key, data)); };
	function str_hmac_md5(key, data) { return binl2str(core_hmac_md5(key, data)); };

/*
 * Perform a simple self-test to see if the VM is working
 */
	function md5_vm_test() {
		return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
	};

	// initialize global stuff
	this.hex_md5 = hex_md5;
	this.b64_md5 = b64_md5;
	this.str_md5 = str_md5;
	this.hex_hmac = hex_hmac_md5;
	this.b64_hmac = b64_hmac_md5;
	this.str_hmac = str_hmac_md5;
	this.md5_vm_test = md5_vm_test;
};

AjxMD5 = new AjxMD5;
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtImg() {
}

DwtImg.BLANK16 = ["", 16, 16];					// UNUSED
DwtImg.BLANK16REAL = ["Blank_16", 16, 16];		// ---
DwtImg.BLANK9 = ["", 9, 9];						// ONE INSTANCE, CHANGED TO USE ACTUAL GRAPHIC
DwtImg.CASCADE = ["Cascade", 16, 16];			// ---
DwtImg.COLUMN_DOWN = ["ColumnDownArrow", 8, 7];	// ---
DwtImg.COLUMN_UP = ["ColumnUpArrow", 8, 7];		// ---
DwtImg.CRITICAL = ["Critical_32", 32, 32];		// ---
DwtImg.DROP_DOWN = ["DropDown", 8, 8];			// UNUSED
DwtImg.DROP_DOWN_DISABLED = ["DropDown_D", 8, 8];//UNUSED
DwtImg.FAST_FWD = ["FastFwdArrowSmall", 10, 9];	//---
DwtImg.FAST_REV = ["FastRevArrowSmall", 10, 9];	//---
DwtImg.FWD = ["FwdArrowSmall", 6, 9];			//---
DwtImg.IMAGE_UNAVAIL = ["DataUnavailable"];		// COULDNT FIND
DwtImg.INFORMATION = ["Information_32", 32, 32];//---
DwtImg.MENU_CHECK = ["MenuCheck", 9, 9];		//---
DwtImg.MENU_RADIO = ["MenuRadio", 9, 9];		//---
DwtImg.NODE_COLLAPSED = ["NodeCollapsed", 16, 16];//---
DwtImg.NODE_EXPANDED = ["NodeExpanded", 16, 16];//---
DwtImg.REV = ["RevArrowSmall", 6, 9];			//---
DwtImg.SELECT_PULL_DOWN = ["SelectPullDownArrow", 16, 18];		// ---
DwtImg.SELECT_PULL_DOWN_DEPRESSED = ["SelectPullDownArrowSel", 16, 18];// ---
DwtImg.SELECT_PULL_DOWN_DISABLED = ["SelectPullDownArrowDis", 16, 18];// ---
DwtImg.SELECT_PULL_DOWN_ENABLED = ["SelectPullDownArrowHover", 16, 18];// ---
DwtImg.SELECT_PULL_UP = ["SelectPullUpArrow", 16, 18];// ---
DwtImg.WARNING = ["Warning_32", 32, 32];		// ---


DwtImg.TAB_TOP_LEFT = ["tab_TL",10,10];
DwtImg.TAB_TOP_MIDDLE = ["tab_T",10,10];
DwtImg.TAB_TOP_RIGHT = ["tab_TR",10,10];
DwtImg.TAB_MIDDLE_LEFT = ["tab_L",10,10];
DwtImg.TAB_MIDDLE_MIDDLE = ["tab_BG",10,10];
DwtImg.TAB_MIDDLE_RIGHT = ["tab_R",10,10];
DwtImg.TAB_BOTTOM_LEFT = ["tab_BL",10,10];
DwtImg.TAB_BOTTOM_MIDDLE = ["tab_B",10,10];
DwtImg.TAB_BOTTOM_RIGHT = ["tab_BR",10,10];

DwtImg.TAB_SELECTED_TOP_LEFT = ["tab_selected_TL",10,10];
DwtImg.TAB_SELECTED_TOP_MIDDLE = ["tab_selected_T",10,10];
DwtImg.TAB_SELECTED_TOP_RIGHT = ["tab_selected_TR",10,10];
DwtImg.TAB_SELECTED_MIDDLE_LEFT = ["tab_selected_L",10,10];
DwtImg.TAB_SELECTED_MIDDLE_MIDDLE = ["tab_selected_BG",10,10];
DwtImg.TAB_SELECTED_MIDDLE_RIGHT = ["tab_selected_R",10,10];
DwtImg.TAB_SELECTED_BOTTOM_LEFT = ["tab_selected_BL",10,10];
DwtImg.TAB_SELECTED_BOTTOM_MIDDLE = ["tab_selected_B",10,10];
DwtImg.TAB_SELECTED_BOTTOM_RIGHT = ["tab_selected_BR",10,10];

DwtImg.TAB_ACTIVE_TOP_LEFT = ["tab_active_TL",10,10];
DwtImg.TAB_ACTIVE_TOP_MIDDLE = ["tab_active_T",10,10];
DwtImg.TAB_ACTIVE_TOP_RIGHT = ["tab_active_TR",10,10];
DwtImg.TAB_ACTIVE_MIDDLE_LEFT = ["tab_active_L",10,10];
DwtImg.TAB_ACTIVE_MIDDLE_MIDDLE = ["tab_active_BG",10,10];
DwtImg.TAB_ACTIVE_MIDDLE_RIGHT = ["tab_active_R",10,10];
DwtImg.TAB_ACTIVE_BOTTOM_LEFT = ["tab_active_BL",10,10];
DwtImg.TAB_ACTIVE_BOTTOM_MIDDLE = ["tab_active_B",10,10];
DwtImg.TAB_ACTIVE_BOTTOM_RIGHT = ["tab_active_BR",10,10];

DwtImg.TAB_DISABLED_TOP_LEFT = ["tab_disabled_TL",10,10];
DwtImg.TAB_DISABLED_TOP_MIDDLE = ["tab_disabled_T",10,10];
DwtImg.TAB_DISABLED_TOP_RIGHT = ["tab_disabled_TR",10,10];
DwtImg.TAB_DISABLED_MIDDLE_LEFT = ["tab_disabled_L",10,10];
DwtImg.TAB_DISABLED_MIDDLE_MIDDLE = ["tab_disabled_BG",10,10];
DwtImg.TAB_DISABLED_MIDDLE_RIGHT = ["tab_disabled_R",10,10];
DwtImg.TAB_DISABLED_BOTTOM_LEFT = ["tab_disabled_BL",10,10];
DwtImg.TAB_DISABLED_BOTTOM_MIDDLE = ["tab_disabled_B",10,10];
DwtImg.TAB_DISABLED_BOTTOM_RIGHT = ["tab_disabled_BR",10,10];

DwtImg.TAB_SPACER = ["tab_spacer",10,10];

/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function Dwt() {
}

// Constants for positioning
Dwt.STATIC_STYLE = "static";
Dwt.ABSOLUTE_STYLE = "absolute";
Dwt.RELATIVE_STYLE = "relative";

// Background repeat 
Dwt.NO_REPEAT = "no-repeat";
Dwt.REPEAT = "repeat";
Dwt.REPEAT_X = "repeat-x";
Dwt.REPEAT_Y = "repeat-y";

// display style
Dwt.DISPLAY_INLINE = "inline";
Dwt.DISPLAY_BLOCK = "block";
Dwt.DISPLAY_NONE = "none";

// constants for layout
Dwt.LEFT = 100;
Dwt.RIGHT = 101;
Dwt.TOP = 102;
Dwt.BOTTOM = 103;

Dwt.ABOVE = 104;
Dwt.BELOW = 105;

Dwt.WIDTH = 106;
Dwt.HEIGHT = 107;

// Scroll constants
Dwt.CLIP = 1;
Dwt.VISIBLE = 2;
Dwt.SCROLL = 3;
Dwt.FIXED_SCROLL = 4;

// z-index order
Dwt.Z_HIDDEN = 100;		// hide the display
Dwt.Z_CURTAIN = 200;	// not used; could be used if there is leakage
Dwt.Z_VIEW = 300;		// make visible
Dwt.Z_MENU = 500;		// popup menus
Dwt.Z_VEIL = 600;		// goes below dialogs to make them modal
Dwt.Z_DIALOG = 700;		// dialogs
Dwt.Z_DIALOG_MENU = 750;// menus in dialogs
Dwt.Z_TOOLTIP = 775;	// tool tips
Dwt.Z_DND = 800;		// Drag N Drop icons
Dwt.Z_BUSY = 900;		// used to block user input
Dwt.Z_SPLASH = 1000;    // used for splash screens

Dwt.Z_INC = 1;			// atomic amount to bump z-index if needed

Dwt.DEFAULT = -123456789;

Dwt.LOC_NOWHERE = -10000; // for positioning an element offscreen

// Drag N Drop action constants
Dwt.DND_DROP_NONE = 0;
Dwt.DND_DROP_COPY = 1;
Dwt.DND_DROP_MOVE = 2;

// Keys used for retrieving data
Dwt.KEY_OBJECT = "_object_";
Dwt.KEY_ID = "_id_";

Dwt._nextId = 1;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// XXX: DEPRACATED
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
Dwt.getDomObj =
function(doc, id)  {
	//return doc.getElementById(id);
	alert("DEPRACATED: Please use document.getElementById instead");
}

Dwt.getNextId =
function() {
	return "DWT" + Dwt._nextId++;
}

Dwt.associateElementWithObject =
function(domElement, jsObject) {
	domElement.dwtObj = jsObject.__internalId = AjxCore.assignId(jsObject);
};

Dwt.disassociateElementFromObject =
function(domElement, jsObject) {
	if (domElement){
		delete domElement.dwtObj;
	}
	if (jsObject.__internalId){
		AjxCore.unassignId(jsObject.__internalId);
	}
};

Dwt.getObjectFromElement =
function(domElement) {
	return AjxCore.objectWithId(domElement.dwtObj);
};

Dwt.setHandler =
function(htmlElement, event, func) {
	if (event == DwtEvent.ONMOUSEWHEEL && AjxEnv.isGeckoBased) {
		Dwt.clearHandler(htmlElement, event);
	}
	htmlElement[event] = func;
	if (event == DwtEvent.ONMOUSEWHEEL && AjxEnv.isGeckoBased) {
		htmlElement.addEventListener("DOMMouseScroll", func, true);
	}
};

Dwt.clearHandler =
function(htmlElement, event) {
	if (event == DwtEvent.ONMOUSEWHEEL && AjxEnv.isGeckoBased) {
		if (htmlElement[event]) {
			var func = htmlElement[event];
			htmlElement.removeEventListener("DOMMouseScroll", func, true);
		}
	}
	htmlElement[event] = null;
};

Dwt.getBackgroundRepeat =
function(htmlElement) {
	return DwtCssStyle.getProperty(htmlElement, "background-repeat");
};

Dwt.setBackgroundRepeat =
function(htmlElement, style) {
	htmlElement.style.backgroundRepeat = style;
};

Dwt.getBounds =
function(htmlElement, incScroll) {
	var loc = Dwt.getLocation(htmlElement);
	var size = Dwt.getSize(htmlElement, incScroll);
	return new DwtRectangle(loc.x, loc.y, size.x, size.y);
};

Dwt.setBounds =
function(htmlElement, x, y, width, height) {
	Dwt.setLocation(htmlElement, x, y);
	Dwt.setSize(htmlElement, width, height);
};

Dwt.getCursor = 
function(htmlElement) {
	return DwtCssStyle.getProperty(htmlElement, "cursor");
};

Dwt.setCursor =
function(htmlElement, cursorName) {
	htmlElement.style.cursor = cursorName;
};


Dwt.getLocation =
function(htmlElement) {
	if (htmlElement.style.position == Dwt.ABSOLUTE_STYLE)
		return new DwtPoint(parseInt(DwtCssStyle.getProperty(htmlElement, "left")),
		                    parseInt(DwtCssStyle.getProperty(htmlElement, "top")));
	else
		return Dwt.toWindow(htmlElement, 0, 0);
};

Dwt.setLocation =
function(htmlElement, x, y) {
	if (htmlElement.style.position != Dwt.ABSOLUTE_STYLE) {
		DBG.println(AjxDebug.DBG1, "Cannot position static widget " + htmlElement.className);
		throw new DwtException("Static widgets may not be positioned", DwtException.INVALID_OP, "Dwt.setLocation");
	}
	if (x = Dwt.checkPxVal(x))
		htmlElement.style.left = x;
	if (y = Dwt.checkPxVal(y))
		htmlElement.style.top = y;
};

Dwt.checkPxVal =
function(val, check) {
	if (val == Dwt.DEFAULT) return false;
	
	if (check && val < 0 && val != Dwt.LOC_NOWHERE) {
		DBG.println(AjxDebug.DBG1, "negative pixel value: " + val);
		val = 0;
	}
	if (typeof(val) == "number")
		val = val + "px";

	return val;
};

Dwt.getPosition =
function(htmlElement) {
	return htmlElement.style.position;
};

Dwt.setPosition =
function(htmlElement, posStyle) {
	htmlElement.style.position = posStyle;
};

Dwt.getScrollStyle =
function(htmlElement) {
	var overflow =  DwtCssStyle.getProperty(htmlElement, "overflow");
	if (overflow == "hidden")
		return Dwt.CLIP;
	else if (overflow =="auto")
		return Dwt.SCROLL;
	else if (overflow =="scroll")
		return Dwt.FIXED_SCROLL;
	else
		return Dwt.VISIBLE;
};

Dwt.setScrollStyle =
function(htmlElement, scrollStyle) {
	if (scrollStyle == Dwt.CLIP)
		htmlElement.style.overflow = "hidden";
	else if (scrollStyle == Dwt.SCROLL)
		htmlElement.style.overflow = "auto";
	else if (scrollStyle == Dwt.FIXED_SCROLL)
		htmlElement.style.overflow = "scroll";
	else
		htmlElement.style.overflow = "visible";
};

// Note: in FireFox, offsetHeight includes border and clientHeight does not;
// may want to look at clientHeight for FF
Dwt.getSize = 
function(htmlElement, incScroll) {
	var p = new DwtPoint(0, 0);
	if (htmlElement.offsetWidth != null) {
		p.x = htmlElement.offsetWidth;
		p.y = htmlElement.offsetHeight;
	} else if (htmlElement.clip && htmlElement.clip.width != null) {
		p.x = htmlElement.clip.width;
		p.y = htmlElement.clip.height;
	} else if (htmlElement.style && htmlElement.style.pixelWidth != null) {
		p.x = htmlElement.style.pixelWidth;
		p.y = htmlElement.style.pixelHeight;
	}
	p.x = parseInt(p.x);
	p.y = parseInt(p.y);
	return p;
};

Dwt.setSize = 
function(htmlElement, width, height) {
	if (width = Dwt.checkPxVal(width, true))
		htmlElement.style.width = width;
	if (height = Dwt.checkPxVal(height, true))
		htmlElement.style.height = height;
};

/**
* Measure the extent in pixels of a section of html
*/
Dwt.getHtmlExtent =
function(html) {
	if (!Dwt._measureDiv) {
		var measureDiv = document.createElement("div");
		measureDiv.id = this._measureDivId = Dwt.getNextId();
		Dwt.setPosition(measureDiv, Dwt.ABSOLUTE_STYLE);
		Dwt.setLocation(measureDiv, Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
		document.body.appendChild(measureDiv);
		Dwt._measureDiv = measureDiv;
	}
	Dwt._measureDiv.innerHTML = html;
	return Dwt.getSize(Dwt._measureDiv);
};

Dwt.getAttr = 
function(htmlEl, attr, recursive) {
	// test for tagName so we dont try to eval non-html elements (i.e. document)
	if (!recursive) {
		return htmlEl && htmlEl.tagName
			? (htmlEl.getAttribute(attr) || htmlEl[attr])
			: null;
	} else {
		while (htmlEl) {
			if (Dwt.getAttr(htmlEl, attr) != null) {
				return htmlEl;
			}
			htmlEl = htmlEl.parentNode;
		}
		return null;
	}
};

Dwt.getVisible =
function(htmlElement) {
	var disp = DwtCssStyle.getProperty(htmlElement, "display");
	return (disp != Dwt.DISPLAY_NONE);
};

Dwt.setVisible =
function(htmlElement, visible) {
	htmlElement.style.display = visible ? Dwt.DISPLAY_BLOCK : Dwt.DISPLAY_NONE;
};

Dwt.getVisibility =
function(htmlElement) {
	var vis = DwtCssStyle.getProperty(htmlElement, "visibility");
	return (vis == "visible");
};

Dwt.setVisibility =
function(htmlElement, visible) {
	htmlElement.style.visibility = visible ? "visible" : "hidden";
};

Dwt.setOpacity =
function(htmlElement, opacity) {
	if (AjxEnv.isIE) htmlElement.style.filter = "alpha(opacity="+opacity+")";
	else htmlElement.style.opacity = opacity/100;
};

Dwt.getZIndex =
function(htmlElement) {
	return DwtCssStyle.getProperty(htmlElement, "z-index");
};

Dwt.setZIndex =
function(htmlElement, idx) {
//DBG.println(AjxDebug.DBG3, "set zindex for " + htmlElement.className + ": " + idx);
	htmlElement.style.zIndex = idx;
};

Dwt.getDisplay = 
function(htmlElement) {
	DwtCssStyle.getProperty(htmlElement, "display");
};

Dwt.setDisplay = 
function(htmlElement, value) {
	htmlElement.style.display = value;
};

/**
* Returns the window size of the browser
*/
Dwt.getWindowSize =
function() {
	var p = new DwtPoint(0, 0);
	if (window.innerWidth) {
		p.x = window.innerWidth;
		p.y = window.innerHeight;
	} else if (AjxEnv.isIE6CSS) {
		p.x = document.body.parentElement.clientWidth;
		p.y = document.body.parentElement.clientHeight;
	} else if (document.body && document.body.clientWidth) {
		p.x = document.body.clientWidth;
		p.y = document.body.clientHeight;
	}
	return p;
}

Dwt.toWindow =
function(htmlElement, x, y, containerElement, dontIncScrollTop) {
	var p = new DwtPoint(x, y);
	// EMC 6/3/2005
	// changed the below line, since it meant we did not 
	// include the given element in our location calculation.
	//var offsetParent = htmlElement.offsetParent;
	var offsetParent = htmlElement;
	while (offsetParent && offsetParent != containerElement) {
		p.x += offsetParent.offsetLeft;
		p.y += offsetParent.offsetTop;
		if (!dontIncScrollTop) {
			if (offsetParent.scrollTop) {
				p.y -= offsetParent.scrollTop;
			}
			var parentNode = offsetParent.parentNode;
			while (parentNode != offsetParent.offsetParent && parentNode != containerElement) {
				if (parentNode.scrollTop) {
					p.y -= parentNode.scrollTop;
				}
				parentNode = parentNode.parentNode;
			}
		}
		offsetParent = offsetParent.offsetParent;
	}
	return p;
};

Dwt.setStatus =
function(text) {
	window.status = text;
};

Dwt.getTitle = 
function() {
	return window.document.title;
};

Dwt.setTitle = 
function(text) {
	window.document.title = text;
};

Dwt.getIframeDoc = 
function(iframeObj) {
	if (iframeObj) {
		return AjxEnv.isIE 
			? iframeObj.contentWindow.document
			: iframeObj.contentDocument;
	}
	return null;
};

Dwt.getIframeWindow = 
function(iframeObj) {
	return iframeObj.contentWindow;
};

Dwt._ffOverflowHack = 
function (htmlElId, myZindex, lowThresholdZ, turnOffOverflowScroll, disableSelf) {
	if (!AjxEnv.isNav)
		return;
		
	var ds = disableSelf? disableSelf: false;
	var lowThresholdZIndex = lowThresholdZ? lowThresholdZ: -100;
	var coll = document.getElementsByTagName("div");
	var temp = null;
	var len = coll.length;
	var lastGoodZIndex = -1;
	for (var i = 0; i < len; ++i) {
		temp = coll[i];
		if (temp.id == htmlElId) {
			temp = coll[++i];
			while(i < len && temp.style.zIndex == '') {
				// enable myself if someone else turned me off
				if (temp._oldOverflow && turnOffOverflowScroll){
					temp.style.overflow = temp._oldOverflow;
					delete temp._oldOverflow;
				} else if (ds){
					temp._oldOverflow = temp.style.overflow;
					temp.style.overflow = "hidden";
				}
				temp = coll[++i];
			}
			if (i == len)
				break;
		}
		var divZIndex = parseInt(temp.style.zIndex);
		// assume that if the value is auto, that we want to shut off the 
		// overflow setting.
		if (isNaN(divZIndex)) {
			divZIndex = lastGoodZIndex;
		} else {
			lastGoodZIndex = divZIndex;
		}
		if ( divZIndex < myZindex && divZIndex >= lowThresholdZIndex) {
			switch (turnOffOverflowScroll) {
			case true:
				if (!temp._oldOverflow) {
					var cssDecl = window.getComputedStyle(temp,"");
					var overflow = cssDecl.getPropertyValue("overflow");
					// FF 1.5 returns "0px" for the computed overflow value
					if (AjxEnv.isFirefox1_5up && overflow == "0px") {
						var overflowX = cssDecl.getPropertyValue("overflow-x");
						overflow = overflowX == "hidden" 
								? "-moz-scrollbars-vertical"
								: "-moz-scrollbars-horizontal"; 
					}
					if (overflow != 'hidden') {
						temp._oldOverflow = overflow;
						temp._oldScrollTop = temp.scrollTop;
						temp.style.overflow = "visible";
					}
				}
				break;
			case false:
				if (temp._oldOverflow) {
					temp.style.overflow = temp._oldOverflow;
					delete temp._oldOverflow;
				}
				if (temp._oldScrollTop != null) {
					temp.scrollTop = temp._oldScrollTop;
				}
				break;
			}
		}
	}
};

/**
* Creates and returns an element from a string of HTML.
*
* @param html	[string]	HTML text
* @param isRow	[boolean]*	true if the element is a TR
*/
Dwt.parseHtmlFragment = 
function(html, isRow) {
	if (!Dwt._div)
		Dwt._div = document.createElement('div');
	// TR element needs to have surrounding table
	if (isRow)
		html = "<table style='table-layout:fixed'>" + html + "</table>";
	Dwt._div.innerHTML = html;
	
	return isRow ? Dwt._div.firstChild.rows[0] : Dwt._div.firstChild;
};

Dwt.contains = 
function(parentEl, childEl) {
  	var isContained = false;
  	if (AjxEnv.isSafari) {
  		return false;
  	} else if (parentEl.compareDocumentPosition) {
		var relPos = parentEl.compareDocumentPosition(childEl);
		if ((relPos == (document.DOCUMENT_POSITION_CONTAINED_BY | document.DOCUMENT_POSITION_FOLLOWING))) {
			isContained = true;
		}

  	} else if (parentEl.contains) {
  		isContained = parentEl.contains(childEl);
  	}
  	return isContained;
};

Dwt.removeChildren =
function(htmlEl) {
	while (htmlEl.hasChildNodes())
		htmlEl.removeChild(htmlEl.firstChild);
};

/**
* Safari always returns zero for cellIndex property of TD element :(
*
* @param cell		TD object we want cell index for
*/
Dwt.getCellIndex = 
function(cell) {
	if (AjxEnv.isSafari) {
		if (cell.tagName && cell.tagName.toLowerCase() == "td") {
			// get the cells collection from the TD's parent TR
			var cells = cell.parentNode.cells;
			for (var i = 0; i < cells.length; i++) {
				if (cells[i] == cell)
					return i;
			}
		}
	} else {
		return cell.cellIndex;
	}
	return -1;
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtException(msg, code, method, detail) {
	if (arguments.length == 0) return;
	AjxException.call(this, msg, code, method, detail);
}

DwtException.prototype = new AjxException;
DwtException.prototype.constructor = DwtException;

DwtException.prototype.toString = 
function() {
	return "DwtException";
}

DwtException.INVALIDPARENT = -1;
DwtException.INVALID_OP = -2;
DwtException.INTERNAL_ERROR = -3;
DwtException.INVALID_PARAM = -4;/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* @class
* This static class enables entities (e.g. DwtDialogs) to be dragged around within an app window. 
* The code is basically the same as in dom-drag.js from www.youngpup.net
*
* @author Ross Dargahi
*/

function DwtDraggable() {
}

DwtDraggable._dragEl = null;

/**
* @param dragEl	Element being dragged, can also be a handle e.g. the title bar in a dialog
* @param rootEl The actual element that will be moved. This will be a
* parent element of <i>dragEl</i> (optional) 
* @param minX	Minimum x coord to which we can drag (optional)
* @param maxX	Maximum x coord to which we can drag (optional)
* @param minY	Minimum y coord to which we can drag (optional)
* @param maxY	Maximum x coord to which we can drag (optional)
* @param dragStartCB AjxCallback that is called when dragging is started
* @param dragCB AjxCallback that is called when dragging
* @param dragEndCB AjxCallback that is called when dragging is ended
* @param swapHorizRef If true, then mouse motion to the right will move element left (optional)
* @param swapVertRef If true, then mouse motion to the bottom will move element up (optional)
* @param fXMapper function that overides this classes x coordinate transformations (optional)
* @param fYMapper function that overides this classes y coordinate transformations (optional)
*/
DwtDraggable.init = 
function(dragEl, rootEl, minX, maxX, minY, maxY, dragStartCB, dragCB, dragEndCB, 
		 swapHorizRef, swapVertRef, fXMapper, fYMapper) {
	dragEl.onmousedown = DwtDraggable._start;

	dragEl._hMode = swapHorizRef ? false : true;
	dragEl._vMode = swapVertRef ? false : true;

	dragEl._root = (rootEl && rootEl != null) ? rootEl : dragEl ;

	if (dragEl._hMode && isNaN(parseInt(dragEl._root.style.left))) 
		dragEl._root.style.left = "0px";
	if (dragEl._vMode && isNaN(parseInt(dragEl._root.style.top))) 
		dragEl._root.style.top = "0px";
		
	if (!dragEl._hMode && isNaN(parseInt(dragEl._root.style.right))) 
		dragEl._root.style.right = "0px";
	if (!dragEl._vMode && isNaN(parseInt(dragEl._root.style.bottom))) 
		dragEl._root.style.bottom = "0px";

	dragEl._minX = (typeof minX != 'undefined') ? minX : null;
	dragEl._minY = (typeof minY != 'undefined') ? minY : null;
	dragEl._maxX = (typeof maxX != 'undefined') ? maxX : null;
	dragEl._maxY = (typeof maxY != 'undefined') ? maxY : null;

	dragEl._xMapper = fXMapper ? fXMapper : null;
	dragEl._yMapper = fYMapper ? fYMapper : null;

	dragEl._root.onDragStart = dragStartCB
	dragEl._root.onDragEnd = dragEndCB
	dragEl._root.onDrag = dragCB;
}


DwtDraggable.setDragBoundaries =
function (dragEl ,minX, maxX, minY, maxY) {
	if (dragEl != null) {
		if (minX != null) dragEl._minX = minX;
		if (maxX != null) dragEl._maxX = maxX;
		if (minY != null) dragEl._minY = minY;
		if (maxY != null) dragEl._maxY = maxY;
	}
};

DwtDraggable._start =
function(e)	{
	var dragEl = DwtDraggable._dragEl = this;
	e = DwtDraggable._fixE(e);
	var x = parseInt(dragEl._hMode ? dragEl._root.style.left : dragEl._root.style.right );
	var y = parseInt(dragEl._vMode ? dragEl._root.style.top  : dragEl._root.style.bottom);
	if (dragEl._root.onDragStart)
		dragEl._root.onDragStart.run([x, y]);

	dragEl._lastMouseX = e.clientX;
	dragEl._lastMouseY = e.clientY;

	if (dragEl._hMode) {
		if (dragEl._minX != null)	
			dragEl._minMouseX = e.clientX - x + dragEl._minX;
		if (dragEl._maxX != null)
			dragEl._maxMouseX = dragEl._minMouseX + dragEl._maxX - dragEl._minX;
	} else {
		if (dragEl._minX != null)
			dragEl._maxMouseX = -dragEl._minX + e.clientX + x;
		if (dragEl._maxX != null)
			dragEl._minMouseX = -dragEl._maxX + e.clientX + x;
	}

	if (dragEl._vMode) {
		if (dragEl._minY != null)
			dragEl._minMouseY = e.clientY - y + dragEl._minY;
		if (dragEl._maxY != null)
			dragEl._maxMouseY = dragEl._minMouseY + dragEl._maxY - dragEl._minY;
	} else {
		if (dragEl._minY != null)
			dragEl._maxMouseY = -dragEl._minY + e.clientY + y;
		if (dragEl._maxY != null)
			dragEl._minMouseY = -dragEl._maxY + e.clientY + y;
	}

	document.onmousemove = DwtDraggable._drag;
	document.onmouseup = DwtDraggable._end;

	return false;
}


DwtDraggable._drag =
function(e)	{
	e = DwtDraggable._fixE(e);
	var dragEl = DwtDraggable._dragEl;

	var ey	= e.clientY;
	var ex	= e.clientX;
	var x = parseInt(dragEl._hMode ? dragEl._root.style.left : dragEl._root.style.right );
	var y = parseInt(dragEl._vMode ? dragEl._root.style.top  : dragEl._root.style.bottom);
	var nx, ny;

	if (!dragEl._xMapper) {
		if (dragEl._minX != null)
			ex = dragEl._hMode ? Math.max(ex, dragEl._minMouseX) : Math.min(ex, dragEl._maxMouseX);
		if (dragEl._maxX != null)
			ex = dragEl._hMode ? Math.min(ex, dragEl._maxMouseX) : Math.max(ex, dragEl._minMouseX);
		nx = x + ((ex - dragEl._lastMouseX) * (dragEl._hMode ? 1 : -1));
	} else {
		nx = dragEl._xMapper(x, ex);
	}

	if (!dragEl._yMapper) {
		if (dragEl._minY != null)
			ey = dragEl._vMode ? Math.max(ey, dragEl._minMouseY) : Math.min(ey, dragEl._maxMouseY);
		if (dragEl._maxY != null)
			ey = dragEl._vMode ? Math.min(ey, dragEl._maxMouseY) : Math.max(ey, dragEl._minMouseY);
		ny = y + ((ey - dragEl._lastMouseY) * (dragEl._vMode ? 1 : -1));
	} else {
		ny = dragEl._yMapper(y, ey);
	}

	DwtDraggable._dragEl._root.style[dragEl._hMode ? "left" : "right"] = nx + "px";
	DwtDraggable._dragEl._root.style[dragEl._vMode ? "top" : "bottom"] = ny + "px";
	DwtDraggable._dragEl._lastMouseX = ex;
	DwtDraggable._dragEl._lastMouseY = ey;

	if (DwtDraggable._dragEl._root.onDrag)
		DwtDraggable._dragEl._root.onDrag.run([nx, ny]);
		
	return false;
}

DwtDraggable._end =
function() {
	document.onmousemove = null;
	document.onmouseup   = null;
	if (DwtDraggable._dragEl._root.onDragEnd)
		DwtDraggable._dragEl._root.onDragEnd.run([parseInt(DwtDraggable._dragEl._root.style[DwtDraggable._dragEl._hMode ? "left" : "right"]), 
											 	 parseInt(DwtDraggable._dragEl._root.style[DwtDraggable._dragEl._vMode ? "top" : "bottom"])]);
	DwtDraggable._dragEl = null;
}

DwtDraggable._fixE =
function(e) {
	if (typeof e == 'undefined')
		e = window.event;
	if (typeof e.layerX == 'undefined')
		e.layerX = e.offsetX;
	if (typeof e.layerY == 'undefined')
		e.layerY = e.offsetY;
	return e;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtCssStyle() {
}

DwtCssStyle.SELECTED	= "selected";	// selected item (left-click) in a list or tree
DwtCssStyle.ACTIONED	= "actioned";	// actioned item (right-click) in a list or tree
DwtCssStyle.MATCHED		= "matched";	// matched item in a list
DwtCssStyle.DND			= "dnd";		// DnD icon version of a list item
DwtCssStyle.ACTIVE		= "active";		// a button that is the default for some action
DwtCssStyle.ACTIVATED	= "activated";	// a button that has the focus
DwtCssStyle.TRIGGERED	= "triggered";	// a button that has been pressed
DwtCssStyle.TOGGLED		= "toggled";	// a button that has been toggled on
DwtCssStyle.INACTIVE	= "inactive";	// a button that is inactive (closed tab button)
DwtCssStyle.DISABLED	= "disabled";	// a disabled item

DwtCssStyle.getProperty = 
function(htmlElement, cssPropName) {
	var result;
	if (htmlElement.ownerDocument == null) {
		// IE5.5 does not suppoert ownerDocument
		for(var parent = htmlElement.parentNode; parent.parentNode != null; parent = parent.parentNode);
		var doc = parent;
	} else {
		var doc = htmlElement.ownerDocument;
	}
	if (doc.defaultView && !AjxEnv.isSafari) {
		var cssDecl = doc.defaultView.getComputedStyle(htmlElement, "");
		result = cssDecl.getPropertyValue(cssPropName);
	} else {
		  // Convert CSS -> DOM name for IE etc
			var tokens = cssPropName.split("-");
			var propName = "";
			var i;
			for (i = 0; i < tokens.length; i++) {
				if (i != 0) 
					propName += tokens[i].substring(0, 1).toUpperCase();
				else 
					propName += tokens[i].substring(0, 1);
				propName += tokens[i].substring(1);
			}
			if (htmlElement.currentStyle)
				result = htmlElement.currentStyle[propName];
			else if (htmlElement.style)
				result = htmlElement.style[propName];
	}
	return result;
}

DwtCssStyle.getComputedStyleObject = 
function(htmlElement) {
	if (htmlElement.ownerDocument == null) {
		// IE5.5 does not suppoert ownerDocument
		for(var parent = htmlElement.parentNode; parent.parentNode != null; parent = parent.parentNode);
		var doc = parent;
	} else {
		var doc = htmlElement.ownerDocument;
	}
	
	if (doc.defaultView && !AjxEnv.isSafari)
		return doc.defaultView.getComputedStyle(htmlElement, "");
	else if (htmlElement.currentStyle)
		return htmlElement.currentStyle;
	else if (htmlElement.style)
		return htmlElement.style;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtPoint(x, y) {
	this.x = x;
	this.y = y;
}

DwtPoint.prototype.toString = 
function() {
	return "DwtPoint";
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtRectangle(x, y, width, height) {

	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
}

DwtRectangle.prototype.toString = 
function() {
	return "DwtRectangle";
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtUnits() {
}

DwtUnits.PIXEL_UNIT = "px";
DwtUnits.CM_UNIT = "cm";
DwtUnits.MM_UNIT = "mm";
DwtUnits.INCH_UNIT = "in";
DwtUnits.PCT_UNIT = "%";
DwtUnits.POINT = "pt";

// pixel widths
DwtUnits.WIDTH_EM = AjxEnv.isIE ? 9 : 11; // width of "m"
DwtUnits.WIDTH_SEP = AjxEnv.isIE ? 6 : 8; // width of ", "
DwtUnits.WIDTH_ELLIPSIS = 15;			 // width of " ... "
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtEvent(init) {
	if (arguments.length == 0) return;
	this.dwtObj = null;
}

DwtEvent.prototype.toString = 
function() {
	return "DwtEvent";
}

// native browser events - value is the associated DOM property
DwtEvent.ONCHANGE		= "onchange";
DwtEvent.ONCLICK		= "onclick";
DwtEvent.ONCONTEXTMENU	= "oncontextmenu";
DwtEvent.ONDBLCLICK		= "ondblclick";
DwtEvent.ONFOCUS		= "onfocus";
DwtEvent.ONBLUR 		= "onblur";
DwtEvent.ONKEYDOWN		= "onkeydown";
DwtEvent.ONKEYPRESS		= "onkeypress";
DwtEvent.ONKEYUP		= "onkeyup";
DwtEvent.ONMOUSEDOWN	= "onmousedown";
DwtEvent.ONMOUSEENTER	= "onmouseenter"; // IE only
DwtEvent.ONMOUSELEAVE	= "onmouseleave"; // IE only
DwtEvent.ONMOUSEMOVE	= "onmousemove";
DwtEvent.ONMOUSEOUT		= "onmouseout";
DwtEvent.ONMOUSEOVER	= "onmouseover";
DwtEvent.ONMOUSEUP		= "onmouseup";
DwtEvent.ONMOUSEWHEEL	= "onmousewheel";
DwtEvent.ONSELECTSTART	= "onselectstart";

// semantic events
DwtEvent.ACTION			= "ACTION";			// right-click
DwtEvent.BUTTON_PRESSED = "BUTTON_PRESSED";
DwtEvent.CONTROL		= "CONTROL";		// resize
DwtEvent.DATE_RANGE		= "DATE_RANGE";
DwtEvent.DISPOSE		= "DISPOSE";		// removal
DwtEvent.ENTER			= "ENTER";			// enter/return key
DwtEvent.HOVEROVER		= "HOVEROVER";		// mouseover for X ms
DwtEvent.HOVEROUT		= "HOVEROUT";
DwtEvent.POPDOWN		= "POPDOWN";
DwtEvent.POPUP			= "POPUP";
DwtEvent.SELECTION		= "SELECTION";		// left-click
DwtEvent.TREE			= "TREE";
DwtEvent.STATE_CHANGE	= "STATE_CHANGE";
DwtEvent.TAB			= "TAB";

// XForms
DwtEvent.XFORMS_READY				= "xforms-ready";
DwtEvent.XFORMS_DISPLAY_UPDATED		= "xforms-display-updated";
DwtEvent.XFORMS_VALUE_CHANGED		= "xforms-value-changed";
DwtEvent.XFORMS_FORM_DIRTY_CHANGE	= "xforms-form-dirty-change";
DwtEvent.XFORMS_CHOICES_CHANGED		= "xforms-choices-changed";
DwtEvent.XFORMS_VALUE_ERROR			= "xforms-value-error";

// Convenience lists
DwtEvent.KEY_EVENTS = [DwtEvent.ONKEYDOWN, DwtEvent.ONKEYPRESS, DwtEvent.ONKEYUP];

DwtEvent.MOUSE_EVENTS = [DwtEvent.ONCONTEXTMENU, DwtEvent.ONDBLCLICK, DwtEvent.ONMOUSEDOWN,
						 DwtEvent.ONMOUSEMOVE, DwtEvent.ONMOUSEUP, DwtEvent.ONSELECTSTART,
						 DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT];
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
 * static class that wraps around AjxEventManager
 */
function DwtEventManager () {
    
}

DwtEventManager._instance = new AjxEventMgr();

DwtEventManager._domEventToDwtMap = {
	'ondblclick': DwtEvent.ONDBLCLICK,
	'onmousedown': DwtEvent.ONMOUSEDOWN ,
	'onmouseup': DwtEvent.ONMOUSEUP,
	'onmousemove': DwtEvent.ONMOUSEMOVE,
	'onmouseout': DwtEvent.ONMOUSEOUT,
	'onmouseover': DwtEvent.ONMOUSEOVER,
	'onselectstart': DwtEvent.ONSELECTSTART,
	'onchange': DwtEvent.ONCHANGE
};

DwtEventManager.addListener = 
function(eventType, listener) {
	DwtEventManager._instance.addListener(eventType, listener);
};

DwtEventManager.notifyListeners = 
function(eventType, event) {
	DwtEventManager._instance.notifyListeners(eventType, event);
};

DwtEventManager.removeListener = 
function(eventType, listener) {
	DwtEventManager._instance.removeListener(eventType, listener);
};

// This tries to listen on a given element as well as to any event
// received by other Dwt widgets
DwtEventManager.addGlobalListener = 
function (element, eventType, listener) {
	AjxCore.addListener(element, eventType, listener);
	var dwtEventName = DwtEventManager._domEventToDwtMap[eventType];
	if (dwtEventName) {
		DwtEventManager.addListener(dwtEventName, listener);
	}
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtDateRangeEvent(init) {
	if (arguments.length == 0) return;
	DwtEvent.call(this, true);
	this.reset();
}

DwtDateRangeEvent.prototype = new DwtEvent;
DwtDateRangeEvent.prototype.constructor = DwtDateRangeEvent;

DwtDateRangeEvent.prototype.toString = 
function() {
	return "DwtDateRangeEvent";
}

DwtDateRangeEvent.prototype.reset =
function() {
	this.start = null;
	this.end = null;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtDisposeEvent(init) {
	if (arguments.length == 0) return;
	DwtEvent.call(this, true);
}

DwtDisposeEvent.prototype = new DwtEvent;
DwtDisposeEvent.prototype.constructor = DwtDisposeEvent;

DwtDisposeEvent.prototype.toString = 
function() {
	return "DwtDisposeEvent";
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtUiEvent(init) {
	if (arguments.length == 0) return;
	DwtEvent.call(this, true);
	this.reset();
}

DwtUiEvent.prototype = new DwtEvent;
DwtUiEvent.prototype.constructor = DwtUiEvent;

DwtUiEvent.prototype.toString = 
function() {
	return "DwtUiEvent";
}

DwtUiEvent.prototype.reset =
function() {
	this.dwtObj = null
	this.altKey = false;
	this.ctrlKey = false;
	this.shiftKey = false;
	this.target = null;
	this.type = null;
	this.docX = -1;
	this.docY = -1;
	this.elementX = -1;
	this.elementY = -1;
	this._stopPropagation = false;
	this._returnValue = true;
}

DwtUiEvent.getEvent =
function(ev) {
	return (ev) ? ev : ((window.event) ? window.event : null);
}

DwtUiEvent.getTarget =
function(ev)  {
	ev = DwtUiEvent.getEvent(ev);
	if (ev && ev.target) {
		// if text node (like on Safari) return parent
		return ev.target.nodeType == 3 ? ev.target.parentNode : ev.target;
	} else if (ev && ev.srcElement) {
		return ev.srcElement;
	} else {
		return null;
	}
}

/**
* Returns the first element with a non-null value for the given property, working its way up the element chain.
*
* @param ev		a UI event
* @param prop	the name of a property
* @returns		an element
*/
DwtUiEvent.getTargetWithProp =
function(ev, prop)  {
	var htmlEl = DwtUiEvent.getTarget(ev);
	while (htmlEl) {
		if (Dwt.getAttr(htmlEl, prop) != null) {
			return htmlEl;
		}
		htmlEl = htmlEl.parentNode;
	}
	return null;
}

/**
* Returns the first element with a non-null value for the given properties, working its way up the element chain.
*
* @param ev		a UI event
* @param props	a list of property names
* @returns		an element
*/
DwtUiEvent.getTargetWithProps =
function(ev, props)  {
	var htmlEl = DwtUiEvent.getTarget(ev);
	while (htmlEl) {
		var okay = true;
		for (var i in props) {
			if (htmlEl[props[i]] == null) {
				htmlEl = htmlEl.parentNode;
				okay = false;
				break;
			}
		}
		if (okay)
			return htmlEl;
	}
	return null;
}

DwtUiEvent.getDwtObjFromEvent =
function(ev) {
	var htmlEl = DwtUiEvent.getTargetWithProp(ev, "dwtObj");
	return htmlEl ? Dwt.getObjectFromElement(htmlEl) : null;
}

DwtUiEvent.getDwtObjWithProp =
function(ev, prop) {
	var htmlEl = DwtUiEvent.getTargetWithProps(ev, ["dwtObj", prop]);
	return htmlEl ? Dwt.getObjectFromElement(htmlEl) : null;
}

DwtUiEvent.copy = 
function(dest, src) {
	dest.altKey = src.altKey;
	dest.ctrlKey = src.ctrlKey;
	dest.shiftKey = src.shiftKey;
	dest.target = src.target;
	dest.type = src.type;
	dest.dwtObj = src.dwtObj;
	dest.docX = src.docX;
	dest.docY = src.docY;
	dest.elementX = src.elementX;
	dest.elementY = src.elementY;
	dest._stopPropagation = src._stopPropagation;
	dest._returnValue = src._returnValue;
}

DwtUiEvent.prototype.setFromDhtmlEvent =
function(ev) {
	ev = DwtUiEvent.getEvent(ev);
	if (!ev) return;
	this.altKey = ev.altKey;
	this.ctrlKey = ev.ctrlKey;
	this.shiftKey = ev.shiftKey;
	this.type = ev.type;
	this.target = DwtUiEvent.getTarget(ev);
	var target = this.target;
	while (target != null) {
		if (target.dwtObj != null) {
			this.dwtObj = Dwt.getObjectFromElement(target);
			break;
		}
		target = target.parentNode;
	}

	// Compute document coordinates
	if (ev.pageX != null) {
		this.docX = ev.pageX;
		this.docY = ev.pageY;
	} else if (ev.clientX != null) {
		this.docX = ev.clientX + document.body.scrollLeft - document.body.clientLeft;
		this.docY = ev.clientY + document.body.scrollTop - document.body.clientTop;
		if (document.body.parentElement) {
				var bodParent = document.body.parentElement;
				this.docX += bodParent.scrollLeft - bodParent.clientLeft;
				this.docY += bodParent.scrollTop - bodParent.clientTop;
		}
	}
	// Compute Element coordinates
	if (ev.offsetX != null) {
		this.elementX = ev.offsetX;
		this.elementY = ev.offsetY;
	} else if (ev.layerX != null) {
		this.elementX = ev.layerX;
		this.elementY = ev.layerY;
	} else { // fail hard for others
		this.elementX = Dwt.DEFAULT;
		this.elementY = Dwt.DEFAULT;
	}
	return ev;
}

DwtUiEvent.prototype.setToDhtmlEvent =
function(ev) {
	DwtUiEvent.setBehaviour(ev, this._stopPropagation, this._returnValue);	
}

DwtUiEvent.setBehaviour =
function(ev, stopPropagation, allowDefault) {
	ev = DwtUiEvent.getEvent(ev);
	
	// stopPropagation is referring to the function found in Mozilla's event object
	if (ev.stopPropagation != null) {
		if (stopPropagation)
			ev.stopPropagation();
		if (!allowDefault)
			ev.preventDefault();
	} else {
		// IE only..
		ev.returnValue = allowDefault; 
		ev.cancelBubble = stopPropagation;
	}
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtControlEvent() {
	this.reset();
}
DwtControlEvent.prototype = new DwtEvent;
DwtControlEvent.prototype.constructor = DwtControlEvent;

DwtControlEvent.prototype.toString = 
function() {
	return "DwtControlEvent";
}

DwtControlEvent.prototype.reset = 
function() {
	this.oldX = Dwt.DEFAULT;
	this.oldY = Dwt.DEFAULT;
	this.oldWidth = Dwt.DEFAULT;
	this.oldHeight = Dwt.DEFAULT;
	this.newX = Dwt.DEFAULT;
	this.newY = Dwt.DEFAULT;
	this.newWidth = Dwt.DEFAULT;
	this.newHeight = Dwt.DEFAULT;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtKeyEvent() {
	DwtUiEvent.call(this, true);
	this.reset(true);
}


DwtKeyEvent.KEY_END_OF_TEXT =  0x03;
DwtKeyEvent.KEY_TAB = 0x09;
DwtKeyEvent.KEY_RETURN = 0x0D;
DwtKeyEvent.KEY_ENTER = 0x0D;
DwtKeyEvent.KEY_ESCAPE = 0x1B;

DwtKeyEvent.prototype = new DwtUiEvent;
DwtKeyEvent.prototype.constructor = DwtKeyEvent;

DwtKeyEvent.prototype.toString = 
function() {
	return "DwtKeyEvent";
}

DwtKeyEvent.isKeyEvent =
function(ev) {
	return (ev.type.search(/^key/i) != -1);
}

DwtKeyEvent.isKeyPressEvent =
function(ev) {
	return (AjxEnv.isIE && ev.type == "keydown") || (ev.type == "keypress");
}

DwtKeyEvent.prototype.reset =
function(dontCallParent) {
	if (!dontCallParent)
		DwtUiEvent.prototype.reset.call(this);
	this.keyCode = 0;
	this.charCode = 0;
}


DwtKeyEvent.prototype.setFromDhtmlEvent =
function(ev) {
	ev = DwtUiEvent.prototype.setFromDhtmlEvent.call(this, ev);
	this.charCode = (ev.charCode) ? ev.charCode : ev.keyCode;
	this.keyCode = ev.keyCode;
}

DwtKeyEvent.getCharCode =
function(ev) {
	ev = DwtUiEvent.getEvent(ev);
	return AjxEnv.isSafari ? ev.keyCode : (ev.charCode || ev.keyCode);
}

DwtKeyEvent.copy = 
function(dest, src) {
	DwtUiEvent.copy(dest, src);
	dest.charCode = src.charCode;
	dest.keyCode = src.keyCode;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtMouseEvent() {
	DwtUiEvent.call(this, true);
	this.reset(true);
}

DwtMouseEvent.prototype = new DwtUiEvent;
DwtMouseEvent.prototype.constructor = DwtMouseEvent;

DwtMouseEvent.prototype.toString = 
function() {
	return "DwtMouseEvent";
}

DwtMouseEvent.NONE = 0;
DwtMouseEvent.LEFT = 1;
DwtMouseEvent.MIDDLE = 2;
DwtMouseEvent.RIGHT = 3;

DwtMouseEvent.prototype.reset =
function(dontCallParent) {
	if (!dontCallParent)
		DwtUiEvent.prototype.reset.call(this);
	this.button = 0;
	this._populated = false;
}

DwtMouseEvent.prototype.setFromDhtmlEvent =
function(ev) {
	ev = DwtUiEvent.prototype.setFromDhtmlEvent.call(this, ev);
	if (ev.offsetX != null) { // IE
		if ((ev.button & 1) != 0)
			this.button = DwtMouseEvent.LEFT;
		else if ((ev.button & 2) != 0)
			this.button = DwtMouseEvent.RIGHT;
		else if ((ev.button & 4) != 0)
			this.button = DwtMouseEvent.MIDDLE;
		else
			this.button = DwtMouseEvent.NONE;
	} else if (ev.layerX != null) { // Mozilla
		if (ev.which == 1)
			this.button = DwtMouseEvent.LEFT;
		else if (ev.which == 2)
			this.button = DwtMouseEvent.MIDDLE;
		else if (ev.which == 3)
			this.button = DwtMouseEvent.RIGHT;
		else
			this.button = DwtMouseEvent.NONE;
	}
	if (AjxEnv.isMac) {
		// if ctrlKey and LEFT mouse, turn into RIGHT mouse with no ctrl key
		if (this.ctrlKey && this.button == DwtMouseEvent.LEFT) {
			this.button = DwtMouseEvent.RIGHT;
			this.ctrlKey = false;
		}
		// allow alt-key to be used for ctrl-select
		if (this.altKey) {
			this.ctrlKey = true;
			this.altKey = false;
		}
	}
}/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/

/**
* Helper class for event capturing
*
* @constructor
* @class DwtMouseEventCapture
*
* @author Ross Dargahi
*
* @param targetObj [DOM Element:required]	Target element
* @param id [string:optional]				ID for this capture instance.
* @param mouseOverHdlr [function:optional]	Browser event handler
* @param mouseDownHdlr [function:optional]	Browser event handler
* @param mouseMoveHdlr [function:optional]	Browser event handler
* @param mouseUpHdlr [function:optional]	Browser event handler
* @param mouseOutHdlr [function:optional]	Browser event handler
* @param hardCapture [boolean:optional]		If true, then event propagation is halted at this element
*/
function DwtMouseEventCapture(targetObj, id, mouseOverHdlr, mouseDownHdlr, mouseMoveHdlr, mouseUpHdlr,
                              mouseOutHdlr, hardCapture) {
	this.targetObj = targetObj;
	this._id = id
	this._mouseOverHdlr = (mouseOverHdlr != null) ? mouseOverHdlr : DwtMouseEventCapture.emptyHdlr;
	this._mouseDownHdlr = (mouseDownHdlr != null) ? mouseDownHdlr : DwtMouseEventCapture.emptyHdlr;
	this._mouseMoveHdlr = (mouseMoveHdlr != null) ? mouseMoveHdlr : DwtMouseEventCapture.emptyHdlr;
	this._mouseUpHdlr = (mouseUpHdlr != null) ? mouseUpHdlr : DwtMouseEventCapture.emptyHdlr;
	this._mouseOutHdlr = (mouseOutHdlr != null) ? mouseOutHdlr : DwtMouseEventCapture.emptyHdlr;
	this._hardCapture = (hardCapture == null || hardCapture == true) ? true : false;
}

DwtMouseEventCapture._capturing = false;

DwtMouseEventCapture.getCaptureObj =
function() {
	return window._mouseEventCaptureObj;
}

DwtMouseEventCapture.getTargetObj =
function() {
	if (window._mouseEventCaptureObj != null)
		return window._mouseEventCaptureObj.targetObj;
	return null;
}

DwtMouseEventCapture.getId =
function() {
	if (window._mouseEventCaptureObj != null)
		return window._mouseEventCaptureObj._id;
	return null;
}

DwtMouseEventCapture.prototype.toString = 
function() {
	return "DwtMouseEventCapture";
}

DwtMouseEventCapture.prototype.capturing =
function() {
	return DwtMouseEventCapture._capturing;
}

DwtMouseEventCapture.prototype.capture =
function() {
	if (window._mouseEventCaptureObj)
		throw new DwtException("Mouse events already being captured", DwtException.INTERNAL_ERROR, "DwtMouseEventCapture.prototype.capture");
	if (document.body != null && document.body.addEventListener != null) {
		document.body.addEventListener("mouseover", this._mouseOverHdlr, true);
		document.body.addEventListener("mousedown", this._mouseDownHdlr, true);
		document.body.addEventListener("mousemove", this._mouseMoveHdlr, true);
		document.body.addEventListener("mouseup", this._mouseUpHdlr, true);
		document.body.addEventListener("mouseout", this._mouseOutHdlr, true);
	} else {
		this._savedMouseOverHdlr = document.onmouseover;
		this._savedMouseDownHdlr = document.onmousedown;
		this._savedMouseMoveHdlr = document.onmousemove;
		this._savedMouseUpHdlr = document.onmouseup;
		this._savedMouseOutHdlr = document.onmouseout;
		document.onmouseover = this._mouseOverHdlr;
		document.onmousedown = this._mouseDownHdlr;
		document.onmousemove = this._mouseMoveHdlr;
		document.onmouseup = this._mouseUpHdlr;
		document.onmouseout = this._mouseOutHdlr;
	}
	if (this._hardCapture && document.body && document.body.setCapture) {
		document.body.setCapture();
	}
	window._mouseEventCaptureObj = this;
	DwtMouseEventCapture._capturing = true;
}


DwtMouseEventCapture.prototype.release = 
function() {
	if (window._mouseEventCaptureObj == null)
		return;
	//DWT.debug.info("REMOVING LISTENERS");	
	var obj = window._shellCaptureObj;
	if (document.body && document.body.addEventListener) {
		document.body.removeEventListener("mouseover", this._mouseOverHdlr, true);
		document.body.removeEventListener("mousedown", this._mouseDownHdlr, true);
		document.body.removeEventListener("mousemove", this._mouseMoveHdlr, true);
		document.body.removeEventListener("mouseup", this._mouseUpHdlr, true);
		document.body.removeEventListener("mouseout", this._mouseOutHdlr, true);
	} else {
		document.onmouseover = this._savedMouseOverHdlr
		document.onmousedown = this._savedMouseDownHdlr;
		document.onmousemove = this._savedMouseMoveHdlr;
		document.onmouseup = this._savedMouseUpHdlr;
		document.onmouseout = this._savedMouseOutHdlr;
	}
	if (this._hardCapture && document.body && document.body.releaseCapture)
		document.body.releaseCapture();	
	window._mouseEventCaptureObj = null;
	DwtMouseEventCapture._capturing = false;
}

DwtMouseEventCapture.emptyHdlr =
function(ev) {
	var capObj = DwtMouseEventCapture.getCaptureObj();
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);	
	if (capObj._hardCapture) {
		mouseEv._stopPropagation = true;
		mouseEv._returnValue = false;
		mouseEv.setToDhtmlEvent(ev);
		return false;	
	} else {
		mouseEv._stopPropagation = false;
		mouseEv._returnValue = true;
		mouseEv.setToDhtmlEvent(ev);
		return true;
	}	
}


/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtListViewActionEvent() {
	DwtMouseEvent.call(this);
	this.reset(true);
}

DwtListViewActionEvent.prototype = new DwtMouseEvent;
DwtListViewActionEvent.prototype.constructor = DwtListViewActionEvent;

DwtListViewActionEvent.prototype.toString = 
function() {
	return "DwtListViewActionEvent";
}

DwtListViewActionEvent.prototype.reset =
function(dontCallParent) {
	if (!dontCallParent)
		DwtMouseEvent.prototype.reset.call(this);
	this.field = null;
	this.item = null;
	this.detail = null;
}/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtSelectionEvent(init) {
	if (arguments.length == 0) return;
	DwtUiEvent.call(this, true);
	this.reset(true);
}

DwtSelectionEvent.prototype = new DwtUiEvent;
DwtSelectionEvent.prototype.constructor = DwtSelectionEvent;

DwtSelectionEvent.prototype.toString = 
function() {
	return "DwtSelectionEvent";
}

DwtSelectionEvent.prototype.reset =
function(dontCallParent) {
	if (!dontCallParent)
		DwtUiEvent.prototype.reset.call(this);
	this.button = 0;
	this.detail = null;
	this.item = null;
}

/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtHtmlEditorStateEvent(init) {
	if (arguments.length == 0) return;
	DwtEvent.call(this, true);
	this.reset();
}

DwtHtmlEditorStateEvent.prototype = new DwtEvent;
DwtHtmlEditorStateEvent.prototype.constructor = DwtHtmlEditorStateEvent;

DwtHtmlEditorStateEvent.prototype.toString = 
function() {
	return "DwtHtmlEditorStateEvent";
}

DwtHtmlEditorStateEvent.prototype.reset =
function() {
	this.isBold = null;
	this.isItalic = null;
	this.isUnderline = null;
	this.isStrikeThru = null;
	this.isSuperscript = null;
	this.isSubscript = null;
	this.isOrderedList = null;
	this.isNumberedList = null;
	this.fontName = null;
	this.fontSize = null;
	this.style = null;
	this.backgroundColor = null;
	this.color = null;
	this.justification = null;
	this.direction = null;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtTreeEvent() {
	DwtSelectionEvent.call(this, true);
}

DwtTreeEvent.prototype = new DwtSelectionEvent;
DwtTreeEvent.prototype.constructor = DwtTreeEvent;

DwtTreeEvent.prototype.toString = 
function() {
	return "DwtTreeEvent";
}

DwtTreeEvent.prototype.setFromDhtmlEvent =
function(ev, win) {
	ev = DwtSelectionEvent.prototype.setFromDhtmlEvent.call(this, ev);
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


//
// DwtHoverEvent
//

function DwtHoverEvent(type, delay, object, x, y) {
	if (arguments.length == 0) return;
	DwtEvent.call(this, true);
	this.type = type;
	this.delay = delay;
	this.object = object;
	this.x = AjxUtil.isUndefined(x) ? -1 : x;
	this.y = AjxUtil.isUndefined(y) ? -1 : y;
}

DwtHoverEvent.prototype = new DwtEvent;
DwtHoverEvent.prototype.constructor = DwtHoverEvent;

DwtHoverEvent.prototype.reset =
function() {
	this.type = 0;
	this.delay = 0;
	this.object = null;
	this.x = -1;
	this.y = -1;
}/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtDragEvent() {
	this.operation = null;
	this.srcControl = null;
	this.action = null;
	this.doIt = false;
	this.srcData = null;
}

DwtDragEvent.DRAG_START = 1;
DwtDragEvent.SET_DATA = 2;
DwtDragEvent.DRAG_END = 3;
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtDragSource(supportedOps) {
	this._supportedOps = supportedOps
	this._evtMgr = new AjxEventMgr();
}

DwtDragSource._DRAG_LISTENER = "DwtDragSource._DRAG_LISTENER";

DwtDragSource._dragEvent = new DwtDragEvent();

DwtDragSource.prototype.toString = 
function() {
	return "DwtDragSource";
}

DwtDragSource.prototype.addDragListener =
function(dragSourceListener) {
	this._evtMgr.addListener(DwtDragSource._DRAG_LISTENER, dragSourceListener);
}

DwtDragSource.prototype.removeDragListener =
function(dragSourceListener) {
	this._evtMgr.removeListener(DwtDragSource._DRAG_LISTENER, dragSourceListener);
}


/* 
* The following  methods are called by DwtControl during the Drag lifecycle 
*/


DwtDragSource.prototype._beginDrag =
function(operation, srcControl) {
	if (!(this._supportedOps & operation))
		return Dwt.DND_DROP_NONE;
		
	DwtDragSource._dragEvent.operation = operation;
	DwtDragSource._dragEvent.srcControl = srcControl;
	DwtDragSource._dragEvent.action = DwtDragEvent.DRAG_START;
	DwtDragSource._dragEvent.srcData = null;
	DwtDragSource._dragEvent.doit = true;
	this._evtMgr.notifyListeners(DwtDragSource._DRAG_LISTENER, DwtDragSource._dragEvent);
	return DwtDragSource._dragEvent.operation;
}

DwtDragSource.prototype._getData =
function() {
	DwtDragSource._dragEvent.action = DwtDragEvent.SET_DATA;
	this._evtMgr.notifyListeners(DwtDragSource._DRAG_LISTENER, DwtDragSource._dragEvent);
	return DwtDragSource._dragEvent.srcData;
}

DwtDragSource.prototype._endDrag =
function() {
	DwtDragSource._dragEvent.action = DwtDragEvent.DRAG_END;
	DwtDragSource._dragEvent.doit = false;
	this._evtMgr.notifyListeners(DwtDragSource._DRAG_LISTENER, DwtDragSource._dragEvent);
	return DwtDragSource._dragEvent.doit;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtDropEvent() {
	this.operation = null;
	this.targetControl = null;
	this.action = null;
	this.srcData = null;
	this.doIt = false;
}

DwtDropEvent.DRAG_ENTER = 1;
DwtDropEvent.DRAG_LEAVE = 2;
DwtDropEvent.DRAG_OP_CHANGED = 3;
DwtDropEvent.DRAG_DROP = 4;/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtDropTarget(transferType) {
	this._transferTypes = new Array();
	this._hasMultiple = false;
	if (transferType) {
		for (var i = 0; i < arguments.length; i++)
			this._transferTypes[i] = arguments[i];
			
		this._transferTypes.length = i;
	}
	this._evtMgr = new AjxEventMgr();
}

DwtDropTarget._DROP_LISTENER = "DwtDropTarget._DROP_LISTENER";

DwtDropTarget._dropEvent = new DwtDropEvent();

DwtDropTarget.prototype.toString = 
function() {
	return "DwtDropTarget";
}

DwtDropTarget.prototype.addDropListener =
function(dropTargetListener) {
	this._evtMgr.addListener(DwtDropTarget._DROP_LISTENER, dropTargetListener);
}

DwtDropTarget.prototype.removeDropListener =
function(dropTargetListener) {
	this._evtMgr.removeListener(DwtDropTarget._DROP_LISTENER, dropTargetListener);
}

/* Check to see if transferType is a valid target. Note that transferType can be an array of items
 * or just an single item */
DwtDropTarget.prototype.isValidTarget =
function(items) {
	if (items instanceof Array) {
		for (var i = 0; i < items.length; i++) {
			if (!this._checkTarget(items[i]))
				return false;
		}
		return true;
	} else {
		return this._checkTarget(items);
	}
}

/* Indicates that the underlying component has multiple sub-components */
DwtDropTarget.prototype.markAsMultiple = 
function() {
	this._hasMultiple = true;
};

DwtDropTarget.prototype.hasMultipleTargets = 
function () {
	return this._hasMultiple;
};

DwtDropTarget.prototype._checkTarget =
function(item) {
	for (var i = 0; i < this._transferTypes.length; i++) {
		if (item instanceof this._transferTypes[i])
			return true;
	}	
	if (i == this._transferTypes.length)
		return false;
}

DwtDropTarget.prototype.getTransferTypes =
function() {
	return this._transferTypes;
}

/* variable length parameter */
DwtDropTarget.prototype.setTransferTypes =
function(transferType) {
	for (var i = 0; i < arguments.length; i++)
		this._transferTypes[i] = arguments[i];
	this._transferTypes.length = i;
}

/* 
* The following methods are called by DwtControl during the Drag lifecycle 
*/
DwtDropTarget.prototype._dragEnter =
function(operation, targetControl, srcData, ev) {
	DwtDropTarget._dropEvent.operation = operation;
	DwtDropTarget._dropEvent.targetControl = targetControl;
	DwtDropTarget._dropEvent.action = DwtDropEvent.DRAG_ENTER;
	DwtDropTarget._dropEvent.srcData = srcData;
	DwtDropTarget._dropEvent.uiEvent = ev;
	DwtDropTarget._dropEvent.doIt = true;
	this._evtMgr.notifyListeners(DwtDropTarget._DROP_LISTENER, DwtDropTarget._dropEvent);
	return DwtDropTarget._dropEvent.doIt;
}

DwtDropTarget.prototype._dragLeave =
function() {
	DwtDropTarget._dropEvent.action = DwtDropEvent.DRAG_LEAVE;
	this._evtMgr.notifyListeners(DwtDropTarget._DROP_LISTENER, DwtDropTarget._dropEvent);
}

DwtDropTarget.prototype._dragOpChanged =
function(newOperation) {
	DwtDropTarget._dropEvent.operation = newOperation;
	DwtDropTarget._dropEvent.action = DwtDropEvent.DRAG_OP_CHANGED;
	this._evtMgr.notifyListeners(DwtDropTarget._DROP_LISTENER, DwtDropTarget._dropEvent);
	return DwtDropTarget._dropEvent.doIt;
}

DwtDropTarget.prototype._drop =
function(srcData, ev) {
	DwtDropTarget._dropEvent.action = DwtDropEvent.DRAG_DROP;
	DwtDropTarget._dropEvent.srcData = srcData;
	DwtDropTarget._dropEvent.uiEvent = ev;
	this._evtMgr.notifyListeners(DwtDropTarget._DROP_LISTENER, DwtDropTarget._dropEvent);
	return DwtDropTarget._dropEvent.doIt;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


//
// DwtHoverMgr
//

function DwtHoverMgr() {
	this._hoverOverAction = new AjxTimedAction(this, this._notifyHoverOver);
	this._hoverOutAction = new AjxTimedAction(this, this._notifyHoverOut);
}

// Data

DwtHoverMgr.prototype._hoverObject;

DwtHoverMgr.prototype._hoverOverDelay = 750;
DwtHoverMgr.prototype._hoverOverData;
DwtHoverMgr.prototype._hoverOverAction;
DwtHoverMgr.prototype._hoverOverActionId = -1;
DwtHoverMgr.prototype._hoverOverListener;

DwtHoverMgr.prototype._hoverOutDelay = 50;
DwtHoverMgr.prototype._hoverOutData;
DwtHoverMgr.prototype._hoverOutAction;
DwtHoverMgr.prototype._hoverOutActionId = -1;
DwtHoverMgr.prototype._hoverOutListener;

DwtHoverMgr.prototype._isHovering = false;

// Public methods

DwtHoverMgr.prototype.setHoverObject = function(object) {
	this._hoverObject = object;
};
DwtHoverMgr.prototype.getHoverObject = function() {
	return this._hoverObject;
};

DwtHoverMgr.prototype.reset = function() {
	this._hoverObject = null;
	this._hoverOverDelay = DwtHoverMgr.prototype._hoverOverDelay;
	this._hoverOverData = null;
	if (this._hoverOverActionId != -1) {
		AjxTimedAction.cancelAction(this._hoverOverActionId);
	}
	this._hoverOverActionId = -1;
	this._hoverOverListener = null;

	this._hoverOutDelay = DwtHoverMgr.prototype._hoverOutDelay;
	this._hoverOutData = null;
	if (this._hoverOutActionId != -1) {
		AjxTimedAction.cancelAction(this._hoverOutActionId);
		this._notifyHoverOut();
	}
	this._hoverOutActionId = -1;
	this._hoverOutListener = null;
};

DwtHoverMgr.prototype.isHovering = function() {
	return this._isHovering;
};

DwtHoverMgr.prototype.setHoverOverDelay = function(delay) {
	this._hoverOverDelay = delay;
};
DwtHoverMgr.prototype.setHoverOverData= function(data) {
	this._hoverOverData = data;
};
DwtHoverMgr.prototype.setHoverOverListener = function(listener) {
	this._hoverOverListener = listener;
};

DwtHoverMgr.prototype.setHoverOutDelay = function(delay) {
	this._hoverOutDelay = delay;
};
DwtHoverMgr.prototype.setHoverOutData = function(data) {
	this._hoverOutData = data;
};
DwtHoverMgr.prototype.setHoverOutListener = function(listener) {
	this._hoverOutListener = listener;
};

DwtHoverMgr.prototype.hoverOver = function(x, y) {
	if (this._hoverOverActionId != -1) {
		AjxTimedAction.cancelAction(this._hoverOverActionId);
	}
	this._hoverOverAction.args = [x, y];
	this._hoverOverActionId = AjxTimedAction.scheduleAction(this._hoverOverAction, this._hoverOverDelay);
};
DwtHoverMgr.prototype.hoverOut = function() {
	if (this._hoverOverActionId != -1) {
		AjxTimedAction.cancelAction(this._hoverOverActionId);
	}
	if (this._hoverOutActionId == -1) {
		if (this._hoverOutDelay > 0) {
			this._hoverOutActionId = AjxTimedAction.scheduleAction(this._hoverOutAction, this._hoverOutDelay);
		}
		else {
			this._notifyHoverOut();
		}
	}
};

// Protected methods

DwtHoverMgr.prototype._notifyHoverOver = function() {
	this._hoverOverActionId = -1;
	this._isHovering = true;
	if (this._hoverOverListener != null) {
		var x = this._hoverOverAction.args[0];
		var y = this._hoverOverAction.args[1];
		var event = new DwtHoverEvent(DwtEvent.HOVEROVER, this._hoverOverDelay, this._hoverOverData, x, y);
		this._hoverOverListener.handleEvent(event);
	}
};
DwtHoverMgr.prototype._notifyHoverOut = function() {
	this._hoverOutActionId = -1;
	this._isHovering = false;
	if (this._hoverOutListener != null) {
		var event = new DwtHoverEvent(DwtEvent.HOVEROUT, this._hoverOutDelay, this._hoverOutData);
		this._hoverOutListener.handleEvent(event);
	}
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a control. A control may be created in "deferred" mode, meaning that the UI portion of the control
* will be created "Just In Time". This is useful for widgets which may want to defer construction
* of elements (e.g. DwtTreeItem) until such time as is needed, in the interest of efficiency. Note that if 
* the control is a child of the shell, it won't become visible until its z-index is set.
* @constructor
* @class
* This class represents a control, the highest-level useable widget. A control is a displayable element with
* a set of attributes (size, location, etc) and behaviors (event handlers). A control does not have child
* elements.
*
* @author Ross Dargahi
* @param parent		the parent widget
* @param className	CSS class
* @param posStyle	positioning style (absolute, static, or relative)
* @param deferred	postpone initialization until needed
*/

function DwtControl(parent, className, posStyle, deferred) {

	if (arguments.length == 0) return;
 	this.parent = parent;
	if (parent != null && !(parent instanceof DwtComposite))
		throw new DwtException("Parent must be a subclass of Composite", DwtException.INVALIDPARENT, "DwtWidget");

	this._data = new Object();
	this._eventMgr = new AjxEventMgr();
	this._disposed = false;
    
 	if (parent == null) 
 		return;

	this._className = className ? className : "DwtControl";
	this._posStyle = posStyle;
	if (!deferred)
		this._initCtrl();
		
	this._hoverOverListener = new AjxListener(this, this._handleHoverOver);
	this._hoverOutListener = new AjxListener(this, this._handleHoverOut);
}

// static properties

DwtControl.STATIC_STYLE = Dwt.STATIC_STYLE;
DwtControl.ABSOLUTE_STYLE = Dwt.ABSOLUTE_STYLE;
DwtControl.RELATIVE_STYLE = Dwt.RELATIVE_STYLE;

DwtControl.CLIP = Dwt.CLIP;
DwtControl.VISIBLE = Dwt.VISIBLE;
DwtControl.SCROLL = Dwt.SCROLL;
DwtControl.FIXED_SCROLL = Dwt.FIXED_SCROLL;

DwtControl.DEFAULT = Dwt.DEFAULT;

DwtControl._NO_DRAG = 1;
DwtControl._DRAGGING = 2;
DwtControl._DRAG_REJECTED = 3;

DwtControl._DRAG_THRESHOLD = 3;

DwtControl.TOOLTIP_THRESHOLD = 5;

DwtControl._DND_HOVER_DELAY = 750;

// static methods

DwtControl._keyPressHdlr =
function(ev) {
	var obj = obj ? obj : DwtUiEvent.getDwtObjFromEvent(ev);
	if (!obj) return false;
	
	if (obj._toolTipContent != null) {
		var shell = DwtShell.getShell(window);
		var manager = shell.getHoverMgr();
		manager.setHoverOutListener(obj._hoverOutListener);
		manager.hoverOut();
		obj._tooltipClosed = false;
	}
}

DwtControl._dblClickHdlr = 
function(ev) {
	return DwtControl._mouseEvent(ev, DwtEvent.ONDBLCLICK);
}

DwtControl._mouseOverHdlr =
function(ev) {
	// Check to see if a drag is occurring. If so, don't process the mouse
	// over events.
	var captureObj = (DwtMouseEventCapture.getId() == "DwtControl") ? DwtMouseEventCapture.getCaptureObj() : null;
	if (captureObj != null) {
		ev = DwtUiEvent.getEvent(ev);
		ev._stopPropagation = true;
		return false;
	}
	var obj = DwtUiEvent.getDwtObjFromEvent(ev);
	if (!obj) return false;
	
	var mouseEv = DwtShell.mouseEvent;
	if (obj._dragging == DwtControl._NO_DRAG) {
		mouseEv.setFromDhtmlEvent(ev);
		if (obj.isListenerRegistered(DwtEvent.ONMOUSEOVER))
			obj.notifyListeners(DwtEvent.ONMOUSEOVER, mouseEv);
		// Call the tooltip after the listeners to give them a 
		// chance to change the tooltip text.
		if (obj._toolTipContent != null) {
			var shell = DwtShell.getShell(window);
			var manager = shell.getHoverMgr();
			if ((manager.getHoverObject() != this || !manager.isHovering()) && !DwtMenu.menuShowing()) {
				manager.reset();
				manager.setHoverObject(this);
				manager.setHoverOverData(obj);
				manager.setHoverOverDelay(DwtToolTip.TOOLTIP_DELAY);
				manager.setHoverOverListener(obj._hoverOverListener);
				manager.hoverOver(mouseEv.docX, mouseEv.docY);
			}
		}
	}
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;
};

DwtControl._mouseDownHdlr =
function(ev) {
	var obj = DwtUiEvent.getDwtObjFromEvent(ev);
	if (!obj) return false;
	
	if (obj._toolTipContent != null) {
		var shell = DwtShell.getShell(window);
		var manager = shell.getHoverMgr();
		manager.setHoverOutListener(obj._hoverOutListener);
		manager.hoverOut();
	}
	
	// If we have a dragSource, then we need to start capturing mouse events
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	if (obj._dragSource != null && mouseEv.button == DwtMouseEvent.LEFT
			&& obj._isValidDragObject(mouseEv)) 
	{
		try {
			obj._ctrlCaptureObj.capture();
		} catch (ex) {
			DBG.dumpObj(ex);
		}
		obj._dragOp = (mouseEv.ctrlKey) ? Dwt.DND_DROP_COPY : Dwt.DND_DROP_MOVE;
		obj._dragStartX = mouseEv.docX;
		obj._dragStartY = mouseEv.docY;
	}
	
	return DwtControl._mouseEvent(ev, DwtEvent.ONMOUSEDOWN, obj, mouseEv);
}

DwtControl._mouseMoveHdlr =
function(ev) {
	// If captureObj == null, then we are not a Draggable control or a 
	// mousedown event has not occurred , so do the default behaviour, 
	// else do the draggable behaviour 
	var captureObj = (DwtMouseEventCapture.getId() == "DwtControl") ? DwtMouseEventCapture.getCaptureObj() : null;
	var obj = (captureObj) ? captureObj.targetObj : DwtUiEvent.getDwtObjFromEvent(ev);
 	if (!obj) return false;

	//DND cancel point
	if (obj._dndHoverActionId != -1) {
		AjxTimedAction.cancelAction(obj._dndHoverActionId);
		obj._dndHoverActionId = -1;
	}

	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);

	// This following can happen during a DnD operation if the mouse moves
	// out the window. This seems to happen on IE only.
	if (mouseEv.docX < 0 || mouseEv.docY < 0) {
		mouseEv._stopPropagation = true;
		mouseEv._returnValue = false;
		mouseEv.setToDhtmlEvent(ev);
		return false;
	}
	
	// If we are not draggable or if we have not started dragging and are 
	// within the Drag threshold then simply handle it as a move.
	if (obj._dragSource == null || captureObj == null
		|| (obj != null && obj._dragging == DwtControl._NO_DRAG 
			&& Math.abs(obj._dragStartX - mouseEv.docX) < 
			   DwtControl._DRAG_THRESHOLD 
			&& Math.abs(obj._dragStartY - mouseEv.docY) < 
			   DwtControl._DRAG_THRESHOLD)) {
		if (obj._toolTipContent != null) {
			var shell = DwtShell.getShell(window);
			var manager = shell.getHoverMgr();
			if (!manager.isHovering() && !obj._tooltipClosed && !DwtMenu.menuShowing()) {
				// NOTE: mouseOver already init'd other hover settings
				// We do hoverOver() here since the mouse may have moved during
				// the delay, and we want to use latest x,y
				manager.hoverOver(mouseEv.docX, mouseEv.docY);
			} else {
				var deltaX = obj._lastTooltipX ? Math.abs(mouseEv.docX - obj._lastTooltipX) : null;
				var deltaY = obj._lastTooltipY ? Math.abs(mouseEv.docY - obj._lastTooltipY) : null;
				if ((deltaX != null && deltaX > DwtControl.TOOLTIP_THRESHOLD) || 
					(deltaY != null && deltaY > DwtControl.TOOLTIP_THRESHOLD)) {
					manager.setHoverOutListener(obj._hoverOutListener);
					manager.hoverOut();
					obj._tooltipClosed = true; // prevent tooltip popup during moves in this object
				}
			}
		}
		return DwtControl._mouseEvent(ev, DwtEvent.ONMOUSEMOVE, obj, mouseEv);
	} else {
		// Deal with mouse moving out of the window etc...
		
		// If we are not dragging, then see if we can drag. 
		// If we cannot drag this control, then
		// we will set dragging status to DwtControl._DRAG_REJECTED 
		if (obj._dragging == DwtControl._NO_DRAG) {
			obj._dragOp = obj._dragSource._beginDrag(obj._dragOp, obj);
			if (obj._dragOp != Dwt.DND_DROP_NONE) {
				obj._dragging = DwtControl._DRAGGING;
				obj._dndIcon = obj._getDnDIcon(obj._dragOp);
				if (obj._dndIcon == null)
					obj._dragging = DwtControl._DRAG_REJECTED;
			} else {
				obj._dragging = DwtControl._DRAG_REJECTED;
			}
		}
		
		// If we are draggable, then see if the control under the mouse 
		// (if one exists) will allow us to be dropped on it. 
		// This is done by (a) making sure that the drag source data type
		// can be dropped onto the target, and (b) that the application 
		// will allow it (i.e. via the listeners on the DropTarget
		if (obj._dragging != DwtControl._DRAG_REJECTED) {
			var destDwtObj = mouseEv.dwtObj;
			if (destDwtObj) {
				// Set up the drag hover event. we will even let this item hover over itself as there may be
				// scenarios where that will hold true
				obj._dndHoverAction.args = [ destDwtObj ];
				obj._dndHoverActionId = AjxTimedAction.scheduleAction(obj._dndHoverAction, DwtControl._DND_HOVER_DELAY);
			}

			if (destDwtObj && destDwtObj._dropTarget && destDwtObj != obj) {
				if (destDwtObj != obj._lastDestDwtObj || 
					destDwtObj._dropTarget.hasMultipleTargets()) {
					if (destDwtObj._dropTarget._dragEnter(
										obj._dragOp, 
										destDwtObj, 
										obj._dragSource._getData(), mouseEv)) {

						obj._setDnDIconState(true);
						obj._dropAllowed = true;
						destDwtObj._dragEnter(mouseEv);
					} else {
						obj._setDnDIconState(false);
						obj._dropAllowed = false;
					}
				} else if (obj._dropAllowed) {
					destDwtObj._dragOver(mouseEv);
				}
			} else {
				obj._setDnDIconState(false);
			}
			
			if (obj._lastDestDwtObj && obj._lastDestDwtObj != destDwtObj 
				&& obj._lastDestDwtObj._dropTarget 
				&& obj._lastDestDwtObj != obj) {

				obj._lastDestDwtObj._dragLeave(mouseEv);
				obj._lastDestDwtObj._dropTarget._dragLeave();
			}
			
			obj._lastDestDwtObj = destDwtObj;
					
			Dwt.setLocation(obj._dndIcon, mouseEv.docX + 2, mouseEv.docY + 2);
			// TODO set up timed event to fire off another mouseover event. 
			// Also need to cancel
			// any pending event, though we should do the cancel earlier 
			// in the code
		} else {
			// XXX: confirm w/ ROSS!
			DwtControl._mouseEvent(ev, DwtEvent.ONMOUSEMOVE, obj, mouseEv);
		}
		mouseEv._stopPropagation = true;
		mouseEv._returnValue = false;
		mouseEv.setToDhtmlEvent(ev);
		return false;
	}
}

DwtControl._mouseUpHdlr =
function(ev) {
	// See if are doing a drag n drop operation
	var captureObj = (DwtMouseEventCapture.getId() == "DwtControl") ? DwtMouseEventCapture.getCaptureObj() : null;
	var obj = (captureObj) ? captureObj.targetObj : DwtUiEvent.getDwtObjFromEvent(ev);
	if (!obj) return false;

	//DND
	if (obj._dndHoverActionId != -1) {
		AjxTimedAction.cancelAction(obj._dndHoverActionId);
		obj._dndHoverActionId = -1;
	}
	
	if (!obj._dragSource || !captureObj) {
		return DwtControl._mouseEvent(ev, DwtEvent.ONMOUSEUP, obj);
	} else {
		captureObj.release();
		var mouseEv = DwtShell.mouseEvent;
		mouseEv.setFromDhtmlEvent(ev);
		if (obj._dragging != DwtControl._DRAGGING) {
			obj._dragging = DwtControl._NO_DRAG;
			return DwtControl._mouseEvent(ev, DwtEvent.ONMOUSEUP, obj, mouseEv);
		} else {
			obj._lastDestDwtObj = null;
			var destDwtObj = mouseEv.dwtObj;
			if (destDwtObj != null && destDwtObj._dropTarget != null && 
				obj._dropAllowed && destDwtObj != obj) {
				destDwtObj._drop(mouseEv);
				destDwtObj._dropTarget._drop(obj._dragSource._getData(), mouseEv);
				obj._dragSource._endDrag();
				obj._destroyDnDIcon(obj._dndIcon);
				obj._dragging = DwtControl._NO_DRAG;
			} else {
				// The following code sets up the drop effect for when an 
				// item is dropped onto an invalid target. Basically the 
				// drag icon will spring back to its starting location.
				obj._dragEndX = mouseEv.docX;
				obj._dragEndY = mouseEv.docY;
				if (obj._badDropAction == null) {
					obj._badDropAction = new AjxTimedAction(obj, obj._badDropEffect);
				}
				
				// Line equation is y = mx + c. Solve for c, and set up d (direction)
				var m = (obj._dragEndY - obj._dragStartY) / (obj._dragEndX - obj._dragStartX);
				obj._badDropAction.args = [m, obj._dragStartY - (m * obj._dragStartX), (obj._dragStartX - obj._dragEndX < 0) ? -1 : 1];
				AjxTimedAction.scheduleAction(obj._badDropAction, 0);
			}
			mouseEv._stopPropagation = true;
			mouseEv._returnValue = false;
			mouseEv.setToDhtmlEvent(ev);
			return false;
		}
	}
}

DwtControl._mouseOutHdlr =
function(ev) {
	var obj = DwtUiEvent.getDwtObjFromEvent(ev);
	if (!obj) return false;

	if (obj._toolTipContent != null) {
		var shell = DwtShell.getShell(window);
		var manager = shell.getHoverMgr();
		manager.setHoverOutListener(obj._hoverOutListener);
		manager.hoverOut();
		obj._tooltipClosed = false;
	}
	return DwtControl._mouseEvent(ev, DwtEvent.ONMOUSEOUT, obj);
};

DwtControl._mouseWheelHdlr =
function(ev) {
	var obj = DwtUiEvent.getDwtObjFromEvent(ev);
	if (!obj) return false;
	return DwtControl._mouseEvent(ev, DwtEvent.ONMOUSEWHEEL, obj);
};

DwtControl._selectStartHdlr = 
function(ev) {
	return DwtControl._mouseEvent(ev, DwtEvent.ONSELECTSTART);
}

DwtControl._contextMenuHdlr = 
function(ev) {
	// for Safari, we have to fake a right click
	if (AjxEnv.isSafari) {
		var obj = DwtUiEvent.getDwtObjFromEvent(ev);
		var prevent = obj ? obj.preventContextMenu() : true;
		if (prevent) {
			DwtControl._mouseEvent(ev, DwtEvent.ONMOUSEDOWN);
			DwtControl._mouseEvent(ev, DwtEvent.ONMOUSEUP);
			return;
		}
	}
	return DwtControl._mouseEvent(ev, DwtEvent.ONCONTEXTMENU);
}

DwtControl._mouseEvent = 
function(ev, eventType, obj, mouseEv) {

	var obj = obj ? obj : DwtUiEvent.getDwtObjFromEvent(ev);
	if (!obj) return false;
	
	if (!mouseEv) {
		mouseEv = DwtShell.mouseEvent;
		mouseEv.setFromDhtmlEvent(ev);
	}

	// By default, we halt event processing. Listeners may override
	var tn = mouseEv.target.tagName.toLowerCase();
	if (tn != "input" && tn != "textarea") {
		// bug #6003 - Safari seems to follow propagation rules for clicks on scrollbar :(
		mouseEv._stopPropagation = obj.getPropagationForEvent();
		mouseEv._returnValue = obj.getReturnValueForEvent();
	} else {
		mouseEv._stopPropagation = false;
		mouseEv._returnValue = true;	
	}
	
	// notify global listeners
	DwtEventManager.notifyListeners(eventType, mouseEv);
	// notify widget listeners
	if (obj.isListenerRegistered && obj.isListenerRegistered(eventType))
		obj.notifyListeners(eventType, mouseEv);

	// publish our settings to the DOM
	mouseEv.setToDhtmlEvent(ev);
	return mouseEv._returnValue;
}

// need to populate this hash after methods are defined
DwtControl.HANDLER = new Object();
DwtControl.HANDLER[DwtEvent.ONCONTEXTMENU] = DwtControl._contextMenuHdlr;
DwtControl.HANDLER[DwtEvent.ONDBLCLICK] = DwtControl._dblClickHdlr;
DwtControl.HANDLER[DwtEvent.ONMOUSEDOWN] = DwtControl._mouseDownHdlr;
DwtControl.HANDLER[DwtEvent.ONMOUSEENTER] = DwtControl._mouseOverHdlr;
DwtControl.HANDLER[DwtEvent.ONMOUSELEAVE] = DwtControl._mouseOutHdlr;
DwtControl.HANDLER[DwtEvent.ONMOUSEMOVE] = DwtControl._mouseMoveHdlr;
DwtControl.HANDLER[DwtEvent.ONMOUSEOUT] = DwtControl._mouseOutHdlr;
DwtControl.HANDLER[DwtEvent.ONMOUSEOVER] = DwtControl._mouseOverHdlr;
DwtControl.HANDLER[DwtEvent.ONMOUSEUP] = DwtControl._mouseUpHdlr;
DwtControl.HANDLER[DwtEvent.ONMOUSEWHEEL] = DwtControl._mouseWheelHdlr;
DwtControl.HANDLER[DwtEvent.ONSELECTSTART] = DwtControl._selectStartHdlr;
DwtControl.HANDLER[DwtEvent.ONKEYPRESS] = DwtControl._keyPressHdlr;

// instance methods

DwtControl.prototype.toString = 
function() {
	return "DwtControl";
}

DwtControl.prototype.addControlListener = 
function(listener) {
	this.addListener(DwtEvent.CONTROL, listener);
}

DwtControl.prototype.removeControlListener = 
function(listener) { 
	this.removeListener(DwtEvent.CONTROL, listener);
}

DwtControl.prototype.addDisposeListener = 
function(listener) {
	this.addListener(DwtEvent.DISPOSE, listener);
}

DwtControl.prototype.removeDisposeListener = 
function(listener) { 
	this.removeListener(DwtEvent.DISPOSE, listener);
}

DwtControl.prototype.addListener =
function(eventType, listener) {
	return this._eventMgr.addListener(eventType, listener); 	
}

DwtControl.prototype.notifyListeners =
function(eventType, event) {
	return this._eventMgr.notifyListeners(eventType, event);
}

DwtControl.prototype.isListenerRegistered =
function(eventType) {
	return this._eventMgr.isListenerRegistered(eventType);
}

DwtControl.prototype.removeListener = 
function(eventType, listener) {
	return this._eventMgr.removeListener(eventType, listener);
}

DwtControl.prototype.removeAllListeners = 
function(eventType) {
	return this._eventMgr.removeAll(eventType);
}

DwtControl.prototype.dispose =
function() {
	if (this._disposed) return;

	if (this.parent != null)
		this.parent.removeChild(this);

	Dwt.disassociateElementFromObject(null, this);

	this._disposed = true;
	var ev = new DwtDisposeEvent();
	ev.dwtObj = this;
	this.notifyListeners(DwtEvent.DISPOSE, ev);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// XXX: DEPRACATED
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
DwtControl.prototype.getDocument =
function() {
	//return document;
	alert("DEPRACATED: Please use document instead");
}

DwtControl.prototype.getData = 
function(key) {
	return this._data[key];
}

DwtControl.prototype.setData = 
function(key, value) {
  this._data[key] = value;
}

DwtControl.prototype.isDisposed =
function() {
	return this._isDisposed;
}

DwtControl.prototype.isInitialized =
function() {
	return this._ctrlInited;
}

DwtControl.prototype.getPropagationForEvent = 
function() {
	// overload me for dealing w/ browsers w/ weird quirks
	return true;
}

DwtControl.prototype.getReturnValueForEvent = 
function() {
	// overload me for dealing w/ browsers w/ weird quirks
	return false;
}

DwtControl.prototype.reparent =
function(newParent) {
	if (!this._checkState()) return;

	var htmlEl = this.getHtmlElement();
	this.parent.removeChild(this);
	DwtComposite._pendingElements[this._htmlElId] = htmlEl;
	newParent.addChild(this);
	this.parent = newParent;
	// TODO do we need a reparent event?
}

/**
* Reparents the HTML element of the control to the html element supplied as the
* parameter to this method. 
*
* @param htmlEl Either a string representing an ID, or an html element
*/
DwtControl.prototype.reparentHtmlElement =
function(htmlEl) {

	/* If htmlEl is a string, then it is an ID so lookup the html element that has
	 * the corresponding ID */
	if (typeof htmlEl == "string")
		htmlEl = document.getElementById(htmlEl);

	htmlEl.appendChild(this.getHtmlElement());
}

DwtControl.prototype.setHandler =
function(event, func) {
	if (!this._checkState()) return;

	var htmlElement = this.getHtmlElement();
	Dwt.setHandler(htmlElement, event, func);
};

DwtControl.prototype.clearHandler =
function(event) {
	if (!this._checkState()) return;
		
	var htmlElement = this.getHtmlElement();
	Dwt.clearHandler(htmlElement, event);
};

DwtControl.prototype.getBounds =
function(incScroll) {
	if (!this._checkState()) return;
		
	return Dwt.getBounds(this.getHtmlElement(), incScroll);
}

DwtControl.prototype.setBounds =
function(x, y, width, height) {
	if (!this._checkState()) return;
		
	var htmlElement = this.getHtmlElement();
	if (this.isListenerRegistered(DwtEvent.CONTROL)) {
		this._controlEvent.reset();
		var bds = Dwt.getBounds(htmlElement);
		this._controlEvent.oldX = bds.x;
		this._controlEvent.oldY = bds.y;
		this._controlEvent.oldWidth = bds.width;
		this._controlEvent.oldHeight = bds.height;
		Dwt.setBounds(htmlElement, x, y, width, height);
		bds = Dwt.getBounds(htmlElement);
		this._controlEvent.newX = bds.x;
		this._controlEvent.newY = bds.y;
		this._controlEvent.newWidth = bds.width;
		this._controlEvent.newHeight = bds.height;
		this.notifyListeners(DwtEvent.CONTROL, this._controlEvent);
	} else {
		Dwt.setBounds(htmlElement, x, y, width, height);
	}
	
	return this;
}

DwtControl.prototype.getClassName =
function() {
	return this._className;
}

DwtControl.prototype.setClassName =
function(className) {
	if (!this._checkState()) return;
		
	this._className = className;
	this.getHtmlElement().className = className;
}

DwtControl.prototype.getCursor = 
function() {
	if (!this._checkState()) return;
		
	return Dwt.getCursor(this.getHtmlElement());
}

DwtControl.prototype.setCursor =
function(cursorName) {
	if (!this._checkState()) return;
		
	Dwt.setCursor(this.getHtmlElement(), cursorName);
}

DwtControl.prototype.getDragSource =
function() {
	return this._dragSource;
}

DwtControl.prototype.setDragSource =
function(dragSource) {
	this._dragSource = dragSource;
	if (dragSource != null && this._ctrlCaptureObj == null) {
		this._ctrlCaptureObj = new DwtMouseEventCapture(this, "DwtControl", DwtControl._mouseOverHdlr,
				DwtControl._mouseDownHdlr, DwtControl._mouseMoveHdlr, 
				DwtControl._mouseUpHdlr, DwtControl._mouseOutHdlr);
		this._dndHoverAction = new AjxTimedAction(null, this._dndDoHover);
	}
}

DwtControl.prototype.getDropTarget =
function() {
	return this._dropTarget;
}

DwtControl.prototype.setDropTarget =
function(dropTarget) {
	this._dropTarget = dropTarget;
}

DwtControl.prototype.getEnabled =
function() {
	if (!this._checkState()) return;
		
	return this._enabled;
}

DwtControl.prototype.setEnabled =
function(enabled, setHtmlElement) {
	if (!this._checkState()) return;
		
	if (enabled != this._enabled) {
		this._enabled = enabled;
		if (setHtmlElement)
			this.getHtmlElement().disabled = !enabled;
	}
};

DwtControl.prototype.getHtmlElement =
function() {
	if (!this._checkState()) return;

	var htmlEl = document.getElementById(this._htmlElId);
	if (htmlEl == null) {
		htmlEl = DwtComposite._pendingElements[this._htmlElId];
	} else if (!htmlEl._rendered) {
		delete DwtComposite._pendingElements[this._htmlElId];
		htmlEl._rendered = true;
	}
	
	return htmlEl;
}

DwtControl.prototype.setHtmlElementId =
function(id) {
	if (this._disposed) return;
	
	if (this._ctrlInited) {
		var htmlEl = this.getHtmlElement();
		if (!htmlEl._rendered) {
			delete DwtComposite._pendingElements[this._htmlElId];
			DwtComposite._pendingElements[id] = htmlEl;
		}
		htmlEl.id = id;
	}
	this._htmlElId = id;
}

DwtControl.prototype.getX =
function() {
	if (!this._checkState()) return;
		
	return Dwt.getLocation(this.getHtmlElement()).x;
}

DwtControl.prototype.getXW =
function() {
	if (!this._checkState()) return;
		
    var bounds = this.getBounds();
	return bounds.x+bounds.width;
}

DwtControl.prototype.getY =
function() {
	if (!this._checkState()) return;
		
	return Dwt.getLocation(this.getHtmlElement()).y;
}

DwtControl.prototype.getYH =
function() {
	if (!this._checkState()) return;
		
    var bounds = this.getBounds();
	return bounds.y+bounds.height;
}

DwtControl.prototype.getLocation =
function() {
	if (!this._checkState()) return;
		
	return Dwt.getLocation(this.getHtmlElement());
}

DwtControl.prototype.setLocation =
function(x, y) {
	if (!this._checkState()) return;
		
	if (this.isListenerRegistered(DwtEvent.CONTROL)) {
		var htmlElement = this.getHtmlElement();
		this._controlEvent.reset();
		var loc = Dwt.getLocation(htmlElement);
		this._controlEvent.oldX = loc.x;
		this._controlEvent.oldY = loc.y;
		Dwt.setLocation(htmlElement, x, y);
		loc = Dwt.getLocation(htmlElement);
		this._controlEvent.newX = loc.x;
		this._controlEvent.newY = loc.y;
		this.notifyListeners(DwtEvent.CONTROL, this._controlEvent);
	} else {
		Dwt.setLocation(this.getHtmlElement(), x, y);
	}
	return this;
}

DwtControl.prototype.getScrollStyle =
function() {
	if (!this._checkState()) return;
		
	return Dwt.getScrollStyle(this.getHtmlElement());
}

DwtControl.prototype.setScrollStyle =
function(scrollStyle) {
	if (!this._checkState()) return;
		
	Dwt.setScrollStyle(this.getHtmlElement(), scrollStyle);
}

DwtControl.prototype.getW = 
function(incScroll) {
	if (!this._checkState()) return;
		
	return Dwt.getSize(this.getHtmlElement(), incScroll).x;
}

DwtControl.prototype.getH = 
function(incScroll) {
	if (!this._checkState()) return;
		
	return Dwt.getSize(this.getHtmlElement(), incScroll).y;
}

DwtControl.prototype.getSize = 
function(incScroll) {
	if (!this._checkState()) return;
		
	return Dwt.getSize(this.getHtmlElement(), incScroll);
}

DwtControl.prototype.setSize = 
function(width, height) {
	if (!this._checkState()) return;
		
	if (this.isListenerRegistered(DwtEvent.CONTROL)) {
		var htmlElement = this.getHtmlElement();
		this._controlEvent.reset();
		var sz = Dwt.getSize(htmlElement);
		this._controlEvent.oldWidth = sz.x;
		this._controlEvent.oldHeight = sz.y;
		Dwt.setSize(htmlElement, width, height);
		sz = Dwt.getSize(htmlElement);
		this._controlEvent.newWidth = sz.x;
		this._controlEvent.newHeight = sz.y;
		this.notifyListeners(DwtEvent.CONTROL, this._controlEvent);
	} else {
		Dwt.setSize(this.getHtmlElement(), width, height);
	}
	return this;
}

DwtControl.prototype.getToolTipContent =
function() {
	if (this._disposed) return;

	return this._toolTipContent;
}

DwtControl.prototype.setToolTipContent =
function(text) {
	if (this._disposed) return;

	this._toolTipContent = text;
}

DwtControl.prototype.getVisible =
function() {
	if (!this._checkState()) return;
		
	return Dwt.getVisible(this.getHtmlElement());
}

DwtControl.prototype.setVisible =
function(visible) {
	if (!this._checkState()) return;
		
	Dwt.setVisible(this.getHtmlElement(), visible);
}

DwtControl.prototype.setVisibility =
function(visible) {
	if (!this._checkState()) return;
		
	Dwt.setVisibility(this.getHtmlElement(), visible);
}

DwtControl.prototype.getZIndex =
function() {
	if (!this._checkState()) return;
		
	return Dwt.getZIndex(this.getHtmlElement());
}

/**
* Sets the z-index for this object's HTML element. Since z-index is only relevant among peer
* elements, we make sure that all elements that are being displayed via z-index hang off the
* main shell.
*
* @param idx	the new z-index for this element
*/
DwtControl.prototype.setZIndex =
function(idx) {
	if (!this._checkState()) return;
		
	Dwt.setZIndex(this.getHtmlElement(), idx);
}

/**
* Convenience function to toggle visibility using z-index. It uses the two lowest level
* z-indexes. Any further stacking will have to use setZIndex() directly.
*
* @param show	true if we want to show the element, false if we want to hide it
*/
DwtControl.prototype.zShow =
function(show) {
	this.setZIndex(show ? Dwt.Z_VIEW : Dwt.Z_HIDDEN);
}

DwtControl.prototype.setDisplay = 
function(value) {
	if (!this._checkState()) return;

	Dwt.setDisplay(this.getHtmlElement(), value);
}

DwtControl.prototype.preventSelection = 
function(targetEl) {
	return !this._isInputEl(targetEl);
}

DwtControl.prototype.preventContextMenu = 
function(targetEl) {
	return targetEl ? (!this._isInputEl(targetEl)) : true;
}

DwtControl.prototype._checkState =
function() {
	if (this._disposed) return false;
	if (!this._ctrlInited) 
		this._initCtrl();
	return true;
}

DwtControl.prototype._isInputEl = 
function(targetEl) {
	var bIsInput = false;
	if(!targetEl || !targetEl.tagName) {
		return bIsInput;
	}
	var tagName = targetEl.tagName.toLowerCase();
	var type = tagName == "input" ? targetEl.type.toLowerCase() : null;
	
	if (tagName == "textarea" || (type && (type == "text" || type == "password")))
		bIsInput = true;
	
	return bIsInput;
}

DwtControl.prototype._setEventHdlrs =
function(events, clear) {
	if (!this._checkState()) return;
		
	var htmlElement = this.getHtmlElement();
	for (var i = 0; i < events.length; i++) {
		if (clear !== true)
			Dwt.setHandler(htmlElement, events[i], DwtControl.HANDLER[events[i]]);
		else
			Dwt.clearHandler(htmlElement, events[i]);
	}
}

DwtControl.prototype._setMouseEventHdlrs =
function(clear) {
	this._setEventHdlrs(DwtEvent.MOUSE_EVENTS, clear);
}


DwtControl.prototype._setKeyPressEventHdlr =
function(clear) {
	this._setEventHdlrs([DwtEvent.ONKEYPRESS], clear);
}

DwtControl.prototype._dndDoHover =
function(control) {
	//TODO Add allow hover?
	control._dragHover();
}



/* Subclasses may override this method to return an HTML element that will represent
 * the dragging icon. The icon must be created on the DwtShell widget. If this method returns
 * null, it indicates that the drag failed*/
DwtControl.prototype._getDnDIcon =
function(dragOp) {
	DBG.println("DwtControl.prototype._getDnDIcon");
	return null;
}

/* Subclasses may override this method to set the DnD icon properties based on whether drops are
 * allowed */
DwtControl.prototype._setDnDIconState =
function(dropAllowed) {
	this._dndIcon.className = (dropAllowed) ? "DropAllowed" : "DropNotAllowed";
}


/* Subclasses may override this method to destroy the Dnd icon HTML element. */
DwtControl._junkIconId = 0;
DwtControl.prototype._destroyDnDIcon =
function(icon) {
	if (icon != null) {
		// not sure why there is no parent node, but if there isn't one,
		// let's try and do our best to get rid of the icon
		if (icon.parentNode) {
			icon.parentNode.removeChild(icon);
		} else {
			// at least hide the icon, and change the id so we can't get it
			// back later
			icon.style.zIndex = -100;
			icon.id = "DwtJunkIcon" + DwtControl._junkIconId++;
			icon = void 0;
		}
	}
}

/* Subclasses may override this method to provide feedback as to whether a possibly
 * valid capture is taking place. For example, there are instances such as when a mouse
 * down happens on a scroll bar in a DwtListView that are reported in the context of
 * the DwtListView, but which are not really a valid mouse down i.e. on a list item. In
 * such cases this function would return false */
 DwtControl.prototype._isValidDragObject =
 function(ev) {
 	return true;
 }

/* subclasses may override the following  functions to provide UI behaviour for DnD operations.
 * _dragEnter is called when a drag operation enters a control. _dragOver is called multiple times
 * as an item crossed over the control. _dragHover is called multiple times as the user hover's over
 * the control. _dragLeave is called when the drag operation exits the control. 
 * _drop is called when the item is dropped on the target.
 */
DwtControl.prototype._dragEnter =
function(ev) {
}

DwtControl.prototype._dragOver =
function(ev) {
}

DwtControl.prototype._dragHover =
function(ev) {
}


DwtControl.prototype._dragLeave =
function(ev) {
}

DwtControl.prototype._drop =
function(ev) {
}

DwtControl.prototype._initCtrl = 
function() {
	this.shell = this.parent.shell || this.parent;
	var htmlElement = document.createElement("div");
	this._htmlElId = htmlElement.id = (this._htmlElId == null) ? Dwt.getNextId() : this._htmlElId;
	DwtComposite._pendingElements[this._htmlElId] = htmlElement;
	Dwt.associateElementWithObject(htmlElement, this);
	if (this._posStyle == null || this._posStyle == DwtControl.STATIC_STYLE) {
        htmlElement.style.position = DwtControl.STATIC_STYLE;
	} else {
        htmlElement.style.position = this._posStyle;
	}
	htmlElement.className = this._className;
	htmlElement.style.overflow = "visible";
	this._enabled = true;
	this._controlEvent = new DwtControlEvent();
	this._dragging = DwtControl._NO_DRAG;
	this._ctrlInited = true;
	// Make sure this is the last thing we do
	this.parent.addChild(this);
}

DwtControl.prototype.setContent =
function(content) {
	if (content)
		this.getHtmlElement().innerHTML = content;
}

DwtControl.prototype.clearContent =
function() {
	this.getHtmlElement().innerHTML = "";
}

DwtControl.prototype._badDropEffect =
function(m, c, d) {
	var usingX = (Math.abs(m) <= 1);
	// Use the bigger delta to control the snap effect
	var delta = usingX ? this._dragStartX - this._dragEndX : this._dragStartY - this._dragEndY;
	if (delta * d > 0) {
		if (usingX) {
			this._dragEndX += (30 * d);
			this._dndIcon.style.top = m * this._dragEndX + c;
			this._dndIcon.style.left = this._dragEndX;
		} else {
			this._dragEndY += (30 * d);
			this._dndIcon.style.top = this._dragEndY;
			this._dndIcon.style.left = (this._dragEndY - c) / m;
		}	
		AjxTimedAction.scheduleAction(this._badDropAction, 0);
 	} else {
  		this._destroyDnDIcon(this._dndIcon);
		this._dragging = DwtControl._NO_DRAG;
  	}
}

DwtControl.prototype._handleHoverOver =
function(event) {
	if (this._eventMgr.isListenerRegistered(DwtEvent.HOVEROVER)) {
		this._eventMgr.notifyListeners(DwtEvent.HOVEROVER, event);
	}
	if (this._toolTipContent != null) {
		var shell = DwtShell.getShell(window);
		var tooltip = shell.getToolTip();
		tooltip.setContent(this._toolTipContent);
		tooltip.popup(event.x, event.y);
		this._lastTooltipX = event.x;
		this._lastTooltipY = event.y;
		this._tooltipClosed = false;
	}
}

DwtControl.prototype._handleHoverOut =
function(event) {
	if (this._eventMgr.isListenerRegistered(DwtEvent.HOVEROUT)) {
		this._eventMgr.notifyListeners(DwtEvent.HOVEROUT, event);
	}
	var shell = DwtShell.getShell(window);
	var tooltip = shell.getToolTip();
	tooltip.popdown();
	this._lastTooltipX = null;
	this._lastTooltipY = null;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtComposite(parent, className, posStyle, deferred) {

	if (arguments.length == 0) return;
	className = className || "DwtComposite";
	DwtControl.call(this, parent, className, posStyle, deferred);

	this._children = new AjxVector();
	this._updating = false;
}

DwtComposite.prototype = new DwtControl;
DwtComposite.prototype.constructor = DwtComposite;

// Pending elements hash (i.e. elements that have not yet been realized)
DwtComposite._pendingElements = new Object();

DwtComposite.prototype.toString = 
function() {
	return "DwtComposite";
}

DwtComposite.prototype.dispose =
function() {
	if (this._disposed) return;
DBG.println(AjxDebug.DBG3, "DwtComposite.prototype.dispose: " + this.toString() + " - " + this._htmlElId);
	var sz = this._children.size();
	if (sz > 0) {
		// Dup the array since disposing the children will result in removeChild
		// being called which will modify the array
		var a = this._children.getArray().slice(0);
		for (var i = 0; i < sz; i++) {
			if (a[i].dispose)
				a[i].dispose();
		}
	}		
	DwtControl.prototype.dispose.call(this);
}

DwtComposite.prototype.getChildren =
function() {
	return this._children.getArray().slice(0);
}

DwtComposite.prototype.getNumChildren =
function() {
	return this._children.size();
}

DwtComposite.prototype.removeChildren =
function() {
	var a = this._children.getArray();
	while (this._children.size() > 0)
		a[0].dispose();
}

DwtComposite.prototype.clear =
function() {
	this.removeChildren();
	this.getHtmlElement().innerHTML = "";
}

/**
* Adds the given child control to this control.
*
* @param child	[DwtControl]	the child control to add
*/
DwtComposite.prototype.addChild =
function(child) {
	this._children.add(child);
	
	// check for a previously removed element
	var htmlEl = child._removedEl ? child._removedEl : child.getHtmlElement();
	if (this instanceof DwtShell && this.isVirtual()) {
		// If we are operating in "virtual shell" mode, then children of the shell's html elements
	 	// are actually parented to the body
		document.body.appendChild(htmlEl);
	} else {
		this.getHtmlElement().appendChild(htmlEl);
	}
	if (child._removedEl)
		child._removedEl = null;
}

/**
* Removes the given child control from this control. A removed child is no longer retrievable via
* getHtmlElement(), so there is an option to save a reference to the removed child. That way it can
* be added later using addChild().
*
* @param child				[DwtControl]	the child control to remove
* @param preserveElement	[boolean]		if true, the child will save a reference to its removed element
*/
DwtComposite.prototype.removeChild =
function(child, preserveElement) {
	DBG.println(AjxDebug.DBG3, "DwtComposite.prototype.removeChild: " + child._htmlElId + " - " + child.toString());
	// Make sure that the child is initialized. Certain children (such as DwtTreeItems)
	// can be created in a deferred manner (i.e. they will only be initialized if they
	// are becoming visible.
	if (child.isInitialized()) {
		this._children.remove(child);
		// Sometimes children are nested in arbitrary HTML so we elect to remove them
		// in this fashion rather than use this.getHtmlElement().removeChild(child.getHtmlElement()
		var childHtmlEl = child.getHtmlElement();
		if (childHtmlEl && childHtmlEl.parentNode) {
			var el = childHtmlEl.parentNode.removeChild(childHtmlEl);
			if (preserveElement)
				child._removedEl = el;
		}
	}
}

DwtComposite.prototype._update = function() {}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


// Cannot be subclassed

/**
* Creates a shell. 
* @constructor
* @class
* This class represents a shell, the first widget that must be instantiated in a Dwt based 
* application. By default the shell covers the whole browser window, though it may also be 
* instantiated within an HTML element.
* <p>
* DwtShell should <b>NOT</b> be subclassed</p>
*
* @author Ross Dargahi
* @param className			[string]*		CSS class name
* @param docBodyScrollable	[boolean]*		if true, then the document body is set to be scrollable
* @param confirmExitMethod	[function]*		method which is called when the user attempts to navigate away from 
*											the application or close the browser window. If this method return a string that 
*											is displayed as part of the alert that is presented to the user. If this method 
*											returns null, then no alert is popped up this parameter may be null
* @param  userShell			[Element]*		an HTML element that will be reparented into an absolutely
*											postioned container in this shell. This is useful in the situation where you have an HTML 
*											template and want to use this in context of Dwt.
* @param useCurtain			[boolean]*		if true, a curtain overlay is created to be used between hidden and viewable elements 
*											using z-index. See Dwt.js for various layering constants
*/
function DwtShell(className, docBodyScrollable, confirmExitMethod, userShell, useCurtain) {
	if (window._dwtShell != null) {
		throw new DwtException("DwtShell already exists for window", DwtException.INVALID_OP, "DwtShell");
	}

	className = className || "DwtShell";
	DwtComposite.call(this, null, className);

    // HACK! This is a hack to make sure that the control methods work 
    // with DwtShell since the parent of DwtShell is null. 
	this._ctrlInited = true;

	window._dwtShell = AjxCore.assignId(this);

	if ((confirmExitMethod != null) && (document.domain != "localhost"))
		window.onbeforeunload = confirmExitMethod;

	document.body.style.margin = 0;
	if (docBodyScrollable != null && !docBodyScrollable)
		document.body.style.overflow = "hidden";

	Dwt.setHandler(document, DwtEvent.ONKEYPRESS, DwtShell._keyPressHdlr);

    document.body.onselect = DwtShell._preventDefaultSelectPrt;
	document.body.onselectstart = DwtShell._preventDefaultSelectPrt;
    document.body.oncontextmenu = DwtShell._preventDefaultPrt;
    window.onresize = DwtShell._resizeHdlr;

    var htmlElement = document.createElement("div");
	this._htmlElId = htmlElement.id = Dwt.getNextId();

	htmlElement.className = className;
	htmlElement.style.width = htmlElement.style.height = "100%";
	if (htmlElement.style.overflow) 
		htmlElement.style.overflow = null;

	// if there is a user shell (body content), move it below this shell
	// into a container that's absolutely positioned
	if (userShell)
		document.body.removeChild(userShell);
	document.body.appendChild(htmlElement);
	if (userShell) {
		var userShellContainer = new DwtControl(this, null, Dwt.ABSOLUTE_STYLE);
		userShellContainer.getHtmlElement().appendChild(userShell);
		userShellContainer.setSize("100%", "100%");
		userShellContainer.zShow(true);
	}
	Dwt.associateElementWithObject(htmlElement, this);
    this.shell = this;

    // Busy overlay - used when we want to enforce a modal busy state
    this._createBusyOverlay(htmlElement);

	// Veil overlay - used by DwtDialog to disable underlying app
	this._veilOverlay = document.createElement("div");
	this._veilOverlay.className = (!AjxEnv.isLinux) ? "VeilOverlay" : "VeilOverlay-linux";
	this._veilOverlay.style.position = "absolute";
	this._veilOverlay.style.cursor = AjxEnv.isIE6up ? "not-allowed" : "wait";
	Dwt.setBounds(this._veilOverlay, 0, 0, "100%", "100%");
    Dwt.setZIndex(this._veilOverlay, Dwt.Z_HIDDEN);
	this._veilOverlay.veilZ = new Array();
	this._veilOverlay.veilZ.push(Dwt.Z_HIDDEN);
	this._veilOverlay.dialogZ = new Array();
	this._veilOverlay.activeDialogs = new Array();
	this._veilOverlay.innerHTML = "<table cellspacing=0 cellpadding=0 style='width:100%; height:100%'><tr><td>&nbsp;</td></tr></table>";
	htmlElement.appendChild(this._veilOverlay);

	// Curtain overlay - used between hidden and viewable elements using z-index
	if (useCurtain) {
		this._curtainOverlay = document.createElement("div");
		this._curtainOverlay.className = "CurtainOverlay";
		this._curtainOverlay.style.position = "absolute";
		Dwt.setBounds(this._curtainOverlay, 0, 0, "100%", "100%")
		Dwt.setZIndex(this._curtainOverlay, Dwt.Z_CURTAIN);
		this._curtainOverlay.innerHTML = "<table cellspacing=0 cellpadding=0 style='width:100%; height:100%'><tr><td>&nbsp;</td></tr></table>";
		htmlElement.appendChild(this._curtainOverlay);
	}

    this._uiEvent = new DwtUiEvent(true);
	this._currWinSize = Dwt.getWindowSize();

	// tooltip singleton used by all controls in shell
	this._toolTip = new DwtToolTip(this);
	this._hoverMgr = new DwtHoverMgr();
}

DwtShell.prototype = new DwtComposite;
DwtShell.prototype.constructor = DwtShell;

// DwtDialog not defined yet, can't base ID on it
DwtShell.CANCEL_BUTTON = -1;

// Event objects used to populate events so we dont need to create them for each event
DwtShell.controlEvent 	= new DwtControlEvent();
DwtShell.keyEvent 		= new DwtKeyEvent();
DwtShell.mouseEvent 	= new DwtMouseEvent();
DwtShell.selectionEvent = new DwtSelectionEvent(true);
DwtShell.treeEvent 		= new DwtTreeEvent();


// Public methods

DwtShell.prototype.toString = 
function() {
	return "DwtShell";
}

/**
* Returns the shell managing the browser window (if any)
*
* @return DwtShell or null
*/
DwtShell.getShell =
function(win){
	return AjxCore.objectWithId(win._dwtShell);
};

/**
* Sets the busy overlay. The busy overlay disables input to the application and makes the 
* cursor a wait cursor. Optionally a work in progress (WIP) dialog may be requested. Since
* multiple calls to this method may be interleaved, it accepts a unique ID to keep them
* separate. We also maintain a count of outstanding calls to setBusy(true). When that count
* changes between 0 and 1, the busy overlay is applied or removed.
* 
* @param busy					[boolean]		if true, set the busy overlay, otherwise hide the busy overlay
* @param id						[int]*			a unique ID for this instance
* @param showbusyDialog 		[boolean]*		if true, show the WIP dialog
* @param busyDialogDelay 		[int]*			number of ms to delay before popping up the WIP dialog
* @param cancelBusyCallback		[AjxCallback]*	callback to run when OK button is pressed in WIP dialog
*/ 
DwtShell.prototype.setBusy =
function(busy, id, showbusyDialog, busyDialogDelay, cancelBusyCallback) {
	if (busy)
		this._setBusyCount++;
	else if (this._setBusyCount > 0)
		this._setBusyCount--;

    if (!this._setBusy && (this._setBusyCount > 0)) {
		// transition from non-busy to busy state
		Dwt.setCursor(this._busyOverlay, "wait");
    	Dwt.setVisible(this._busyOverlay, true);
    	this._setBusy = true;
    	DBG.println(AjxDebug.DBG2, "set busy overlay, id = " + id);
    } else if (this._setBusy && (this._setBusyCount <= 0)) {
		// transition from busy to non-busy state
	    Dwt.setCursor(this._busyOverlay, "default");
	    Dwt.setVisible(this._busyOverlay, false);
	    this._setBusy = false;
    	DBG.println(AjxDebug.DBG2, "remove busy overlay, id = " + id);
	}
	
	// handle busy dialog whether we've changed state or not
	if (busy && showbusyDialog) {
		if (busyDialogDelay && busyDialogDelay > 0) {
			this._busyActionId[id] = AjxTimedAction.scheduleAction(this._busyTimedAction, busyDialogDelay);
		} else {
			this._showBusyDialogAction(id);
		}

		if (cancelBusyCallback) {
			this._cancelBusyCallback = cancelBusyCallback;
			this._busyDialog.setButtonEnabled(DwtShell.CANCEL_BUTTON, true);
		} else {
			this._busyDialog.setButtonEnabled(DwtShell.CANCEL_BUTTON, false);
		}
	} else {
    	if (this._busyActionId[id] && (this._busyActionId[id] != -1)) {
    		AjxTimedAction.cancelAction(this._busyActionId[id]);
    		this._busyActionId[id] = -1;
    	}
   		if (this._busyDialog.isPoppedUp)
    		this._busyDialog.popdown();
    } 
}

/**
* Sets the text for the shell's busy dialog
*
* @param text The text to set (may be HTML)
*/
DwtShell.prototype.setBusyDialogText =
function(text) { 
	this._busyDialogTxt.innerHTML = (text) ? text : "";
}

/**
* Sets shell's busy dialog title. If null set's it to the default
*
* @param title The title text
*/
DwtShell.prototype.setBusyDialogTitle =
function(title) { 
	this._busyDialog.setTitle((title) ? title : AjxMsg.workInProgress);
}

DwtShell.prototype.getHoverMgr = 
function() {
	return this._hoverMgr;
}

DwtShell.prototype.getToolTip = 
function() {
	return this._toolTip;
}

DwtShell.prototype.getH = 
function(incScroll) {
	return (!this._virtual) ? Dwt.getSize(this.getHtmlElement(), incScroll).y
	                        : Dwt.getSize(document.body, incScroll).y;
}

DwtShell.prototype.getW = 
function(incScroll) {
	return (!this._virtual) ? Dwt.getSize(this.getHtmlElement(), incScroll).x
	                        : Dwt.getSize(document.body, incScroll).x;
}

DwtShell.prototype.getSize = 
function(incScroll) {
	return (!this._virtual) ? Dwt.getSize(this.getHtmlElement(), incScroll)
	                        : Dwt.getSize(document.body, incScroll);
}

DwtShell.prototype.getLocation =
function() {
	return (!this._virtual) ? Dwt.getLocation(this.getHtmlElement())
	                        : Dwt.getLocation(document.body);
}

DwtShell.prototype.getX =
function() {
	return (!this._virtual) ? Dwt.getLocation(this.getHtmlElement()).x
	                        : Dwt.getLocation(document.body).x;
}

DwtShell.prototype.getY =
function() {
	return (!this._virtual) ? Dwt.getLocation(this.getHtmlElement()).y
	                        : Dwt.getLocation(document.body).y;
}


DwtShell.prototype.getBounds = 
function() {
	return (!this._virtual) ? Dwt.getBounds(this.getHtmlElement(), incScroll)
	                        : Dwt.getBounds(document.body, incScroll);
}

/**
 * If the shell is set as a virtual shell, then all children that are 
 * directly added to the shell become childre on the body element. This
 * is useful in the cases where DWT is to be with existing HTML documents
 * rather than as the foundation for an application
 */
DwtShell.prototype.setVirtual =
function() {
	this._virtual = true;
	this.setVisible(false);
}

DwtShell.prototype.isVirtual =
function() {
	return this._virtual;
}


// Private / protected methods

DwtShell.prototype._showBusyDialogAction =
function(id) {
	this._busyDialog.popup();
	this._busyActionId[id] = -1;
}

DwtShell.prototype._createBusyOverlay =
function(htmlElement) { 
    this._busyOverlay = document.createElement("div");
    this._busyOverlay.className = (!AjxEnv.isLinux) ? "BusyOverlay" : "BusyOverlay-linux";
    this._busyOverlay.style.position = "absolute";
    Dwt.setBounds(this._busyOverlay, 0, 0, "100%", "100%")
    Dwt.setZIndex(this._busyOverlay, Dwt.Z_VEIL);
    this._busyOverlay.innerHTML = "<table cellspacing=0 cellpadding=0 style='width:100%; height:100%'><tr><td>&nbsp;</td></tr></table>";
    htmlElement.appendChild(this._busyOverlay);
	Dwt.setVisible(this._busyOverlay, false);

	var cancelButton = new DwtDialog_ButtonDescriptor(DwtShell.CANCEL_BUTTON, AjxMsg.cancelRequest, DwtDialog.ALIGN_CENTER);
    this._busyDialog = new DwtDialog(this, "DwtShellbusyDialog", AjxMsg.workInProgress, DwtDialog.NO_BUTTONS, [cancelButton], Dwt.BUSY + 10);
    this._busyDialog._disableFFhack();
    this._busyDialog.registerCallback(DwtShell.CANCEL_BUTTON, this._busyCancelButtonListener, this);
    var txtId = Dwt.getNextId();
    var html = [
        "<table xborder=1 class='DialogContent'><tr>",
            "<td class='WaitIcon'></td><td class='MsgText' id='", txtId, "'>&nbsp;</td>",
        "</tr></table>"].join("");
    
    this._busyDialog.setContent(html);
    this._busyDialogTxt = document.getElementById(txtId);
       
	this._busyTimedAction = new AjxTimedAction(this, this._showBusyDialogAction);
	this._busyActionId = {};
	
	this._setBusyCount = 0;
	this._setBusy = false;
}


// Listeners

DwtShell.prototype._busyCancelButtonListener =
function(ev) {
	this._cancelBusyCallback.run();
	this._busyDialog.popdown();
}


// Static methods

DwtShell._preventDefaultSelectPrt =
function(ev) {
    var evt = AjxCore.objectWithId(window._dwtShell)._uiEvent;
    evt.setFromDhtmlEvent(ev);

	if (evt.dwtObj && evt.dwtObj instanceof DwtControl && !evt.dwtObj.preventSelection(evt.target)) {
        evt._stopPropagation = false;
        evt._returnValue = true;
    } else {
        evt._stopPropagation = true;
        evt._returnValue = false;
    }
    evt.setToDhtmlEvent(ev);
    return !evt._stopPropagation;
}

DwtShell._preventDefaultPrt =
function(ev) {
	ev = DwtUiEvent.getEvent(ev);
	var target = ev.target ? ev.target : ev.srcElement;
	
    var evt = AjxCore.objectWithId(window._dwtShell)._uiEvent;
    evt.setFromDhtmlEvent(ev);
	//default behavior
    evt._stopPropagation = true;
    evt._returnValue = false;
	if (evt.dwtObj && evt.dwtObj instanceof DwtControl && !evt.dwtObj.preventContextMenu(evt.target)) {
        evt._stopPropagation = false;
        evt._returnValue = true;
    } else if (target != null && typeof(target) == 'object') {
     	if ((target.tagName == "A" ||  target.tagName == "a") && target.href) {
	        evt._stopPropagation = false;
    	    evt._returnValue = true;
    	}
    } 
    
    evt.setToDhtmlEvent(ev);
    return evt._returnValue;
}

DwtShell._keyPressHdlr =
function(ev) {
	var shell = AjxCore.objectWithId(window._dwtShell);
	if (shell.isListenerRegistered(DwtEvent.ONKEYPRESS)) {
		var keyEvent = DwtShell.keyEvent;
		keyEvent.setFromDhtmlEvent(ev);
//		DBG.println("KEY PRESS - KC:" + keyEvent.keyCode + " CC: " + keyEvent.charCode 
//	   	         + " ALT: " + keyEvent.altKey + " SHIFT: " + keyEvent.shiftKey + " CTRL: " + keyEvent.ctrlKey);
	   	         
//	   	if (keyEvent.target)
//			DBG.println("TARGET NAME: " + keyEvent.target.tagName + " ID: " + keyEvent.target.id);	
	
		var tagName = (keyEvent.target) ? keyEvent.target.tagName.toLowerCase() : null;
		if (tagName != "input" && tagName != "textarea") {
			return shell.notifyListeners(DwtEvent.ONKEYPRESS, keyEvent);
//			keyEvent._stopPropagation = true;
//    		keyEvent._returnValue = false;
//    		keyEvent.setToDhtmlEvent(ev);
//   		return keyEvent._returnValue;
    	} 
    }
}

/* This the resize handler to track when the browser window size changes */
DwtShell._resizeHdlr =
function(ev) {
	var shell = AjxCore.objectWithId(window._dwtShell);
	if (shell.isListenerRegistered(DwtEvent.CONTROL)) {
	 	var evt = DwtShell.controlEvent;
	 	evt.reset();
	 	evt.oldWidth = shell._currWinSize.x;
	 	evt.oldHeight = shell._currWinSize.y;
	 	shell._currWinSize = Dwt.getWindowSize();
	 	evt.newWidth = shell._currWinSize.x;
	 	evt.newHeight = shell._currWinSize.y;
	 	shell.notifyListeners(DwtEvent.CONTROL, evt);
	} else {
		shell._currWinSize = Dwt.getWindowSize();
	}
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a color picker displaying "Web safe" colours. Instances of this class may be
* used with DwtMenu to create a ColorPicker menu. Clicking on a color cell generates a
* DwtSelectionEvent the detail attribute of which contains the color string associated
* the cell on which the user clicked
*
* @constructor
* @class
*
* @author Ross Dargahi
* @param parent		the parent widget
* @param className	a CSS class
* @param posStyle	positioning style
*/
function DwtColorPicker(parent, className, posStyle) {
	if (arguments.length == 0) return;
	className = className || "DwtColorPicker";
	DwtControl.call(this, parent, className, posStyle);

	this._createColorTable();
	this._registerEventHdlrs();
	this.setCursor("default");
}

DwtColorPicker.prototype = new DwtControl;
DwtColorPicker.prototype.constructor = DwtColorPicker;

// RE to parse out components out of a "rgb(r, g, b);" string
DwtColorPicker._RGB_RE = /rgb\(([0-9]{1,3}), ([0-9]{1,3}), ([0-9]{1,3})\)/;
DwtColorPicker._HEX_RE = /\#([0-9FCfc]{2})([0-9FCfc]{2})([0-9FCfc]{2})/;


// Public methods

DwtColorPicker.prototype.toString = 
function() {
	return "DwtColorPicker";
}

/**
* Adds a listener to be notified when the button is pressed.
*
* @param listener	a listener
*/
DwtColorPicker.prototype.addSelectionListener = 
function(listener) {
	this.addListener(DwtEvent.SELECTION, listener);
}

/**
* Removes a selection listener.
*
* @param listener	the listener to remove
*/
DwtColorPicker.prototype.removeSelectionListener = 
function(listener) { 
	this.removeListener(DwtEvent.SELECTION, listener);
}

DwtColorPicker.prototype.dispose = 
function () {
	if (this._disposed) return;
	Dwt.disassociateElementFromObject(this.getHtmlElement().firstChild, this);
	DwtControl.prototype.dispose.call(this);
}

DwtColorPicker.prototype._registerEventHdlrs =
function() {
	var table = this.getHtmlElement().firstChild;
	Dwt.associateElementWithObject(table, this);	
	var rows = table.rows;
	var numRows = rows.length;

	for (var i = 0; i < numRows; i++) {
		var cells = rows[i].cells;
		var numCells = cells.length
		for (var j = 0; j < numCells; j++) {
			var cell = cells[j];
			Dwt.setHandler(cell, DwtEvent.ONMOUSEDOWN, DwtColorPicker._mouseDownHdlr);
			Dwt.setHandler(cell, DwtEvent.ONMOUSEUP, DwtColorPicker._mouseUpHdlr);
			if (AjxEnv.isIE) {
				Dwt.setHandler(cell, DwtEvent.ONMOUSEOVER, DwtColorPicker._mouseOverHdlr);
				Dwt.setHandler(cell, DwtEvent.ONMOUSEOUT, DwtColorPicker._mouseOutHdlr);
			} else {
				Dwt.setHandler(cell, DwtEvent.ONMOUSEENTER, DwtColorPicker._mouseOverHdlr);
				Dwt.setHandler(cell, DwtEvent.ONMOUSELEAVE, DwtColorPicker._mouseOutHdlr);
			}
			cell.style.border = "2px outset " + cell.style.backgroundColor;
		}
	}
}

DwtColorPicker.prototype._createColorTable =
function() {
	this._tdId = Dwt.getNextId();
	var html = new Array(150);
	var i = 0;
	
	html[i++] = "<table cellpadding='0' cellspacing='0' border='0' align='center'>";
	html[i++] = "<tr>"
	html[i++] = "<td id='" + this._tdId + "#FFFFFF' style='background-color:#FFFFFF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FFCCCC' style='background-color:#FFCCCC' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FFCC99' style='background-color:#FFCC99' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FFFF99' style='background-color:#FFFF99' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FFFFCC' style='background-color:#FFFFCC' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#99FF99' style='background-color:#99FF99' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#99FFFF' style='background-color:#99FFFF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#CCFFFF' style='background-color:#CCFFFF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#CCCCFF' style='background-color:#CCCCFF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FFCCFF' style='background-color:#FFCCFF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "</tr><tr>";
	html[i++] = "<td id='" + this._tdId + "#CCCCCC' style='background-color:#CCCCCC' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FF6666' style='background-color:#FF6666' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FF9966' style='background-color:#FF9966' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FFFF66' style='background-color:#FFFF66' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FFFF33' style='background-color:#FFFF33' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#66FF99' style='background-color:#66FF99' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#33FFFF' style='background-color:#33FFFF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#66FFFF' style='background-color:#66FFFF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#9999FF' style='background-color:#9999FF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FF99FF' style='background-color:#FF99FF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "</tr><tr>";
	html[i++] = "<td id='" + this._tdId + "#C0C0C0' style='background-color:#C0C0C0' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FF0000' style='background-color:#FF0000' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FF9900' style='background-color:#FF9900' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FFCC66' style='background-color:#FFCC66' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FFFF00' style='background-color:#FFFF00' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#33FF33' style='background-color:#33FF33' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#66CCCC' style='background-color:#66CCCC' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#33CCFF' style='background-color:#33CCFF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#6666CC' style='background-color:#6666CC' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#CC66CC' style='background-color:#CC66CC' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "</tr><tr>";
	html[i++] = "<td id='" + this._tdId + "#999999' style='background-color:#999999' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#CC0000' style='background-color:#CC0000' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FF6600' style='background-color:#FF6600' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FFCC33' style='background-color:#FFCC33' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#FFCC00' style='background-color:#FFCC00' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#33CC00' style='background-color:#33CC00' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#00CCCC' style='background-color:#00CCCC' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#3366FF' style='background-color:#3366FF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#6633FF' style='background-color:#6633FF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#CC33CC' style='background-color:#CC33CC' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "</tr><tr>";
	html[i++] = "<td id='" + this._tdId + "#666666' style='background-color:#666666' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#990000' style='background-color:#990000' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#CC6600' style='background-color:#CC6600' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#CC9933' style='background-color:#CC9933' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#999900' style='background-color:#999900' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#009900' style='background-color:#009900' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#339999' style='background-color:#339999' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#3333FF' style='background-color:#3333FF' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#6600CC' style='background-color:#6600CC' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#993399' style='background-color:#993399' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "</tr><tr>";
	html[i++] = "<td id='" + this._tdId + "#333333' style='background-color:#333333' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#660000' style='background-color:#660000' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#993300' style='background-color:#993300' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#996633' style='background-color:#996633' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#666600' style='background-color:#666600' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#006600' style='background-color:#006600' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#336666' style='background-color:#336666' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#000099' style='background-color:#000099' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#333399' style='background-color:#333399' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#663366' style='background-color:#663366' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "</tr><tr>";
	html[i++] = "<td id='" + this._tdId + "#000000' style='background-color:#000000' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#330000' style='background-color:#330000' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#663300' style='background-color:#663300' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#663333' style='background-color:#663333' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#333300' style='background-color:#333300' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#003300' style='background-color:#003300' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#003333' style='background-color:#003333' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#000066' style='background-color:#000066' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#330099' style='background-color:#330099' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "<td id='" + this._tdId + "#330033' style='background-color:#330033' width='12' height='14'><img height='1' width='1'/></td>";
	html[i++] = "</tr></table>";
	
	this.getHtmlElement().innerHTML = html.join("");
}

DwtColorPicker._mouseOverHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	var target = mouseEv.target;
	if (target.nodeName.toLowerCase() == "img")
		target = target.parentNode;

	if (mouseEv.dwtObj._downTdId == target.id) {
		var tmp = target.style.backgroundColor;
		target.style.backgroundColor = mouseEv.dwtObj._swappedColor;
		mouseEv.dwtObj._swappedColor = tmp
		target.style.border = "2px inset " + tmp;
	}

	this._stopPropagation = true;
	this._returnValue = false;
	mouseEv.setToDhtmlEvent(ev)
	return false;
}

DwtColorPicker._mouseOutHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	var target = mouseEv.target;
	if (target.nodeName.toLowerCase() == "img")
		target = target.parentNode;
 
	if (mouseEv.dwtObj._downTdId == target.id) {
		var tmp = target.style.backgroundColor;
		target.style.backgroundColor = mouseEv.dwtObj._swappedColor;
		mouseEv.dwtObj._swappedColor = tmp
		target.style.border = "2px outset " + tmp;
		mouseEv.dwtObj._downTdId = null;
	}

	this._stopPropagation = true;
	this._returnValue = false;
	mouseEv.setToDhtmlEvent(ev)
	return false;
}

DwtColorPicker._mouseDownHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	var target = mouseEv.target;
	if (target.nodeName.toLowerCase() == "img")
		target = target.parentNode;
	
	// Make a depressed button color darker than the original color to get
	// a true depressed effect
	var colorStr = mouseEv.target.style.backgroundColor;
	var rgb;
	var r, g, b;
	
	mouseEv.dwtObj._downTdId = target.id;
	mouseEv.dwtObj._swappedColor = colorStr;
	target.style.border = "2px inset " + colorStr;

	// IE refuses to convert Hex 2 rgb
	if (colorStr.substr(0, 1) == "#") {
		rgb = colorStr.match(DwtColorPicker._HEX_RE);
		rgb[1] = DwtColorPicker._hexConv(rgb[1]); 
		rgb[2] = DwtColorPicker._hexConv(rgb[2]); 
		rgb[3] = DwtColorPicker._hexConv(rgb[3]); 
	} else {
		rgb = colorStr.match(DwtColorPicker._RGB_RE);
	}
	
	r = Math.max(Math.floor(rgb[1] - (rgb[1] * 0.25)), 0);
	g = Math.max(Math.floor(rgb[2] - (rgb[2] * 0.25)), 0);
	b = Math.max(Math.floor(rgb[3] - (rgb[3] * 0.25)), 0);
	colorStr = "rgb(" + r + "," + g + "," + b + ")";
	target.style.backgroundColor = colorStr;
	
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev)
	return false;
}

DwtColorPicker._hexConv = 
function(hexStr) {
	if (hexStr == "00")
		return 0;
	else if (hexStr == "33")
		return 51;
	else if (hexStr == "66")
		return 102;
	else if (hexStr == "99")
		return 153;
	else if (hexStr.toUpperCase() == "CC")
		return 204;
	else if (hexStr.toUpperCase() == "FF")
		return 255;
	else if (hexStr.toUpperCase() == "C0")
		return 192;
}

DwtColorPicker._mouseUpHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	var me = mouseEv.dwtObj;
	
	var target = mouseEv.target;
	if (target.nodeName.toLowerCase() == "img")
		target = target.parentNode;
	
	if (me._downTdId == target.id) {
		target.style.border = "2px outset " + mouseEv.dwtObj._swappedColor;
		target.style.backgroundColor = mouseEv.dwtObj._swappedColor;
	}
	
	if (me._downTdId == target.id) {
	
		// If our parent is a menu then we need to have it close
		if (me.parent instanceof DwtMenu)
			DwtMenu.closeActiveMenu();
	
		// Call Listeners on mouseEv.target.id
		if (me.isListenerRegistered(DwtEvent.SELECTION)) {
	    	var selEv = DwtShell.selectionEvent;
	    	DwtUiEvent.copy(selEv, mouseEv);
	    	selEv.item = me;
	    	selEv.detail = mouseEv.target.id.substr(mouseEv.target.id.indexOf("#"));
	    	me.notifyListeners(DwtEvent.SELECTION, selEv);
	    }
	}
	
	me._downTdId = null;
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev)
	return false;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a new dialog container without displaying it. The shell must be provided.

* @constructor
* @class
* This is a base class for dialogs. Given content, this class will take care of 
* showing, and hiding the dialog, as well as dragging it.
* <p>
* Content that is draggable ( classes that override _createHtml ), need to create
* an element with an id of this.getHtmlElement().id + "_handle".
* <p>
* Dialogs always hang off the main shell since their stacking order is managed through z-index.
*
* @author Ross Dargahi
* @author Conrad Damon
* @param parent				parent widget (the shell)
* @param classname			a CSS class
* @param zIndex				z-index when the dialog is visible
* @param mode				modal or modeless
* @param loc				where to popup
*/
function DwtBaseDialog(parent, className, title, zIndex, mode, loc, optionalView, optionalDragHandleId) {

	if (arguments.length == 0) return;
	if (!(parent instanceof DwtShell)) {
		throw new DwtException("DwtBaseDialog parent must be a DwtShell", 
							   DwtException.INVALIDPARENT, "DwtDialog");
	}
	className = className || "DwtBaseDialog";
	this._title = title || "";

	DwtComposite.call(this, parent, className, DwtControl.ABSOLUTE_STYLE);
	DBG.timePt(AjxDebug.PERF, "DwtComposite constructor");

	this._shell = parent;
	this._zIndex = zIndex || Dwt.Z_DIALOG;

	this._mode = mode || DwtBaseDialog.MODAL;
	this._loc = loc;
	this._ffHackDisabled = false;

	this._createHtml();
	DBG.timePt(AjxDebug.PERF, "DwtBaseDialog#_createHtml");
	if (optionalView != null) {
		this.setView(optionalView);
	}
	// make dialog draggable within boundaries of shell
	var htmlElement = this.getHtmlElement();
	
	// Workaround for the hidden cursor issue in Gecko based browsers like FireFox
	//if (AjxEnv.isGeckoBased)
	//	htmlElement.style.overflow = "auto";
		
	var dHandleId = optionalDragHandleId ? optionalDragHandleId : (htmlElement.id + "_handle");
	this.initializeDragging(dHandleId);
	DBG.timePt(AjxDebug.PERF, "init dragging");
	
	// reset tab index
	this._tabIndex = 0;
    this.setZIndex(Dwt.Z_HIDDEN); // not displayed until popup() called
	this._positionDialog({x:-10000, y:-10000});
	DBG.timePt(AjxDebug.PERF, "DwtBaseDialog#_positionDialog");
}

DwtBaseDialog.prototype = new DwtComposite;
DwtBaseDialog.prototype.constructor = DwtBaseDialog;

// modes
DwtBaseDialog.MODELESS = 1;
DwtBaseDialog.MODAL = 2;


// -------------------------------------------------------------------
// API Methods 
// -------------------------------------------------------------------

DwtBaseDialog.prototype.toString = 
function() {
	return "DwtBaseDialog";
};

DwtBaseDialog.prototype.initializeDragging = 
function(dragHandleId) {
	var dragHandle = document.getElementById(dragHandleId);
	if (dragHandle) {
		var p = Dwt.getSize(AjxCore.objectWithId(window._dwtShell).getHtmlElement());
		var dragObj = document.getElementById(this._htmlElId);
		var size = this.getSize();
		var dragEndCb = new AjxCallback(this, this._dragEnd);
		var dragCb = new AjxCallback(this, this._duringDrag);
		var dragStartCb = new AjxCallback(this, this._dragStart);
		
 		DwtDraggable.init(dragHandle, dragObj, 0,
 						  document.body.offsetWidth - 10, 0, document.body.offsetHeight - 10, dragStartCb, dragCb, dragEndCb);
	}	
};

/**
* Makes the dialog visible, and places it. Everything under the dialog will become veiled
* if we are modal.
*
* @param loc	the desired location
*/
DwtBaseDialog.prototype.popup =
function(loc) {
	
	this.cleanup(true);
	DBG.timePt(AjxDebug.PERF, "DwtBaseDialog#cleanup");

	var thisZ = this._zIndex;
	// if we're modal, setup the veil effect,
	// and track which dialogs are open
	if (this._mode == DwtBaseDialog.MODAL) {
		thisZ = this._setModalEffect(thisZ);
	}
	DBG.timePt(AjxDebug.PERF, "DwtBaseDialog#setModelEffect");

	// add the listener functions for key events that
	// we're interested in
	this.addKeyListeners();
	this._shell._veilOverlay.activeDialogs.push(this);
	DBG.timePt(AjxDebug.PERF, "push this on list of active dialogs");

	// Deal with Firefox's horrible bug with absolutely 
	// positioned divs and inputs floating over them.
	if (!this._ffHackDisabled) Dwt._ffOverflowHack(this._htmlElId, thisZ, null, false);
	DBG.timePt(AjxDebug.PERF, "Dwt._ffOverflowHack");
	
	// use whichever has a value, local has precedence
	loc = this._loc = loc || this._loc; 
	
	this._positionDialog(loc);
	DBG.timePt(AjxDebug.PERF, "DwtBaseDialog#positionDialog");
	this.setZIndex(thisZ);
	DBG.timePt(AjxDebug.PERF, "DwtBaseDialog#setZIndex");
	this._poppedUp = true;
	this.focus();
	DBG.timePt(AjxDebug.PERF, "DwtBaseDialog#focus");
}

DwtBaseDialog.prototype._disableFFhack = 
function() {
	this._ffHackDisabled = true;
}

DwtBaseDialog.prototype.focus = 
function () {
	// if someone is listening for the focus to happen, give 
	// control to them, otherwise focus on this dialog.
	if (this.isListenerRegistered(DwtEvent.ONFOCUS)) {
		this.notifyListeners(DwtEvent.ONFOCUS);
	} else if (this._focusElementId){
		var focEl = document.getElementById(this._focusElementId);
		if (focEl) {
			focEl.focus();
		}
	}
};

DwtBaseDialog.prototype.isPoppedUp =
function () {
	return this._poppedUp;
};

/**
* Hides the dialog.
*/
DwtBaseDialog.prototype.popdown =
function() {

	if (this._poppedUp) {
		this._poppedUp = false;
		this.cleanup(false);
	
		//var myZIndex = this.getZIndex();
	    var myZIndex = this._zIndex;
		this.setZIndex(Dwt.Z_HIDDEN);
		this._positionDialog({x:Dwt.LOC_NOWHERE, y:Dwt.LOC_NOWHERE});
		if (this._mode == DwtBaseDialog.MODAL) {
			this._undoModality(myZIndex);
		} else {
			if (!this._ffHackDisabled) Dwt._ffOverflowHack(this._htmlElId, myZIndex, null, false);
			this._shell._veilOverlay.activeDialogs.pop();
		}
		this.removeKeyListeners();
	}
}

DwtBaseDialog.prototype.setView =
function(newView) {
	this.reset();
	if (newView) this._getContentDiv().appendChild(newView.getHtmlElement());
};

/**
* Sets the dialog back to its original state after being constructed, by clearing any
* detail message and resetting the standard button callbacks.
*/
DwtBaseDialog.prototype.reset =
function() {
	this._loc = null;
}

/**
* cleans up the dialog so it can be used again later
*/
DwtBaseDialog.prototype.cleanup =
function(bPoppedUp) {

	var inputFields = this._getInputFields();
	
	if (inputFields) {
		for (var i = 0; i < inputFields.length; i++) {
			inputFields[i].disabled = !bPoppedUp;
			if (bPoppedUp)
				inputFields[i].value = "";
		}
	}
}

/**
* Sets the dialog content (below the title, above the buttons).
*
* @param text		dialog content
*/
DwtBaseDialog.prototype.setContent =
function(text) {
	var d = this._getContentDiv();
	if (d) {
		var content =
			DwtBorder.getBorderStartHtml("dialog") + 
			text + 
			DwtBorder.getBorderEndHtml("dialog");
		d.innerHTML = text;
	}
}

DwtBaseDialog.prototype._getContentDiv =
function (){
	return this._contentDiv;
};
/** 
 * @param listenerFunc -- takes an event when the tab key
 * has been pressed for an element inside of this dialog.
 */
DwtBaseDialog.prototype.addTabListener =
function(listener) {
	this.addListener(DwtEvent.TAB, listener);
};

DwtBaseDialog.prototype.addEnterListener =
function(listener) {
	this.addListener(DwtEvent.ENTER, listener);
};

DwtBaseDialog.getActiveDialog = 
function() {
	var dialog = null;
	var shellObj = DwtShell.getShell(window);
	if (shellObj) {
		var len = shellObj._veilOverlay.activeDialogs.length;
		if (len > 0) {
			dialog = shellObj._veilOverlay.activeDialogs[len - 1];
		}
	}
	return dialog;
};

DwtBaseDialog.prototype.handleKeys = 
function(ev) {
	var ad = DwtBaseDialog.getActiveDialog();
	var dialogEl = ad.getHtmlElement();
	var target = DwtUiEvent.getTarget(ev);
	var keyCode = DwtKeyEvent.getCharCode(ev);
	switch (keyCode) {
	case DwtKeyEvent.KEY_TAB:
		if (ad && ad._mode == DwtBaseDialog.MODAL) {
			ev.item = ad;
			var isContained = ad._doesContainElement(target);
			if (isContained) {
				ev.isTargetInDialog = true;
				if (ad._tabIdOrder) {
					var oldTabIndex = -1;
					if (ad._tabIndex != null ) {
						oldTabIndex = ad._tabIndex;
						ad._tabIndex = ++ad._tabIndex % ad._tabIdOrder.length;
					} else {
						ad._tabIndex =  1;
					}
					var id = ad._tabIdOrder[ad._tabIndex];
					document.getElementById(id).focus();
					ev.oldTabIndexId = (oldTabIndex == -1) ? oldTabIndex : ad._tabIdOrder[oldTabIndex];
					ev.isTargetInDialog = true;
					ev.currentTabIndexId = id;
				} 
			} else {
				ev.oldTabIndexId = -1;
				ev.isTargetInDialog = false;
				ev.currentTabIndexId = -1;
			}
			ad.notifyListeners(DwtEvent.TAB, ev);
			DwtUiEvent.setBehaviour(ev, true, false);
		}
		break;
	case DwtKeyEvent.KEY_ENTER:
		ad.notifyListeners(DwtEvent.ENTER, ev);
		break;
	}
};

DwtBaseDialog.prototype.setTabOrder = 
function(elementIdArray) {
	this._tabIdOrder = elementIdArray;
};

DwtBaseDialog.prototype.addKeyListeners =
function() {
	if (this._shell._veilOverlay.activeDialogs.length == 0 ) {
		if (window.addEventListener) {
			window.addEventListener('keypress', this.handleKeys, false);
		} else if (document.body.attachEvent) {
			document.body.attachEvent('onkeydown', this.handleKeys);
		}
	}
};

DwtBaseDialog.prototype.removeKeyListeners =
function () {
	if (this._shell._veilOverlay.activeDialogs.length == 0 ) {
		if (window.removeEventListener) {
			window.removeEventListener('keypress', this.handleKeys, false);
		} else if (document.body.detachEvent) {
			document.body.detachEvent('onkeydown', this.handleKeys);
		}
	}
};

// -------------------------------------------------------------------
// Private methods
// -------------------------------------------------------------------

DwtBaseDialog.prototype._getStartBorder = 
function() {
	if (!this._titleHandleId) this._titleHandleId = Dwt.getNextId();
	if (!this._contentId) this._contentId = Dwt.getNextId();
	if (!this._titleCellId) this._titleCellId = Dwt.getNextId();
	return DwtBorder.getBorderStartHtml("dialog", {title : this._title, titleTextId: this._titleCellId,
												titleId: this._titleHandleId});
};

DwtBaseDialog.prototype._getEndBorder = 
function() {
	return DwtBorder.getBorderEndHtml("dialog");
};

DwtBaseDialog.prototype._getContentHtml = 
function() {
	return "<div id='" + this._contentId + "'></div>"
};

/**
 * A subclass will probably override this method
 */
DwtBaseDialog.prototype._createHtml =
function() {
	var htmlElement = this.getHtmlElement();
	var html = new Array();
	var idx = 0;
	html[idx++] = this._getStartBorder();
	html[idx++] = this._getContentHtml();
	html[idx++] = this._getEndBorder();
	htmlElement.innerHTML = html.join("");
	this._contentDiv = document.getElementById(this._contentId);
}

DwtBaseDialog.prototype._setModalEffect = 
function() {
	// place veil under this dialog
	var dialogZ = this._shell._veilOverlay.dialogZ;
	var currentDialogZ = null;
	var veilZ;
	if (dialogZ.length)
		currentDialogZ = dialogZ[dialogZ.length - 1];
	if (currentDialogZ) {
		thisZ = currentDialogZ + 2;
		veilZ = currentDialogZ + 1;
	} else {
		thisZ = this._zIndex;
		veilZ = Dwt.Z_VEIL;
	}
	this._shell._veilOverlay.veilZ.push(veilZ);
	this._shell._veilOverlay.dialogZ.push(thisZ);
	Dwt.setZIndex(this._shell._veilOverlay, veilZ);
	return thisZ;
};

DwtBaseDialog.prototype._undoModality =
function (myZIndex) {
	var veilZ = this._shell._veilOverlay.veilZ;
	veilZ.pop();
	var newVeilZ = veilZ[veilZ.length - 1];
	if (!this._ffHackDisabled) Dwt._ffOverflowHack(this._htmlElId, myZIndex, null, false);
	Dwt.setZIndex(this._shell._veilOverlay, newVeilZ);
	this._shell._veilOverlay.dialogZ.pop();
	this._shell._veilOverlay.activeDialogs.pop();
	if (this._shell._veilOverlay.activeDialogs.length > 0 ) {
		this._shell._veilOverlay.activeDialogs[0].focus();
	}
};

DwtBaseDialog.prototype._positionDialog = 
function (loc) {
	var sizeShell = this._shell.getSize();
	DBG.timePt(AjxDebug.PERF, "DwtBaseDialog#_positionDialog: get shell size");
	var sizeThis = this.getSize();
	DBG.timePt(AjxDebug.PERF, "DwtBaseDialog#_positionDialog: get dialog size");
	var x, y;
	if (loc == null) {
		// if no location, go for the middle
		x = Math.round((sizeShell.x - sizeThis.x) / 2);
		y = Math.round((sizeShell.y - sizeThis.y) / 2);
	} else {
		x = loc.x;
		y = loc.y;
	}
	// try to stay within shell boundaries
	if ((x + sizeThis.x) > sizeShell.x)
		x = sizeShell.x - sizeThis.x;
	if ((y + sizeThis.y) > sizeShell.y)
		y = sizeShell.y - sizeThis.y;
	this.setLocation(x, y);
	DBG.timePt(AjxDebug.PERF, "DwtBaseDialog#_positionDialog: set location");
};

// returns a list of input fields in dialog
DwtBaseDialog.prototype._getInputFields = 
function() {
	// overload me
}

DwtBaseDialog.prototype._dragStart = 
function (x, y){
	// fix for bug 3177
	if (AjxEnv.isNav) {
		this._currSize = this.getSize();
		DwtDraggable.setDragBoundaries(DwtDraggable._dragEl, 0, document.body.offsetWidth - this._currSize.x, 0, 
									   document.body.offsetHeight - this._currSize.y);
	}
};

DwtBaseDialog.prototype._dragEnd =
function(x, y) {
// 	// save dropped position so popup(null) will not re-center dialog box
// 	DBG.println("drag end x:", x, " y:", y);
	this._loc = new DwtPoint(x, y);
}

DwtBaseDialog.prototype._duringDrag =
function(x, y) {
// 	DBG.println("during drag x:", x, " y:", y);
	// overload me
};

DwtBaseDialog.prototype._doesContainElement = 
function (element) {
	return Dwt.contains(this.getHtmlElement(), element);
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a new dialog, without displaying it. The shell must be provided, and a 
* title should be provided as well. Everything else has a reasonable default.
* @constructor
* @class
* This class represents a popup dialog which has at least a title and up to 
* three standard buttons (OK, Cancel). A client or subclass sets the content.
* <p>
* Dialogs always hang off the main shell since their stacking order is managed 
* through z-index.
*
* @author Ross Dargahi
* @author Conrad Damon
*
* @param parent				parent widget (the shell)
* @param classname			a CSS class
* @param title				a title for the dialog
* @param standardButtons	a list of standard button IDs
* @param extraButtons		a list of button descriptors
* @param zIndex				z-index when the dialog is visible
* @param mode				modal or modeless
* @param loc				where to popup
*/
function DwtDialog(parent, className, title, standardButtons, extraButtons, zIndex, mode, loc) {

	if (arguments.length == 0) return;
	className = className || "DwtDialog";
	this._title = title || "";

	// standard buttons default to OK / Cancel
	if (!standardButtons) {
		standardButtons = [DwtDialog.OK_BUTTON, DwtDialog.CANCEL_BUTTON];
	} else if (standardButtons == DwtDialog.NO_BUTTONS) {
		standardButtons = null;
	}
	// assemble the list of button IDs, and the list of button descriptors
	this._buttonList = new Array();
	if (standardButtons || extraButtons) {
		this._buttonDesc = new Object();
		if (standardButtons && standardButtons.length) {
			this._enterButtonId = standardButtons[0];
			for (var i = 0; i < standardButtons.length; i++) {
				var buttonId = standardButtons[i];
				this._buttonList.push(buttonId);
				// creating standard button descriptors on file read didn't work, so we create them here
				this._buttonDesc[buttonId] = new DwtDialog_ButtonDescriptor(buttonId, AjxMsg[DwtDialog.MSG_KEY[buttonId]],
																			this.getAlignmentForButton(buttonId));
			}
			// set standard callbacks
			this._resetCallbacks();
		}
		if (extraButtons && extraButtons.length) {
			if (!this._enterButtonId) {
				this._enterButtonId = extraButtons[0];
			}
			for (var i = 0; i < extraButtons.length; i++) {
				var buttonId = extraButtons[i].id;
				this._buttonList.push(buttonId);
				this._buttonDesc[buttonId] = extraButtons[i];
			}
		}
		DBG.timePt(AjxDebug.PERF, "DwtDialog: constructed buttons");
	}

	this._titleCellId = Dwt.getNextId();
	this._contentId = Dwt.getNextId();

	// get button IDs
	this._buttonElementId = new Object();
	for (var i = 0; i < this._buttonList.length; i++)
		this._buttonElementId[this._buttonList[i]] = Dwt.getNextId();

	DwtBaseDialog.call(this, parent, className, this._title, zIndex, mode, loc);
	DBG.timePt(AjxDebug.PERF, "DwtBaseDialog constructor");
	this._titleCell = document.getElementById(this._titleCellId);
	this._contentDiv = document.getElementById(this._contentId);

	// set up buttons
	this._button = new Object();
	for (var i = 0; i < this._buttonList.length; i++) {
		var buttonId = this._buttonList[i];
		this._button[buttonId] = new DwtButton(this);
		this._button[buttonId].setText(this._buttonDesc[buttonId].label);
		this._button[buttonId].buttonId = buttonId;
		this._button[buttonId].addSelectionListener(new AjxListener(this, this._buttonListener));
		document.getElementById(this._buttonElementId[buttonId]).appendChild(this._button[buttonId].getHtmlElement());
	}
	this.initializeDragging(this._titleHandleId);
	DBG.timePt(AjxDebug.PERF, "setup buttons and init dragging");
}

DwtDialog.prototype = new DwtBaseDialog;
DwtDialog.prototype.constructor = DwtDialog;

function DwtDialog_ButtonDescriptor(id, label, align, callback, cellTemplate) {
	this.id = id;
	this.label = label;
	this.align = align;
	this.callback = callback;
	this.cellTemplate = cellTemplate;
}

DwtDialog.prototype.getAlignmentForButton =
function (id) {
	return DwtDialog.ALIGN[id];
};

DwtDialog.ALIGN_LEFT 		= 1;
DwtDialog.ALIGN_RIGHT 		= 2;
DwtDialog.ALIGN_CENTER 		= 3;

// standard buttons, their labels, and their positioning
DwtDialog.CANCEL_BUTTON 	= 1;
DwtDialog.OK_BUTTON 		= 2;
DwtDialog.DISMISS_BUTTON 	= 3;
DwtDialog.NO_BUTTON 		= 4;
DwtDialog.YES_BUTTON 		= 5;
DwtDialog.LAST_BUTTON 		= 5;
DwtDialog.NO_BUTTONS 		= 256;
DwtDialog.ALL_BUTTONS 		= [DwtDialog.CANCEL_BUTTON, DwtDialog.OK_BUTTON, 
							   DwtDialog.DISMISS_BUTTON, DwtDialog.NO_BUTTON, 
							   DwtDialog.YES_BUTTON];

DwtDialog.MSG_KEY = new Object();
DwtDialog.MSG_KEY[DwtDialog.CANCEL_BUTTON] 	= "cancel";
DwtDialog.MSG_KEY[DwtDialog.OK_BUTTON] 		= "ok";
DwtDialog.MSG_KEY[DwtDialog.DISMISS_BUTTON] = "dismiss";
DwtDialog.MSG_KEY[DwtDialog.NO_BUTTON] 		= "no";
DwtDialog.MSG_KEY[DwtDialog.YES_BUTTON] 	= "yes";

DwtDialog.ALIGN = new Object();
DwtDialog.ALIGN[DwtDialog.CANCEL_BUTTON]	= DwtDialog.ALIGN_RIGHT;
DwtDialog.ALIGN[DwtDialog.OK_BUTTON] 		= DwtDialog.ALIGN_RIGHT;
DwtDialog.ALIGN[DwtDialog.DISMISS_BUTTON] 	= DwtDialog.ALIGN_RIGHT;
DwtDialog.ALIGN[DwtDialog.NO_BUTTON] 		= DwtDialog.ALIGN_RIGHT;
DwtDialog.ALIGN[DwtDialog.YES_BUTTON] 		= DwtDialog.ALIGN_RIGHT;

// modes
DwtDialog.MODELESS = DwtBaseDialog.MODELESS;
DwtDialog.MODAL = DwtBaseDialog.MODAL;

// -------------------------------------------------------------------
// API Methods 
// -------------------------------------------------------------------

DwtDialog.prototype.toString = 
function() {
	return "DwtDialog";
};

DwtDialog.prototype.popdown =
function() {
	DwtBaseDialog.prototype.popdown.call(this);
	this.resetButtonStates();
};

/**
* Sets the dialog back to its original state after being constructed, by clearing any
* detail message and resetting the standard button callbacks.
*/
DwtDialog.prototype.reset =
function() {
	this._resetCallbacks();
	this.resetButtonStates();
	DwtBaseDialog.prototype.reset.call(this);
};

/**
 * Sets all buttons back to inactive
 */
DwtDialog.prototype.resetButtonStates =
function() {
	for (b in this._button) {
		this._button[b].setEnabled(true);
		this._button[b].setActivated(false);
	}
};

DwtDialog.prototype.getButton =
function(buttonId) {
	return this._button[buttonId];
};

DwtDialog.prototype.setButtonEnabled = 
function(buttonId, enabled) {
	this._button[buttonId].setEnabled(enabled);
};

DwtDialog.prototype.setButtonVisible = 
function(buttonId, visible) {
	this._button[buttonId].setVisible(visible);
};

DwtDialog.prototype.getButtonEnabled = 
function(buttonId) {
	return this._button[buttonId].getEnabled();
};

/**
* Registers a callback on the given button.
*
* @param button		one of the standard dialog buttons
* @param func		callback method
* @param obj		callback obj
*/
DwtDialog.prototype.registerCallback =
function(buttonId, func, obj, args) {
	this._buttonDesc[buttonId].callback = new AjxCallback(obj, func, args);
}
DwtDialog.prototype.unregisterCallback =
function(buttonId) {
	this._buttonDesc[buttonId].callback = null;
};

/**
* Makes the given listener the only listener for the given button.
*
* @param button		one of the standard dialog buttons
* @param listener	a listener
*/
DwtDialog.prototype.setButtonListener =
function(buttonId, listener) {
	this._button[buttonId].removeSelectionListeners();
	this._button[buttonId].addSelectionListener(listener);
}

/**
* Sets the dialog title.
*/
DwtDialog.prototype.setTitle =
function(title) {
	this._title = title;
	this._titleCell.innerHTML = title;
}

/**
* Sets the dialog content (below the title, above the buttons).
*
* @param text		dialog content
*/
DwtBaseDialog.prototype._getContentDiv =
function (){
	return this._contentDiv;
};


DwtDialog.prototype.associateEnterWithButton =
function(id) {
	this._enterButtonId = id;
};


// Private methods


// -----------------------------------------------------------------------
// layout methods -- subclasses should override to customize layout
// -----------------------------------------------------------------------
DwtDialog.prototype._getStartBorder = 
function() {
	var html = new Array();
	var idx = 0;
	html[idx++] = DwtBaseDialog.prototype._getStartBorder.call(this);
	if (AjxEnv.isNav) {
		html[idx++] = "<input type='button' id='";
		html[idx++] = this._focusElementId = Dwt.getNextId();
		html[idx++] = "' style='height:0px; width:0px;";
		html[idx++] = "display:none;";
		html[idx++] = "'>";
	}

	return html.join("");
};

DwtDialog.prototype._getContentHtml =
function() {
	var html = new Array();
	var idx = 0;
	html[idx++] = DwtBaseDialog.prototype._getContentHtml.call(this);
	idx = this._addButtonsHtml(html,idx);
	return html.join("");
};

DwtDialog.prototype._getSeparatorTemplate =
function () {
	return "<div class=horizSep></div>";
};

DwtDialog.prototype._getButtonsContainerStartTemplate =
function () {
	return "<table cellspacing='0' cellpadding='0' border='0' width='100%'><tr>";
};

DwtDialog.prototype._getButtonsAlignStartTemplate =
function () {
	return "<td align=\"{0}\"><table cellspacing='5' cellpadding='0' border='0'><tr>";
};

DwtDialog.prototype._getButtonsAlignEndTemplate =
function () {
	return "</tr></table></td>";
};

DwtDialog.prototype._getButtonsCellTemplate =
function () {
	return "<td id=\"{0}\"></td>";
};

DwtDialog.prototype._getButtonsContainerEndTemplate =
function () {
	return  "</tr></table>";
};

DwtDialog.prototype._addButtonsHtml =
function(html, idx) {
	if (this._buttonList) {
		var leftButtons = new Array();
		var rightButtons = new Array();
		var centerButtons = new Array();
		for (var i = 0; i < this._buttonList.length; i++) {
			var buttonId = this._buttonList[i];
			switch (this._buttonDesc[buttonId].align) {
				case DwtDialog.ALIGN_RIGHT: 	rightButtons.push(buttonId); break;
				case DwtDialog.ALIGN_LEFT: 		leftButtons.push(buttonId); break;
				case DwtDialog.ALIGN_CENTER:	centerButtons.push(buttonId); break;
			}
		}
		html[idx++] = this._getSeparatorTemplate();
		html[idx++] = this._getButtonsContainerStartTemplate();
		
		if (leftButtons.length) {
			html[idx++] = AjxMessageFormat.format(
								  this._getButtonsAlignStartTemplate(),
								  ["left"]);
			for (var i = 0; i < leftButtons.length; i++) {
				var buttonId = leftButtons[i];
				var cellTemplate = this._buttonDesc[buttonId].cellTemplate ? 
					this._buttonDesc[buttonId].cellTemplate : this._getButtonsCellTemplate();
		 		html[idx++] = AjxMessageFormat.format(
								  cellTemplate,
								  [this._buttonElementId[buttonId]]);
		 	}
			html[idx++] = this._getButtonsAlignEndTemplate();
		}
		if (centerButtons.length){
			html[idx++] = AjxMessageFormat.format(
								this._getButtonsAlignStartTemplate(),
								["center"]);
			for (var i = 0; i < centerButtons.length; i++) {
				var buttonId = centerButtons[i];
				var cellTemplate = this._buttonDesc[buttonId].cellTemplate ? 
					this._buttonDesc[buttonId].cellTemplate : this._getButtonsCellTemplate();				
		 		html[idx++] = AjxMessageFormat.format(
								cellTemplate,
								[this._buttonElementId[buttonId]]);
		 	}
			html[idx++] = this._getButtonsAlignEndTemplate();
		}
		if (rightButtons.length) {
			html[idx++] = AjxMessageFormat.format(
								this._getButtonsAlignStartTemplate(),
								["right"]);
			for (var i = 0; i < rightButtons.length; i++) {
				var buttonId = rightButtons[i];
				var cellTemplate = this._buttonDesc[buttonId].cellTemplate ? 
					this._buttonDesc[buttonId].cellTemplate : this._getButtonsCellTemplate();				

		 		html[idx++] = AjxMessageFormat.format(cellTemplate,
													[this._buttonElementId[buttonId]]);
		 	}
			html[idx++] = this._getButtonsAlignEndTemplate();
		}
		html[idx++] = this._getButtonsContainerEndTemplate();
	}	
	return idx;
};

// Button listener that checks for callbacks
DwtDialog.prototype._buttonListener =
function(ev, args) {
	var obj = DwtUiEvent.getDwtObjFromEvent(ev);
	var buttonId = obj.buttonId;
	this._runCallbackForButtonId(buttonId, args);
};

DwtDialog.prototype._runCallbackForButtonId =
function(id, args) {
	var callback = this._buttonDesc[id].callback;
	if (!callback) return;
	args = (args instanceof Array) ? args : [args];
	callback.run.apply(callback, args);
};

DwtDialog.prototype._runEnterCallback =
function(args) {
	if (this._enterButtonId && this.getButtonEnabled(this._enterButtonId)) {
		this._runCallbackForButtonId(this._enterButtonId, args);
	}
};

// Default callbacks for the standard buttons.
DwtDialog.prototype._resetCallbacks =
function() {
	for (var i = 0; i < DwtDialog.ALL_BUTTONS.length; i++) {
		var id = DwtDialog.ALL_BUTTONS[i];
		if (this._buttonDesc[id])
			this._buttonDesc[id].callback = new AjxCallback(this, this.popdown);
	}
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a label.
* @constructor
* @class
* This class represents a label, which consists of an image and/or some text. It is used
* both as a concrete class and as the base class for buttons. The label's components are
* managed within a table. The label can be enabled or disabled, which are reflected in 
* its display. A disabled label looks greyed out.
*
* @author Ross Dargahi
* @param parent		the parent widget
* @param style		the label style (a bitsum of constants)
* @param className	a CSS class
* @param posStyle	positioning style
*/
function DwtLabel(parent, style, className, posStyle) {

	if (arguments.length == 0) return;
	className = className ? className : "DwtLabel";
	DwtComposite.call(this, parent, className, posStyle);

	this._style = style ? style : (DwtLabel.IMAGE_LEFT | DwtLabel.ALIGN_CENTER);

	this._createTable();
	this.setCursor("default");
}

DwtLabel.prototype = new DwtComposite;
DwtLabel.prototype.constructor = DwtLabel;

// display styles
DwtLabel.IMAGE_LEFT = 1;
DwtLabel.IMAGE_RIGHT = 2;
DwtLabel.ALIGN_LEFT = 4;
DwtLabel.ALIGN_RIGHT = 8;
DwtLabel.ALIGN_CENTER = 16;
DwtLabel._LAST_STYLE = 16;

// Public methods

DwtLabel.prototype.toString = 
function() {
	return "DwtLabel";
}

DwtLabel.prototype._createTable =
function() {
	this._table = document.createElement("table");
	this._table.border = 0;
	
	// Left is the default alignment. Note that if we do an explicit align left, Firefox freaks out
	if (this._style & DwtLabel.ALIGN_RIGHT)
		this._table.align = "right";
	else if (!(this._style & DwtLabel.ALIGN_LEFT)) {
		this._table.align = "center";
		this._table.width = "100%";
	}

	this._row = this._table.insertRow(0);
	this.getHtmlElement().appendChild(this._table);
};

/**
* Sets the enabled/disabled state of the label. A disabled label may have a different
* image, and greyed out text.
*
* @param enabled	whether to enable the label
*/
DwtLabel.prototype.setEnabled =
function(enabled) {
	if (enabled != this._enabled) {
		DwtControl.prototype.setEnabled.call(this, enabled);
		if (enabled) {
			this._setImage(this._imageInfo);
			if (this._textCell != null)
				this._textCell.className = "";
		} else {
			if (this._disabledImageInfo)
				this._setImage(this._disabledImageInfo);
			if (this._textCell)
				this._textCell.className = "DisabledText";
		}
	}
}

/**
* Returns the current Image Info.
*/
DwtLabel.prototype.getImage =
function() {
	return this._imageInfo;
}

/**
* Sets the main (enabled) image. If the label is currently enabled, its image is updated.
*/
DwtLabel.prototype.setImage =
function(imageInfo) {
	this._imageInfo = imageInfo;
	if (this._enabled || (!this._enabled && this._disabledImageInfo))
		this._setImage(imageInfo);
}

/**
* Returns the disabled image. If the label is currently disabled, its image is updated.
*
* @param imageSrc	the disabled image
*/
DwtLabel.prototype.setDisabledImage =
function(imageInfo) {
	this._disabledImageInfo = imageInfo;
	if (!this._enabled && imageInfo)
		this._setImage(imageInfo);
}

/**
* Returns the label text.
*/
DwtLabel.prototype.getText =
function() {
	return (this._text != null) ? this._text.data : null;
}

/**
* Sets the label text, and manages its placement and display.
*
* @param text	the new label text
*/
DwtLabel.prototype.setText =
function(text) {
	if (text == null || text == "") {
		if (this._textCell != null) {
			var cellIndex = Dwt.getCellIndex(this._textCell);
			this._row.deleteCell(cellIndex);
		}
	} else {
		if (this._text == null) {
		  this._text = document.createTextNode(text);
		}
		this._text.data = text;
		var idx;
		if (this._textCell == null) {
			if (this._style & DwtLabel.IMAGE_RIGHT) {
				idx = 0;
			} else {
				idx = (this._imageCell != null) ? 1 : 0;
			}
			this._textCell = this._row.insertCell(idx);
			this._textCell.className = this._enabled ? "Text" : "DisabledText";
			if (this._textBackground)
				this._textCell.style.backgroundColor = this._textBackground;
			if (this._textForeground)
				this._textCell.style.color = this._textForeground;
			this._doAlign();
			this._textCell.noWrap = true;
			this._textCell.style.verticalAlign = "middle";
			this._textCell.appendChild(this._text);
		}
	}
}

DwtLabel.prototype.setTextBackground =
function(color) {
	this._textBackground = color;
	if (this._textCell)
		this._textCell.style.backgroundColor = color;
}

DwtLabel.prototype.setTextForeground =
function(color) {
	this._textForeground = color;
	if (this._textCell)
		this._textCell.style.color = color;
}


DwtLabel.prototype.setAlign =
function(alignStyle) {
	this._style = alignStyle;
	
	// reset dom since alignment style may have changed
	if (this._textCell) {
		this._row.removeChild(this._textCell);
		this._textCell = null;
		this.setText(this._text.data)
	}
	if (this._imageCell) {
		this._row.removeChild(this._imageCell);
		this._imageCell = null;
		this._setImage(this._imageInfo);
	}
}

// Private methods

// Set the label's image, and manage its placement.
DwtLabel.prototype._setImage =
function(imageInfo) {
	if (!imageInfo) {
		if (this._imageCell) {
			var cellIndex = Dwt.getCellIndex(this._imageCell);
			this._row.deleteCell(cellIndex);
			this._imageCell = null;
		}
	} else {
		var idx;
		if (!this._imageCell) {
			if (this._style & DwtLabel.IMAGE_LEFT) {
				idx = 0;
			} else {
				idx = this._textCell ? 1 : 0;
			}
			this._imageCell = this._row.insertCell(idx);
			this._doAlign();
		}
		AjxImg.setImage(this._imageCell, imageInfo);
	}	
}

// Handle the alignment style.
DwtLabel.prototype._doAlign =
function() {
	if (this._style & DwtLabel.ALIGN_CENTER) {
		if (this._imageCell != null && this._textCell != null) {
			// XXX: this doesnt seem right (no pun intended)
			if (this._style & DwtLabel.IMAGE_LEFT) {
				this._imageCell.align = "right";
				this._textCell.align = "left";
			} else {
				this._imageCell.align = "left";
				this._textCell.align = "right";
			}
		} else if (this._imageCell != null) {
			this._imageCell.align = "center";
		} else if (this._textCell != null) {
			this._textCell.align = "center";
		}
	}
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtListView(parent, className, posStyle, headerList, noMaximize) {

	if (arguments.length == 0) return;
	className = className || "DwtListView";
	DwtComposite.call(this, parent, className, posStyle);

	if (headerList) {
		var htmlElement = this.getHtmlElement();

		this._listColDiv = document.createElement("div");
		this._listColDiv.id = Dwt.getNextId();
		this._listColDiv.className = "DwtListView-ColHeader";
		htmlElement.appendChild(this._listColDiv);

		this._listDiv = document.createElement("div");
		this._listDiv.id = Dwt.getNextId();
		this._listDiv.className = "DwtListView-Rows";
		htmlElement.appendChild(this._listDiv);

		// setup vars needed for sorting
		this._bSortAsc = false;
		this._currentColId = null;
		this._sortingEnabled = true;
	} else {
		this.setScrollStyle(DwtControl.SCROLL); // auto scroll
	}
		
	this._setMouseEventHdlrs();
	this.setCursor("default");

	this._listenerMouseOver = new AjxListener(this, this._mouseOverListener);
	this._listenerMouseOut = new AjxListener(this, this._mouseOutListener);
	this._listenerMouseDown = new AjxListener(this, this._mouseDownListener);
	this._listenerMouseUp = new AjxListener(this, this._mouseUpListener);
	this._listenerMouseMove = new AjxListener(this, this._mouseMoveListener);
	this._listenerDoubleClick = new AjxListener(this, this._doubleClickListener);
	this.addListener(DwtEvent.ONMOUSEOVER, this._listenerMouseOver);
	this.addListener(DwtEvent.ONMOUSEOUT, this._listenerMouseOut);
	this.addListener(DwtEvent.ONMOUSEDOWN, this._listenerMouseDown);
	this.addListener(DwtEvent.ONMOUSEUP, this._listenerMouseUp);
	this.addListener(DwtEvent.ONMOUSEMOVE, this._listenerMouseMove);
	this.addListener(DwtEvent.ONDBLCLICK, this._listenerDoubleClick);

	this._evtMgr = new AjxEventMgr();
	this._selectedItems = new AjxVector();
	this._selAnchor = null; 
	this._selEv = new DwtSelectionEvent(true);
	this._actionEv = new DwtListViewActionEvent(true);
	this._stateChangeEv = new DwtEvent(true);
	this._headerList = headerList;
	this._noMaximize = noMaximize;
	this._parentEl = this._headerList ? this._listDiv : this.getHtmlElement();
	
	this._list = null;
	this._offset = 0;
	this._headerColCreated = false;
	this._firstSelIndex = -1;

	this.setMultiSelect(true);
}

DwtListView.ITEM_SELECTED 		= 1;
DwtListView.ITEM_DESELECTED 	= 2;
DwtListView.ITEM_DBL_CLICKED 	= 3;
DwtListView._LAST_REASON 		= 3;

DwtListView._TOOLTIP_DELAY 		= 250;

DwtListView.HEADERITEM_HEIGHT 	= 24;
DwtListView.HEADERITEM_ARROW  	= "arr--";
DwtListView.HEADER_ID			= "crr--";
DwtListView.HEADERITEM_LABEL 	= "drr--";

DwtListView.TYPE_HEADER_ITEM 	= "1";
DwtListView.TYPE_LIST_ITEM 		= "2";
DwtListView.TYPE_HEADER_SASH 	= "3";

DwtListView.DEFAULT_LIMIT = 25;
DwtListView.MAX_REPLENISH_THRESHOLD = 10;
DwtListView.MIN_COLUMN_WIDTH = 10;
DwtListView.COL_MOVE_THRESHOLD = 3;

DwtListView.prototype = new DwtComposite;
DwtListView.prototype.constructor = DwtListView;

DwtListView.prototype.toString = 
function() {
	return "DwtListView";
}

DwtListView.prototype.setEnabled = 
function(enabled) {
	DwtComposite.prototype.setEnabled.call(this, enabled);
	// always remove listeners to avoid adding listeners multiple times
	this.removeListener(DwtEvent.ONMOUSEOVER, this._listenerMouseOver);
	this.removeListener(DwtEvent.ONMOUSEOUT, this._listenerMouseOut);
	this.removeListener(DwtEvent.ONMOUSEDOWN, this._listenerMouseDown);
	this.removeListener(DwtEvent.ONMOUSEUP, this._listenerMouseUp);
	this.removeListener(DwtEvent.ONMOUSEMOVE, this._listenerMouseMove);
	this.removeListener(DwtEvent.ONDBLCLICK, this._listenerDoubleClick);
	// now re-add listeners, if needed
	if (enabled) {
		this.addListener(DwtEvent.ONMOUSEOVER, this._listenerMouseOver);
		this.addListener(DwtEvent.ONMOUSEOUT, this._listenerMouseOut);
		this.addListener(DwtEvent.ONMOUSEDOWN, this._listenerMouseDown);
		this.addListener(DwtEvent.ONMOUSEUP, this._listenerMouseUp);
		this.addListener(DwtEvent.ONMOUSEMOVE, this._listenerMouseMove);
		this.addListener(DwtEvent.ONDBLCLICK, this._listenerDoubleClick);
	}
	// modify selection classes
	var selection = this.getSelectedItems();
	if (selection) {
		var elements = selection.getArray();
		for (var i = 0; i < elements.length; i++) {
			var element = elements[i];
			element.className = enabled 
				? Dwt.getAttr(element, "_selectedStyleClass") 
				: Dwt.getAttr(element, "_selectedDisabledStyleClass");
		}
	}
}

DwtListView.prototype.createHeaderHtml = 
function(defaultColumnSort) {

	// does this list view have headers or have they already been created?
	if (!this._headerList || this._headerColCreated)
		return;
	
	var idx = 0;
	var htmlArr = new Array();
	this._headerTableId = DwtListView.HEADER_ID + Dwt.getNextId();

	htmlArr[idx++] = "<table id='" + this._headerTableId + "' cellpadding=0 cellspacing=0 border=0 height=100%";
	htmlArr[idx++] = this._noMaximize ? ">" : " width=100%>";
	htmlArr[idx++] = "<tr>";
	for (i = 0; i < this._headerList.length; i++) {
		var headerCol = this._headerList[i];
		if (!headerCol._visible)
			continue;
			
		htmlArr[idx++] = "<td id='" + headerCol._id + "' class='";
		htmlArr[idx++] = headerCol._id == this._currentColId
			? "DwtListView-Column DwtListView-ColumnActive'"
			: "DwtListView-Column'";
		htmlArr[idx++] = headerCol._width ? " width=" + headerCol._width + ">" : ">";
		// must add a div to force clipping :(
		htmlArr[idx++] = "<div";
		htmlArr[idx++] = headerCol._width ? (" style='width: " + (headerCol._width+2) + "'>") : ">";

		// add new table for icon/label/sorting arrow		
		htmlArr[idx++] = "<table border=0 cellpadding=0 cellspacing=0 width=100%><tr>";
		if (headerCol._iconInfo) {
			htmlArr[idx++] = "<td><center>";
			htmlArr[idx++] = AjxImg.getImageHtml(headerCol._iconInfo);
			htmlArr[idx++] = "</center></td>";
		}
			
		if (headerCol._label)
			htmlArr[idx++] = "<td id='" + DwtListView.HEADERITEM_LABEL + headerCol._id + "'>&nbsp;" + headerCol._label + "</td>";
		
		if (headerCol._sortable) {
			var arrowIcon = this._bSortAsc ? "ColumnUpArrow" : "ColumnDownArrow";
			var id = DwtListView.HEADERITEM_ARROW + headerCol._id;
			if (headerCol._sortable == defaultColumnSort) {
				this._currentColId = headerCol._id;
				htmlArr[idx++] = "<td width=10 id='" + id + "'>" + AjxImg.getImageHtml(arrowIcon) + "</td>";
			} else {
				htmlArr[idx++] = "<td width=10 id='" + id + "'>" + AjxImg.getImageHtml(arrowIcon, "visibility:hidden") + "</td>";
			}
		}
		
		// ALWAYS add "sash" separators
		htmlArr[idx++] = "<td width=4>";
		htmlArr[idx++] = "<table align=right border=0 cellpadding=0 cellspacing=0 width=2 height=100%><tr>";
		htmlArr[idx++] = "<td class='DwtListView-Sash'><div style='width: 1px; height: " + (DwtListView.HEADERITEM_HEIGHT-2) + "px; background-color: #8A8A8A'></div></td>";
		htmlArr[idx++] = "<td class='DwtListView-Sash'><div style='width: 1px; height: " + (DwtListView.HEADERITEM_HEIGHT-2) + "px; background-color: #FFFFFF'></div></td>";
		htmlArr[idx++] = "</tr></table>";
		htmlArr[idx++] = "</td>";

		htmlArr[idx++] = "</tr></table>";
		htmlArr[idx++] = "</div></td>";
	}
	htmlArr[idx++] = "</tr>";
	htmlArr[idx++] = "</table>";

	this._listColDiv.innerHTML = htmlArr.join("");

	// for each sortable column, sets its identifier
	for (var j = 0; j < this._headerList.length; j++) {
		var cell = document.getElementById(this._headerList[j]._id);
		if (cell == null) continue;
		
		var sortable = this._headerList[j]._sortable;
		if (sortable && sortable == defaultColumnSort)
			cell.className = "DwtListView-Column DwtListView-ColumnActive";

		var isResizeable = this._headerList[j]._resizeable;
		if (isResizeable) {
			// always get the sibling cell to the right
			var sashCell = cell.firstChild.firstChild.rows[0].lastChild;
			if (sashCell) {
				sashCell._type = DwtListView.TYPE_HEADER_SASH;
				sashCell._itemIndex = j + "--sash";
			}
		}

		cell._isSortable = sortable != null;
		cell._isResizeable = isResizeable;
		cell._type = DwtListView.TYPE_HEADER_ITEM;
		cell._itemIndex = j;
	}
	
	this._headerColCreated = true;
}


// this returns the index into the header list array for the given Id
DwtListView.prototype.getColIndexForId = 
function(headerId) {
	if (this._headerList) {
		for (var i = 0; i < this._headerList.length; i++) {
			if (this._headerList[i]._id.indexOf(headerId) != -1)
				return i;
		}
	}
	return -1;
};

/**
* Creates a list view out of the given vector of items. The derived class should override _createItemHtml()
* in order to display an item.
*
* @param list	a vector of items (AjxVector)
* @param defaultColumnSort	default column field to sort (optional)
*/
DwtListView.prototype.set =
function(list, defaultColumnSort) {
	
	this._selectedItems.removeAll();
	this.enableSorting(true);
	this._resetList();
	this._list = list;
	this._now = new Date();
	this.setUI(defaultColumnSort);
}

/**
* Renders the list view using the current list of items.
*
* @param defaultColumnSort		[string]	ID of column that represents default sort order
* @param noResultsOk			[boolean]*	if true, don't show "No Results" for empty list
*/
DwtListView.prototype.setUI =
function(defaultColumnSort, noResultsOk) {
	this.removeAll();
	this.createHeaderHtml(defaultColumnSort);
	this._renderList(this._list, noResultsOk);
}

DwtListView.prototype._renderList =
function(list, noResultsOk) {
	if (list instanceof AjxVector && list.size()) {
		var size = list.size();
		for (var i = 0; i < size; i++) {
			var item = list.get(i);
			var div = this._createItemHtml(item, this._now);
			if (div) {
				if (div instanceof Array) {
					for (var j = 0; j < div.length; j++){
						this._addRow(div[j]);
					}
				} else {
					this._addRow(div);
				}
			}
		}
	} else if (!noResultsOk) {
		this._setNoResultsHtml();
	}
};

DwtListView.prototype.addItems =
function(itemArray, index) {
	if (AjxUtil.isArray(itemArray)){
		if (!this._list) {
			this._list = new AjxVector();
		}
	
		// clear the "no results" message before adding!
		if (this._list.size() == 0) {
			this._resetList();
		}
		var currentSize = this._list.size();
		var vec = AjxVector.fromArray(itemArray);
		this._renderList(vec);
		this._list.addList(itemArray);
	}
};

DwtListView.prototype.addItem =
function(item, index, skipNotify) {
	if (!this._list)
		this._list = new AjxVector();
	
	// clear the "no results" message before adding!
	if (this._list.size() == 0)
		this._resetList();
	
	this._list.add(item, index);
	var div = this._createItemHtml(item, this._now);
	if (div)
		this._addRow(div, index);
		
	if (!skipNotify && this._evtMgr.isListenerRegistered(DwtEvent.STATE_CHANGE)) {
		this._evtMgr.notifyListeners(DwtEvent.STATE_CHANGE, this._stateChangeEv);
	}
}

DwtListView.prototype.removeItem =
function(item, skipNotify) {
	var itemEl = this._getElFromItem(item);
	this._selectedItems.remove(itemEl);
	this._parentEl.removeChild(itemEl);
	this._list.remove(item);
		
	if (!skipNotify && this._evtMgr.isListenerRegistered(DwtEvent.STATE_CHANGE)) {
		this._evtMgr.notifyListeners(DwtEvent.STATE_CHANGE, this._stateChangeEv);
	}
}

DwtListView.prototype.removeLastItem =
function(skipNotify) {
	var last = this._list.get(this._list.size() - 1);
	this._list.remove(last);
	this._parentEl.removeChild(this._getElFromItem(last));
		
	if (!skipNotify && this._evtMgr.isListenerRegistered(DwtEvent.STATE_CHANGE)) {
		this._evtMgr.notifyListeners(DwtEvent.STATE_CHANGE, this._stateChangeEv);
	}
}

DwtListView.prototype.reIndexColumn = 
function(columnIdx, newIdx) {
	// do some sanity checks before continuing
	if (this._headerList == null) 
		return;
	var len = this._headerList.length;
	if (columnIdx < 0 || newIdx < 0 || columnIdx >= len || newIdx >= len || columnIdx == newIdx)
		return;

	// reindex the header list
	var temp = this._headerList.splice(columnIdx, 1);
	this._headerList.splice(newIdx, 0, temp[0]);
	
	// finally, relayout the list view (incl. header columns)
	this._relayout();
}

DwtListView.prototype.reSizeColumn = 
function(headerIdx, newWidth) {
	// TODO: do some (more?) sanity checks before changing the header width
	if (newWidth == this._headerList._width || newWidth < DwtListView.MIN_COLUMN_WIDTH)
		return;

	this._headerList[headerIdx]._width = newWidth;
	this._relayout();
}

// determine if col header needs padding to accomodate for scrollbars
DwtListView.prototype._resetColWidth =
function() {
	if (this._headerList == null)
		return;
	
	// dynamically get col idx for last column (b/c col may or may not be turned on)
	var count = this._headerList.length-1;
	var lastColIdx = null;
	while (lastColIdx == null && count >= 0) {
		if (this._headerList[count]._visible)
			lastColIdx = count;
		count--;
	}

	var lastCell = document.getElementById(this._headerList[lastColIdx]._id);
	var div = lastCell.firstChild;
	var scrollbarPad = 16;
	
	var headerWidth = this._listColDiv.clientWidth;
	var rowWidth = this._listDiv.clientWidth;
	
	if (headerWidth != rowWidth) {
		lastCell.style.width = div.style.width = this._headerList[lastColIdx]._width
			? (this._headerList[lastColIdx]._width + scrollbarPad)
			: (lastCell.clientWidth + scrollbarPad);
	} else {
		lastCell.style.width = div.style.width = (this._headerList[lastColIdx]._width || "");
	}
}

DwtListView.prototype.size =
function() {
	if(this._list) {
		return this._list.size();
	} else {
		return 0;
	}
}

DwtListView.prototype.setMultiSelect = 
function (enabled) {
	this._multiSelectEnabled = enabled;
};

DwtListView.prototype.isMultiSelectEnabled =
function () {
	return this._multiSelectEnabled;
};

// safari breaks w/ clicking on scrollbar in list views so we do this:
DwtListView.prototype.getPropagationForEvent = 
function() {
	if (AjxEnv.isSafari) {
		return false;
	} else {
		return DwtControl.prototype.getPropagationForEvent.call(this);
	}
}

// safari breaks w/ clicking on scrollbar in list views so we do this:
DwtListView.prototype.getReturnValueForEvent = 
function() {
	if (AjxEnv.isSafari) {
		return true;
	} else {
		return DwtControl.prototype.getReturnValueForEvent.call(this);
	}
}

DwtListView.prototype._addRow =
function(row, index) {
	// bug fix #1894 - check for childNodes length otherwise IE barfs
	if (index != null && this._parentEl.childNodes.length > 0)
		this._parentEl.insertBefore(row, this._parentEl.childNodes[index]);
	else
		this._parentEl.appendChild(row);
}

/**
* Renders a single item as a DIV element.
*
* Default implementation creates a simple div with the innerHTML set to 
* the string value of the item.
*/
DwtListView.prototype._createItemHtml = 
function(item, now, isDnDIcon) {
	var div = document.createElement("DIV");
	div.id = Dwt.getNextId();
	var rowClassName = AjxBuffer.concat(this._className, "Row");
	div._styleClass = AjxBuffer.concat("Row ",rowClassName);
	div._selectedStyleClass = AjxBuffer.concat("Row-", DwtCssStyle.SELECTED, " ", rowClassName);
	div._selectedDisabledStyleClass = AjxBuffer.concat("Row-", DwtCssStyle.SELECTED, "-" , DwtCssStyle.DISABLED, " ", rowClassName);
	div.className = div._styleClass;
	if (typeof(item) == "object") {
		div.innerHTML = AjxStringUtil.htmlEncode(item.toString());
	} else {
		div.innerHTML = AjxStringUtil.htmlEncode(String(item));
	}
	this.associateItemWithElement(item, div, DwtListView.TYPE_LIST_ITEM);
	return div;
}

DwtListView.prototype._setNoResultsHtml = 
function() {
	var htmlArr = new Array(5);
	var	div = document.createElement("div");
	var idx = 0;

	htmlArr[idx++] = "<table width='100%' cellspacing='0' cellpadding='1'>";
	htmlArr[idx++] = "<tr><td class='NoResults'><br>";
	htmlArr[idx++] = AjxMsg.noResults;
	htmlArr[idx++] = "</td></tr></table>";

	div.innerHTML = htmlArr.join("");

	this._addRow(div);
}

DwtListView.prototype.addSelectionListener = 
function(listener) {
	this._evtMgr.addListener(DwtEvent.SELECTION, listener);
}

DwtListView.prototype.removeSelectionListener = 
function(listener) {
	this._evtMgr.removeListener(DwtEvent.SELECTION, listener);    	
}

DwtListView.prototype.addActionListener = 
function(listener) {
	this._evtMgr.addListener(DwtEvent.ACTION, listener);
}

DwtListView.prototype.removeActionListener = 
function(listener) {
	this._evtMgr.removeListener(DwtEvent.ACTION, listener);    	
}

DwtListView.prototype.addStateChangeListener = function(listener) {
	this._evtMgr.addListener(DwtEvent.STATE_CHANGE, listener);
}
DwtListView.prototype.removeStateChangeListener = function(listener) {
	this._evtMgr.removeListener(DwtEvent.STATE_CHANGE, listener);
}

DwtListView.prototype.removeAll =
function(skipNotify) {
	this._parentEl.innerHTML = "";
	this._selectedItems.removeAll();
	this._selAnchor = null;
		
	if (!skipNotify && this._evtMgr.isListenerRegistered(DwtEvent.STATE_CHANGE)) {
		this._evtMgr.notifyListeners(DwtEvent.STATE_CHANGE, this._stateChangeEv);
	}
}

DwtListView.prototype.deselectAll =
function() {
	var a = this._selectedItems.getArray();
	var sz = this._selectedItems.size();
	for (var i = 0; i < sz; i++)
		a[i].className = Dwt.getAttr(a[i], "_styleClass");
	this._selectedItems.removeAll();
	this._selAnchor = null;
}

DwtListView.prototype.getDnDSelection =
function() {
	if (this._dndSelection instanceof AjxVector) {
		return this.getSelection();
	} else {
		return AjxCore.objectWithId(this._dndSelection);
	}
}

DwtListView.prototype.getSelection =
function() {
	var a = new Array();
	if (this._rightSelItems) {
		a.push(AjxCore.objectWithId(Dwt.getAttr(this._rightSelItems, "_itemIndex")));
	} else {
		var sa = this._selectedItems.getArray();
		var saLen = this._selectedItems.size();
		for (var i = 0; i < saLen; i++)
			a[i] = AjxCore.objectWithId(Dwt.getAttr(sa[i], "_itemIndex"));
	}
	return a;
}

DwtListView.prototype.getSelectedItems =
function() {
	return this._selectedItems;
}

DwtListView.prototype.setSelection =
function(item, skipNotify) {
	var el = this._getElFromItem(item);
	if (el) {
		var i;
		this._deselectAllSelectedItems();
		this._selectedItems.add(el);
		this._selAnchor = el;
		el.className = this.getEnabled() 
			? Dwt.getAttr(el, "_selectedStyleClass") 
			: Dwt.getAttr(el, "_selectedDisabledStyleClass");

		// reset the selected index
		this._firstSelIndex = this._list && this._list.size() > 0
			? this._list.indexOf(item) : -1;

		if (!skipNotify && this._evtMgr.isListenerRegistered(DwtEvent.SELECTION)) {
			var selEv = new DwtSelectionEvent(true);
			selEv.button = DwtMouseEvent.LEFT;
			selEv.target = el;
			selEv.item = AjxCore.objectWithId(Dwt.getAttr(el, "_itemIndex"));
			selEv.detail = DwtListView.ITEM_SELECTED;
			this._evtMgr.notifyListeners(DwtEvent.SELECTION, selEv);
		}	
	}
}

DwtListView.prototype._deselectAllSelectedItems =
function() {
	var a = this._selectedItems.getArray();
	var sz = this._selectedItems.size();
	for (i = 0; i < sz; i++) {
		a[i].className = Dwt.getAttr(a[i], "_styleClass");
	}
	this._selectedItems.removeAll();
};

DwtListView.prototype.setSelectedItems =
function(selectedArray) {
	this._deselectAllSelectedItems();
	var i, sz, el;
	sz = selectedArray.length;
	for (i = 0; i < sz; ++i) {
		el = this._getElFromItem(selectedArray[i]);
		if (el) {
			el.className = this.getEnabled() 
				? Dwt.getAttr(el, "_selectedStyleClass")
				: Dwt.getAttr(el, "_selectedDisabledStyleClass");
			this._selectedItems.add(el);
		}
	}
};

DwtListView.prototype.getSelectionCount =
function() {
	return this._rightSelItems ? 1 : this._selectedItems.size();
}

DwtListView.prototype.handleActionPopdown = 
function() {
	// clear out old right click selection
	if (this._rightSelItems) {
		this._rightSelItems.className = Dwt.getAttr(this._rightSelItems, "_styleClass");
		this._rightSelItems = null;
	}
}

DwtListView.prototype._getItemId =
function(item) {
	return item ? (this._getViewPrefix() + item.id) : null;
}

DwtListView.prototype._getHeaderTableId = 
function() {
	return this._headerList ? this._headerTableId : null;
}

DwtListView.prototype._getElFromItem = 
function(item) {
	var childNodes = this._parentEl.childNodes;
	var len = childNodes.length;
	var comparisonId = this._getItemId(item);
	for (var i = 0; i < len; i++) {
		if (childNodes[i].id == comparisonId)
			return childNodes[i];
	}
	return null;
}

DwtListView.prototype._getItemIndex = 
function(item) {
	var list = this._list;
	var len = list.size();
	for (var i = 0; i < len; ++i){
		if (list.get(i).id == item.id){
			return i;
		}
	}
}

DwtListView.prototype.getItemFromElement =
function(element) {
	var itemIdx = Dwt.getAttr(element, "_itemIndex");
	if (itemIdx !== void 0) {
		if (Dwt.getAttr(element, "_type") == DwtListView.TYPE_LIST_ITEM)
			return AjxCore.objectWithId(itemIdx);
	}
	return null;
}

DwtListView.prototype._getViewPrefix = 
function() {
	return "";
}

DwtListView.prototype.associateItemWithElement =
function(item, element, type, optionalId) {
	element.id = optionalId ? optionalId : this._getItemId(item);
	element._itemIndex = AjxCore.assignId(item);
	element._type = type;
}

/* Return true only if the event occurred in one of our Divs
 * See DwtControl for more info */
DwtListView.prototype._isValidDragObject =
function(ev) {
	var div = ev.target;
	div = this._findAncestor(div, "_itemIndex");
	return (div != null);
}

DwtListView.prototype.dragSelect =
function(row) {
	// If we have something previously selected, try and remove the selection
	if (this._dragHighlight != null) {
		var oldRow = document.getElementById(this._dragHighlight);
		// only go forward if the row doesn't exist, or if the new selection
		// is different from the old selection.
		// In the case where a header item is dragged over, the row might be 
		// null or void.
		if (!row || row.id != oldRow.id){
			this._updateDragSelection(oldRow, false);
		}
	}
	// Don't try and select if we are over a header item
	if (!row || Dwt.getAttr(row, "_type") != DwtListView.TYPE_LIST_ITEM) return;
	
	// Try and select only if the new row is different from the currently
	// highlighted row.
	if (row.id != this._dragHighlight){
		this._dragHighlight = row.id;
		this._updateDragSelection(row, true);
	}
}

DwtListView.prototype.dragDeselect =
function(row) {
	if (this._dragHighlight) {
		var oldRow = document.getElementById(this._dragHighlight);
		this._updateDragSelection(oldRow, false);
		this._dragHighlight = null;
	}
}

DwtListView.prototype._updateDragSelection =
function(row, select) {
	if (!select){
		row.className = row._dwtListViewOldClassName;
	} else {
		row._dwtListViewOldClassName = row.className;
		row.className = row.className + "-drag";
	}
}

DwtListView.prototype._mouseOverAction = 
function(mouseEv, div) {
	var type = Dwt.getAttr(div, "_type");
	if ((type == DwtListView.TYPE_HEADER_ITEM) && this._sortingEnabled && div._isSortable && this._headerClone == null) {
		div.className = "DwtListView-Column DwtListView-ColumnHover";
	} else if (type == DwtListView.TYPE_HEADER_SASH) {
		div.style.cursor = AjxEnv.isIE ? "col-resize" : "e-resize";
	} else if (type == DwtListView.TYPE_LIST_ITEM) {
		if (div._hoverStyleClass == null || div == this._rightSelItems) {
			div.hoverSet = false;
		} else {
			var selItems = this._selectedItems.getArray();
			div.hoverSet = true;
			for (var i = 0; i < selItems.length; i++) {
				if (div == selItems[i]) {
					div.hoverSet = false;
					break;
				}
			}
		}
		if (div.hoverSet)
			div.className += " " + div._hoverStyleClass;
	}

	return true;
}

DwtListView.prototype._mouseOutAction = 
function(mouseEv, div) {
	var type = Dwt.getAttr(div, "_type");
	if (type == DwtListView.TYPE_HEADER_ITEM && this._headerClone == null) {
		div.className = div.id != this._currentColId 
			? "DwtListView-Column" 
			: "DwtListView-Column DwtListView-ColumnActive";
	} else if (type == DwtListView.TYPE_HEADER_SASH) {
		div.style.cursor = "auto";
	} else if (type == DwtListView.TYPE_LIST_ITEM) {
		if (div._hoverStyleClass && div.hoverSet)
			div.className = Dwt.getAttr(div, "_styleClass");
	}

	return true;
}

DwtListView.prototype._mouseOverListener = 
function(ev) {
	var div = ev.target;
	div = this._findAncestor(div, "_itemIndex");
	if (!div)
		return;
	
	this._mouseOverAction(ev, div);
}

DwtListView.prototype._mouseOutListener = 
function(ev) {
	var div = ev.target;
	div = this._findAncestor(div, "_itemIndex");
	if (!div)
		return;
	// NOTE: The DwtListView handles the mouse events on the list items
	//		 that have associated tooltip text. Therefore, we must
	//		 explicitly null out the tooltip content whenever we handle
	//		 a mouse out event. This will prevent the tooltip from
	//		 being displayed when we re-enter the listview even though
	//		 we're not over a list item.
	this._toolTipContent = null;
	this._mouseOutAction(ev, div);
}

DwtListView.prototype._mouseMoveListener = 
function(ev) {
	if (this._clickDiv == null)
		return;

	var type = Dwt.getAttr(this._clickDiv, "_type");
	if (type == DwtListView.TYPE_HEADER_ITEM) {
		this._handleColHeaderMove(ev);
	} else if (type == DwtListView.TYPE_HEADER_SASH) {
		this._handleColHeaderResize(ev);
	}
}

DwtListView.prototype._mouseUpAction = 
function(mouseEv, div) {
	return true;
}

DwtListView.prototype._findAncestor =
function(elem, attr) {
	while (elem && (Dwt.getAttr(elem, attr) == void 0))
		elem = elem.parentNode;
	return elem;
}

DwtListView.prototype._mouseDownListener = 
function(ev) {
	var div = ev.target;
	div = this._findAncestor(div, "_itemIndex");

	if (div == null){
		this._dndSelection = null;
	} else {
		this._clickDiv = div;

		if (Dwt.getAttr(div, "_type") != DwtListView.TYPE_LIST_ITEM) {
			this._dndSelection = null;
		} else {
			this._dndSelection = (this._selectedItems.contains(div)) 
				? this._selectedItems 
				: Dwt.getAttr(div, "_itemIndex");
		}
	}
}

DwtListView.prototype._mouseUpListener = 
function(ev) {
	var div = ev.target;
	div = this._findAncestor(div, "_itemIndex");

	var wasDraggingCol = this._handleColHeaderDrop(ev);
	var wasDraggingSash = this._handleColSashDrop(ev);
	
	if (!div || div != this._clickDiv || 
		wasDraggingCol || wasDraggingSash) 
	{
		delete this._clickDiv;
		return;
	}
	delete this._clickDiv;

	var type = Dwt.getAttr(div, "_type");
	if (this._headerList && type == DwtListView.TYPE_HEADER_ITEM) {
		if (div._isSortable && this._sortingEnabled && ev.button == DwtMouseEvent.LEFT) {
			this._columnClicked(div, ev);
		} else if (ev.button == DwtMouseEvent.RIGHT) {
			var actionMenu = this._getActionMenuForColHeader();
			if (actionMenu && actionMenu instanceof DwtMenu)
				actionMenu.popup(0, ev.docX, ev.docY);
		}
	} else if (type == DwtListView.TYPE_LIST_ITEM) {
		// set item selection, then hand off to derived class for handling
		if (ev.button == DwtMouseEvent.LEFT || ev.button == DwtMouseEvent.RIGHT)
			this._itemClicked(div, ev);
			
		if (!this._mouseUpAction(ev, div))
			return;
	}
}

DwtListView.prototype._doubleClickAction = 
function(mouseEv, div) {return true;}

DwtListView.prototype._doubleClickListener =
function(ev) {
	var div = ev.target;
	div = this._findAncestor(div, "_itemIndex");

	if (!div) return;

	if (Dwt.getAttr(div, "_type") == DwtListView.TYPE_LIST_ITEM) {
		if (!this._doubleClickAction(ev, div))
			return;
		if (this._evtMgr.isListenerRegistered(DwtEvent.SELECTION)) {
			DwtUiEvent.copy(this._selEv, ev);
			this._selEv.item = this.getItemFromElement(div);
			this._selEv.detail = DwtListView.ITEM_DBL_CLICKED;
			this._evtMgr.notifyListeners(DwtEvent.SELECTION, this._selEv);
		}
	}
}

DwtListView.prototype.emulateDblClick = 
function(item) {
	var div = document.getElementById(this._getItemId(item));
	if (div) {
		var ev = new Object();
		ev.target = div;
		ev.button = DwtMouseEvent.LEFT;
		
		this._itemClicked(div, ev);
		this._doubleClickListener(ev);
	}
}

DwtListView.prototype._itemClicked =
function(clickedEl, ev) {
	var i;
	var a = this._selectedItems.getArray();
	var numSelectedItems = this._selectedItems.size();

	// always clear out old right click selection
	if (this._rightSelItems) {
		this._rightSelItems.className = Dwt.getAttr(this._rightSelItems, "_styleClass");
		this._rightSelItems = null;
	}

	if ((!ev.shiftKey && !ev.ctrlKey) || !this.isMultiSelectEnabled()) {
		// always reset detail if left/right click
		if (ev.button == DwtMouseEvent.LEFT || ev.button == DwtMouseEvent.RIGHT)
			this._selEv.detail = DwtListView.ITEM_SELECTED;
		
		// is this element currently in the selected items list?
		var bContained = this._selectedItems.contains(clickedEl);
		
		if (ev.button == DwtMouseEvent.LEFT) {
			if (this._allowLeftSelection(clickedEl, ev, ev.button)) {
				// clear out old left click selection(s)
				for (i = 0; i < numSelectedItems; i++)
					a[i].className = Dwt.getAttr(a[i], "_styleClass");
				this._selectedItems.removeAll();
				
				// save new left click selection
				this._selectedItems.add(clickedEl);
				this._selAnchor = clickedEl;
				clickedEl.className = Dwt.getAttr(clickedEl, "_selectedStyleClass");
				this._firstSelIndex = this._list 
					? this._list.indexOf(AjxCore.objectWithId(Dwt.getAttr(clickedEl, "_itemIndex"))) : -1;
			}
		} else if (ev.button == DwtMouseEvent.RIGHT && !bContained) {
			// save right click selection
			this._rightSelItems = clickedEl;
			clickedEl.className = Dwt.getAttr(clickedEl, "_selectedStyleClass") + "-right";
		}
		clickedEl.hoverSet = false;
	} else {
		if (ev.ctrlKey) {
			if (this._selectedItems.contains(clickedEl)) {
				this._selectedItems.remove(clickedEl);
				clickedEl.className = Dwt.getAttr(clickedEl, "_styleClass");
				this._selEv.detail = DwtListView.ITEM_DESELECTED;
			} else {
				this._selectedItems.add(clickedEl);
				clickedEl.className = Dwt.getAttr(clickedEl, "_selectedStyleClass");
				clickedEl.hoverSet = false;
				this._selEv.detail = DwtListView.ITEM_SELECTED;
			}
			// The element that was part of the ctrl action always becomes
			// the anchor since it gets focus
			this._selAnchor = clickedEl;
		} else { // SHIFT KEY
			// Adds to the selection to/from the current node to the selection anchor
			if (this._selAnchor == null)
				return;				
			var convEls = this._getChildren() || clickedEl.parentNode.childNodes;
			var numConvEls = convEls.length;
			var convEl;
			var state = 0;
			for (i = 0; i < numConvEls; i++) {
				convEl = convEls[i];
				if (convEl == this._rightSelItems)
					this._rightSelItems = null;
				
				if (convEl == clickedEl) {
					/* Increment the state. 
					 * 0 - means we havent started
					 * 1 - means we are in selection range
					 * 2 - means we are out of selection range */
					state++;
				}
				var selStyleClass = Dwt.getAttr(convEl, "_selectedStyleClass");
				if (convEl == this._selAnchor) {
					state++;
					if (convEl.className != selStyleClass) {
						convEl.className = selStyleClass;
						this._selectedItems.add(convEl);
					}
					continue;
				}
				
				// If state == 0 or 2 (i.e. we are out of the selection range, 
				// we have to deselect the node. Else we select it
				if (state != 1 && convEl.className == selStyleClass && convEl != clickedEl) {
					convEl.className = Dwt.getAttr(convEl, "_styleClass");
					this._selectedItems.remove(convEl);
				} else if (state == 1 || convEl == clickedEl) {
					if (convEl.className != selStyleClass) {
						convEl.className = selStyleClass;
						convEl.hoverSet = false;
						this._selectedItems.add(convEl);
					}
				}
			}
			var newSelectedItems = this._selectedItems.size();
			if (numSelectedItems < newSelectedItems)
				this._selEv.detail = DwtListView.ITEM_SELECTED;
			else if (numSelectedItems > newSelectedItems)
				this._selEv.detail = DwtListView.ITEM_DESELECTED;
			else
				return;
		}
	}

	if (ev.button == DwtMouseEvent.LEFT && this._evtMgr.isListenerRegistered(DwtEvent.SELECTION)) {
		if (this._setListEvent(ev, this._selEv, clickedEl))
			this._evtMgr.notifyListeners(DwtEvent.SELECTION, this._selEv);
	} else if (ev.button == DwtMouseEvent.RIGHT && this._evtMgr.isListenerRegistered(DwtEvent.ACTION)) {
		if (this._setListEvent(ev, this._actionEv, clickedEl))
			this._evtMgr.notifyListeners(DwtEvent.ACTION, this._actionEv);
	}
}

/*
* Creates a list event from a mouse event. Returns true if it is okay to notify listeners.
* Subclasses may override to add more properties to the list event.
*
* @param	[DwtEvent]		mouse event
* @param	[DwtEvent]		list event (selection or action)
* @param	[element]		HTML element that received mouse click
*/
DwtListView.prototype._setListEvent =
function(ev, listEv, clickedEl) {
	DwtUiEvent.copy(listEv, ev);
	listEv.item = AjxCore.objectWithId(Dwt.getAttr(clickedEl, "_itemIndex"));
	return true;
};

DwtListView.prototype._columnClicked =
function(clickedCol, ev) {
	
	var list = this.getList();
	if (!list) return;
	var size = list.size();
	if (!size) return;

	var item = this._headerList[Dwt.getAttr(clickedCol, "_itemIndex")];
	// reset order by sorting preference
	this._bSortAsc = item._id == this._currentColId	? !this._bSortAsc : this._getDefaultSortbyForCol(item);
	
	// reset arrows as necessary
	this._setSortedColStyle(item._id);

	// call sorting callback if more than one item to sort
	if (size >= 1){
		this._sortColumn(item, this._bSortAsc);
	}
}

DwtListView.prototype._sortColumn = 
function(columnItem, bSortAsc) {
	// overload me
}

DwtListView.prototype._getActionMenuForColHeader = 
function() {
	// overload me if you want action menu for column headers
	return null;
}

DwtListView.prototype._getDefaultSortbyForCol = 
function(colHeader) {
	// by default, always return ascending
	return true;
}

DwtListView.prototype._allowLeftSelection =
function(clickedEl, ev, button) {
	// overload me (and return false) if you dont want to actually select clickedEl
	return true;
}

DwtListView.prototype._setSortedColStyle = 
function(columnId) {
	
	if (this._currentColId != null && columnId != this._currentColId) {
		// unset current column arrow
		oldArrowId = DwtListView.HEADERITEM_ARROW + this._currentColId;
		oldArrowCell = document.getElementById(oldArrowId);
		if (oldArrowCell && oldArrowCell.firstChild) {
			var imgEl = (AjxImg._mode == AjxImg.SINGLE_IMG) ? oldArrowCell.firstChild : oldArrowCell.firstChild.firstChild;
			if (imgEl)
				imgEl.style.visibility = "hidden";
		}
		
		// reset style for old sorted column
		var oldSortedCol = document.getElementById(this._currentColId);
		if (oldSortedCol)
			oldSortedCol.className = "DwtListView-Column";
	}
	this._currentColId = columnId;
			
	// set new column arrow
	var newArrowId = DwtListView.HEADERITEM_ARROW + columnId;
	var newArrowCell = document.getElementById(newArrowId);
	if (newArrowCell) {
		AjxImg.setImage(newArrowCell, this._bSortAsc ? "ColumnUpArrow" : "ColumnDownArrow");
		var imgEl = (AjxImg._mode == AjxImg.SINGLE_IMG) ? newArrowCell.firstChild : newArrowCell.firstChild.firstChild;
		if (imgEl)
			imgEl.style.visibility = "visible";
	}
	
	// set new column style
	var newSortedCol = document.getElementById(columnId);
	if (newSortedCol)
		newSortedCol.className = "DwtListView-Column DwtListView-ColumnActive";
}

DwtListView.prototype._resetList =
function() {
	this._resetModelList();
	this._resetListView();
};

DwtListView.prototype._resetModelList =
function () {
	// clear out old list to force GC
	if (this._list && this._list.size()) {
		this._list.removeAll();
	}
};

DwtListView.prototype._resetListView =
function () {
	// explicitly remove each child (setting innerHTML causes mem leak)
	while (this._parentEl.hasChildNodes()) {
		cDiv = this._parentEl.removeChild(this._parentEl.firstChild);
		AjxCore.unassignId(Dwt.getAttr(cDiv, "_itemIndex"));
	}
};

DwtListView.prototype._destroyDnDIcon =
function(icon) {
	var itemIdx = Dwt.getAttr(icon, "_itemIndex");
	if (itemIdx)
		AjxCore.unassignId(itemIdx);
	DwtControl.prototype._destroyDnDIcon.call(this,icon);
};

DwtListView.prototype._handleColHeaderMove = 
function(ev) {
	if (this._headerClone == null) {
		if (this._headerColX == null) {
			this._headerColX = ev.docX;
			return;
		} else {
			var threshold = Math.abs(this._headerColX - ev.docX);
			if (threshold < DwtListView.COL_MOVE_THRESHOLD)
				return;
		}
		
		// create a clone of the selected column to move
		this._headerClone = document.createElement("div");
		var size = Dwt.getSize(this._clickDiv);
		var width = AjxEnv.isIE ? size.x : size.x - 3;	// browser quirks
		var height = AjxEnv.isIE ? size.y : size.y - 5;
		Dwt.setSize(this._headerClone, width, height);
		Dwt.setPosition(this._headerClone, Dwt.ABSOLUTE_STYLE); 
		Dwt.setZIndex(this._headerClone, Dwt.Z_DND);
		Dwt.setLocation(this._headerClone, Dwt.DEFAULT, ev.docY);
		
		this._headerClone.className = this._clickDiv.className + " DndIcon";
		this._headerClone.innerHTML = this._clickDiv.innerHTML;
		this._clickDiv.className = "DwtListView-Column DwtListView-ColumnEmpty";
		
		// XXX: style hacks - improve this later
		this._headerClone.style.borderTop = "1px solid #777777";
		var labelCell = document.getElementById(DwtListView.HEADERITEM_LABEL + this._clickDiv.id);
		if (labelCell)
			labelCell.style.color = "white";
		
		//this._listColDiv.appendChild(this._headerClone);
		this.shell.getHtmlElement().appendChild(this._headerClone);
	} else {
		var target = this._findAncestor(ev.target, "_itemIndex");
		if (target && Dwt.getAttr(target, "_type") == DwtListView.TYPE_HEADER_ITEM) {
			if (this._headerCloneTarget && this._headerCloneTarget == this._clickDiv)
				this._headerCloneTarget = null;
			else if (this._headerCloneTarget != target) {
				this._headerCloneTarget = target;
			}
		} else {
			this._headerCloneTarget = null;
		}
	}

	Dwt.setLocation(this._headerClone, ev.docX + 2);
}

DwtListView.prototype._handleColHeaderResize = 
function(ev) {

	if (this._headerSash == null) {
		this._headerSash = document.createElement("div");

		Dwt.setSize(this._headerSash, Dwt.DEFAULT, this.getSize().y);
		Dwt.setPosition(this._headerSash, Dwt.ABSOLUTE_STYLE); 
		Dwt.setZIndex(this._headerSash, Dwt.Z_DND);
		Dwt.setLocation(this._headerSash, Dwt.DEFAULT, 0);

		this._headerSash.className = "DwtListView-ColumnSash";
		this.getHtmlElement().appendChild(this._headerSash);
		
		// remember the initial x-position
		this._headerSashX = ev.docX;
	}
	
	// always update the sash's position
	var parent = this._getParentForColResize();
	var loc = Dwt.toWindow(parent.getHtmlElement(), 0 ,0);
	Dwt.setLocation(this._headerSash, ev.docX-loc.x);
}

DwtListView.prototype._handleColHeaderDrop = 
function(ev) {
	this._headerColX = null;

	if (this._headerClone == null || ev.button == DwtMouseEvent.RIGHT)
		return false;
	
	// did the user drop the column on a valid target?
	if (this._headerCloneTarget) {
		var divItemIdx = Dwt.getAttr(this._clickDiv, "_itemIndex");
		var tgtItemIdx = Dwt.getAttr(this._headerCloneTarget, "_itemIndex");
		this.reIndexColumn(divItemIdx, tgtItemIdx);
	}

	this._clickDiv.className = this._clickDiv.id != this._currentColId 
		? "DwtListView-Column" 
		: "DwtListView-Column DwtListView-ColumnActive";
		
	wasDraggingCol = true;
	var parent = this._headerClone.parentNode;
	if (parent) {
		parent.removeChild(this._headerClone);
	} else {
		DBG.println(AjxDebug.DBG1, "XXX: column header has no parent!");
	}
	delete this._headerClone;
	
	if (Dwt.getAttr(this._clickDiv, "_type") != DwtListView.TYPE_HEADER_ITEM) {
		// something is messed up! redraw the header
		var sortable = this._getSortableFromColId(this._currentColId);
		this._headerColCreated = false;
		this.createHeaderHtml(sortable);
	} else {
		// reset styles as necessary
		var labelCell = document.getElementById(DwtListView.HEADERITEM_LABEL + this._clickDiv.id);
		if (labelCell)
			labelCell.style.color = "black";
	}
		
	this._resetColWidth();

	// TODO: generate notification for column reorder

	return true;
}

DwtListView.prototype._handleColSashDrop = 
function(ev) {
	if (this._headerSash == null || ev.button == DwtMouseEvent.RIGHT)
		return false;
		
	// find out where the user dropped the sash and update column width
	var delta = ev.docX - this._headerSashX;

	var itemIdx = Dwt.getAttr(this._clickDiv, "_itemIndex");
	var suffixIdx = itemIdx.indexOf("--sash");
	var headerIdx = parseInt(itemIdx.substring(0, suffixIdx));
	if (headerIdx >= 0 && headerIdx < this._headerList.length) {
		var newWidth = null;
		if (this._headerList[headerIdx]._width)
			newWidth = this._headerList[headerIdx]._width + delta;
		else {
			// lets actually adjust the next column since this one has a relative width
			var nextCol = this._headerList[headerIdx+1];
			if (nextCol && nextCol._width && nextCol._resizeable) {
				var cell = document.getElementById(nextCol._id);
				newWidth = cell ? Dwt.getSize(cell).x + delta : null;
			}
		}
		this.reSizeColumn(headerIdx, newWidth);
	} else {
		DBG.println("XXX: Bad header ID.");
	}
	
	var parent = this._headerSash.parentNode;
	if (parent)
		parent.removeChild(this._headerSash);
	delete this._headerSash;
	
	this._resetColWidth();
	
	return true;
}

DwtListView.prototype._relayout = 
function() {
	// force relayout of header column
	this._headerColCreated = false;
	var sortable = this._getSortableFromColId(this._currentColId);
	var sel = this.getSelection()[0];
	this.setUI(sortable);
	this.setSelection(sel, true);
}

// XXX: this could be optimized by saving the sortable everytime the sort column changes
DwtListView.prototype._getSortableFromColId = 
function(colId) {
	// helper function to find column that was last sorted
	var sortable = null;
	for (var i = 0; i < this._headerList.length; i++) {
		if (this._headerList[i]._id == colId) {
			sortable = this._headerList[i]._sortable;
			break;
		}
	}
	return sortable;
}

DwtListView.prototype._getParentForColResize = 
function() {
	// overload me to return a higher inheritance chain parent
	return this;
}

DwtListView.prototype.setSize =
function(width, height) {
	DwtComposite.prototype.setSize.call(this, width, height);
	this._sizeChildren(height);
}

DwtListView.prototype.setBounds =
function(x, y, width, height) {
	DwtComposite.prototype.setBounds.call(this, x, y, width, height);
	this._sizeChildren(height);
}

DwtListView.prototype._sizeChildren =
function(height) {
	if (this._listDiv && (height != Dwt.DEFAULT))
		Dwt.setSize(this._listDiv, Dwt.DEFAULT, height - DwtListView.HEADERITEM_HEIGHT);
}

// overload if parent element's children are not DIV's (i.e. div's w/in a table)
DwtListView.prototype._getChildren = 
function() {
	return null;
}

DwtListView.prototype.setSortByAsc = 
function(column, bSortByAsc) {
	if (!this._headerList)
		return;
		
	this._bSortAsc = bSortByAsc;
	var columnId = null;
	for (var i = 0; i < this._headerList.length; i++) {
		if (this._headerList[i]._sortable && this._headerList[i]._sortable == column) {
			columnId = this._headerList[i]._id;
			break;
		}
	}
	if (columnId)
		this._setSortedColStyle(columnId);
}

DwtListView.prototype.enableSorting = 
function(enabled) { 
	this._sortingEnabled = enabled;
};

DwtListView.prototype.getOffset = 
function() { 
	return this._offset;
}

DwtListView.prototype.setOffset = 
function(newOffset) { 
	this._offset = newOffset;
}

DwtListView.prototype.getNewOffset = 
function(bPageForward) {
	var limit = this.getLimit();
	var offset = bPageForward ? this._offset + limit : this._offset - limit;
	
	// normalize..
	if (offset < 0) 
		offset = 0;
	
	return offset;
}

DwtListView.prototype.getLimit = 
function() {
	// return the default limit value unless overloaded
	return DwtListView.DEFAULT_LIMIT;
}

DwtListView.prototype.getReplenishThreshold = 
function() {
	// return the default threshold value unless overloaded
	return DwtListView.MAX_REPLENISH_THRESHOLD;
}

DwtListView.prototype.getList = 
function() {
	return this._list;
}

// this method simply appends the given list to this current one
DwtListView.prototype.replenish = 
function(list) {
	this._list.addList(list);

	var size = list.size();
	for (var i = 0; i < size; i++) {
		var item = list.get(i);
		var div = this._createItemHtml(item, this._now);
		if (div)
			this._addRow(div);
	}
}

//////////////////////////////////////////////////////////////////////////////
// DwtListHeaderItem
// - This is a (optional) "container" class for DwtListView objects which 
//   want a column header to appear. Create a new DwtListViewItem for each 
//   column header you want to appear. Be sure to specify width values 
//   (otherwise, undefined is default)
//
// @id 			Some ID used internally (a GUID gets appended to ensure uniqueness)
// @label 		The text shown for the column
// @iconInfo 	The icon shown for the column
// @width 		The width of the column
// @sortable 	ID of a sortable column. Pass null if the column is not sortable
// @resizeable 	Flag indicating whether column can be resized
// @visible 	Flag indicating whether column is initially visible
// @name 		Description of column used if column headers have action menu 
//              - If not supplied, uses label value. 
//                This param is primarily used for columns w/ only an icon (no label)
//
// TODO - kill this class and make a static array in derived class describing 
//        column info (i.e. derived classes will be required to supply this!)
//////////////////////////////////////////////////////////////////////////////
function DwtListHeaderItem(id, label, iconInfo, width, sortable, resizeable, visible, name) {
	this._id = id + Dwt.getNextId();
	this._label = label;
	this._iconInfo = iconInfo;
	this._width = width;
	this._sortable = sortable;
	this._resizeable = resizeable;
	// only set visible if explicitly set to false
	this._visible = (visible !== false);
	this._name = name || label;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a button.
* @constructor
* @class
* This class represents a button, which is basically a smart label that can handle
* various UI events. It knows when it has been activated (the mouse is over it),
* when it has been triggered (mouse down), and when it has been pressed (mouse up).
* In addition to a label's image and/or text, a button may have a dropdown menu.
*
* @author Ross Dargahi
* @author Conrad Damon
* @param parent		the parent widget
* @param style		the label style (see DwtLabel)
* @param className	a CSS class
* @param posStyle	positioning style
*/
function DwtButton(parent, style, className, posStyle, actionTiming) {
	if (arguments.length == 0) return;
	className = className || "DwtButton";
	DwtLabel.call(this, parent, style, className, posStyle);

	// CSS classes to handle activated/triggered states
	this._origClassName = className;
	this._activatedClassName = this._className + "-" + DwtCssStyle.ACTIVATED;
	this._triggeredClassName = this._className + "-" + DwtCssStyle.TRIGGERED;
	this._toggledClassName = this._className + "-" + DwtCssStyle.TOGGLED;

	// add custom mouse handlers to standard ones
	var mouseEvents = [DwtEvent.ONCONTEXTMENU, DwtEvent.ONDBLCLICK, DwtEvent.ONMOUSEDOWN,
					   DwtEvent.ONMOUSEMOVE, DwtEvent.ONMOUSEUP, DwtEvent.ONSELECTSTART];
	if (AjxEnv.isIE)
		mouseEvents.push(DwtEvent.ONMOUSEENTER, DwtEvent.ONMOUSELEAVE);
	else
		mouseEvents.push(DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT);
	this._setEventHdlrs(mouseEvents);
	this._mouseOverListener = new AjxListener(this, DwtButton.prototype._mouseOverListener);
	this._mouseOutListener = new AjxListener(this, DwtButton.prototype._mouseOutListener);
	this._mouseDownListener = new AjxListener(this, DwtButton.prototype._mouseDownListener);
	this._mouseUpListener = new AjxListener(this, DwtButton.prototype._mouseUpListener);
	this._addMouseListeners();
	
	this._dropDownEvtMgr = new AjxEventMgr();

	this._toggled = false;

	this._actionTiming = actionTiming? actionTiming : DwtButton.ACTION_MOUSEUP;
}

DwtButton.prototype = new DwtLabel;
DwtButton.prototype.constructor = DwtButton;

DwtButton.TOGGLE_STYLE = DwtLabel._LAST_STYLE * 2;
DwtButton.ACTION_MOUSEUP = 1;
DwtButton.ACTION_MOUSEDOWN = 2;
// Public methods

DwtButton.prototype.toString = 
function() {
	return "DwtButton";
}

/**
* Adds a listener to be notified when the button is pressed.
*
* @param listener	a listener
*/
DwtButton.prototype.addSelectionListener = 
function(listener) {
	this.addListener(DwtEvent.SELECTION, listener);
}

/**
* Removes a selection listener.
*
* @param listener	the listener to remove
*/
DwtButton.prototype.removeSelectionListener = 
function(listener) { 
	this.removeListener(DwtEvent.SELECTION, listener);
}

/**
* Removes all the selection listeners.
*/
DwtButton.prototype.removeSelectionListeners = 
function() { 
	this.removeAllListeners(DwtEvent.SELECTION);
}

/**
* Adds a listener to be notified when the dropdown arrow is pressed.
*
* @param listener	a listener
*/
DwtButton.prototype.addDropDownSelectionListener = 
function(listener) {
	return this._dropDownEvtMgr.addListener(DwtEvent.SELECTION, listener);
}

/**
* Removes a dropdown selection listener.
*
* @param listener	the listener to remove
*/
DwtButton.prototype.removeDropDownSelectionListener = 
function(listener) { 
	this._dropDownEvtMgr.removeListener(DwtEvent.SELECTION, listener);
}

DwtButton.prototype.setDropDownImages = function (enabledImg, disImg, hovImg, depImg) {
	this._dropDownImg = enabledImg;
	this._dropDownDisImg = disImg;
	this._dropDownHovImg = hovImg;
	this._dropDownDepImg = depImg;
};

DwtButton.prototype._addMouseListeners = 
function() {
	this.addListener(DwtEvent.ONMOUSEOVER, this._mouseOverListener);
	this.addListener(DwtEvent.ONMOUSEOUT, this._mouseOutListener);
	this.addListener(DwtEvent.ONMOUSEDOWN, this._mouseDownListener);
	this.addListener(DwtEvent.ONMOUSEUP, this._mouseUpListener);
};

DwtButton.prototype._removeMouseListeners =
function() {
	this.removeListener(DwtEvent.ONMOUSEOVER, this._mouseOverListener);
	this.removeListener(DwtEvent.ONMOUSEOUT, this._mouseOutListener);
	this.removeListener(DwtEvent.ONMOUSEDOWN, this._mouseDownListener);
	this.removeListener(DwtEvent.ONMOUSEUP, this._mouseUpListener);
};

/**
* Sets the enabled/disabled state of the button. A disabled button may have a different
* image, and greyed out text. The button (and its menu) will only have listeners if it 
* is enabled.
*
* @param enabled	whether to enable the button
*
*/
DwtButton.prototype.setEnabled =
function(enabled) {
	if (enabled != this._enabled) {
		DwtLabel.prototype.setEnabled.call(this, enabled); // handles image/text
		if (enabled) {
			this._addMouseListeners();
			// set event handler for pull down menu if applicable
			if (this._menu) {
				this._setupDropDownCellMouseHandlers();
				AjxImg.setImage(this._dropDownCell, this._dropDownImg);
			}
		} else {
			this.setClassName(this._origClassName); // clear activated or triggered
			this._removeMouseListeners();
			// remove event handlers for pull down menu if applicable
			if (this._menu) {
				this._removeDropDownCellMouseHandlers();
				AjxImg.setImage(this._dropDownCell, this._dropDownDisImg);
			}
		}
	}
}

DwtButton.prototype.setHoverImage =
function (hoverImageInfo) {
    this._hoverImageInfo = hoverImageInfo;
}
/**
* Adds a dropdown menu to the button, available through a small down-arrow.
*
* @param menuOrCallback		The dropdown menu or an AjxCallback object. If a
*                           callback is given, it is called the first time the
*                           menu is requested. The callback must return a valid 
*                           DwtMenu object.
* @param shouldToggle
* @param followIconStyle	style of menu item (should be checked or radio style) for
*							which the button icon should reflect the menu item icon
*/
DwtButton.prototype.setMenu =
function(menuOrCallback, shouldToggle, followIconStyle) {
	this._menu = menuOrCallback;
	this._shouldToggleMenu = (shouldToggle === true);
	this._followIconStyle = followIconStyle;
	if (this._menu) {
		if (!this._dropDownCell) {
			var idx = (this._imageCell) ? 1 : 0;
			if (this._textCell)
				idx++;
			this._dropDownCell = this._row.insertCell(idx);
			this._dropDownCell.id = Dwt.getNextId();
			this._dropDownCell.className = "dropDownCell";
	
			if (this._dropDownImg == null) this._dropDownImg = "SelectPullDownArrow";
			if (this._dropDownDisImg == null) this._dropDownDisImg = "SelectPullDownArrowDis";
			if (this._dropDownHovImg == null) this._dropDownHovImg = "SelectPullDownArrowHover";
			AjxImg.setImage(this._dropDownCell, this._dropDownImg);

			// set event handler if applicable
			if (this._enabled) {
				this._setupDropDownCellMouseHandlers();
			}
		}
		if (!(this._menu instanceof AjxCallback)) {
			this._menu.setAssociatedElementId(this._dropDownCell.id);
		}
	} else if (this._dropDownCell) {
		this._row.deleteCell(Dwt.getCellIndex(this._dropDownCell));
		this._dropDownCell = null;
	}
}

DwtButton.prototype._setupDropDownCellMouseHandlers =
function() {
	Dwt.setHandler(this._dropDownCell, DwtEvent.ONMOUSEDOWN, DwtButton._dropDownCellMouseDownHdlr);
	Dwt.setHandler(this._dropDownCell, DwtEvent.ONMOUSEUP, DwtButton._dropDownCellMouseUpHdlr);
};

DwtButton.prototype._removeDropDownCellMouseHandlers =
function() {
	Dwt.clearHandler(this._dropDownCell, DwtEvent.ONMOUSEDOWN);
	Dwt.clearHandler(this._dropDownCell, DwtEvent.ONMOUSEUP);
};

/**
* Returns the button's menu
*/
DwtButton.prototype.getMenu =
function() {
	if (this._menu instanceof AjxCallback) {
		var callback = this._menu;
		this.setMenu(callback.run());
	}
	return this._menu;
}

/**
* Returns the button display to normal (not activated or triggered).
*/
DwtButton.prototype.resetClassName = 
function() {
	this.setClassName(this._origClassName);	
}
/*
 * Sets whether actions for this button should occur on mouse up or mouse
 * down.
 *
 * Currently supports DwtButton.ACTION_MOUSEDOWN and DwtButton.ACTION_MOUSEUP
 */
DwtButton.prototype.setActionTiming =
function(actionTiming) {
      this._actionTiming = actionTiming;
};

/**
* Activates/inactivates the button. A button is activated when the mouse is over it.
*
* @param activated		whether the button is activated
*/
DwtButton.prototype.setActivated =
function(activated) {
	if (activated) {
		this.setClassName(this._activatedClassName);
	} else {
		this.setClassName(this._origClassName);
	}
}

DwtButton.prototype.setEnabledImage =
function (imageInfo) {
	this._enabledImageInfo = imageInfo;
	this.setImage(imageInfo);
}

DwtButton.prototype.setDepressedImage =
function (imageInfo) {
    this._depressedImageInfo = imageInfo;
}

DwtButton.prototype.setToggled =
function(toggled) {
	if ((this._style & DwtButton.TOGGLE_STYLE) && this._toggled != toggled) {
		this._toggled = toggled;
		this.setClassName((toggled) ? this._toggledClassName : this._origClassName);
	}
}

DwtButton.prototype.isToggled = 
function() {
	return this._toggled;
}

DwtButton.prototype.popup =
function() {
	var menu = this.getMenu();
	var p = menu.parent;
	var pb = p.getBounds();
	var ws = menu.shell.getSize();
	var s = menu.getSize();
	var pHtmlElement = p.getHtmlElement();
	// since buttons are often absolutely positioned, and menus aren't, we need x,y relative to window
	var ptw = Dwt.toWindow(pHtmlElement, 0, 0);
	var vBorder = (pHtmlElement.style.borderLeftWidth == "") ? 0 : parseInt(pHtmlElement.style.borderLeftWidth);
	var x = ptw.x + vBorder;
	var hBorder = (pHtmlElement.style.borderTopWidth == "") ? 0 : parseInt(pHtmlElement.style.borderTopWidth);
	hBorder += (pHtmlElement.style.borderBottomWidth == "") ? 0 : parseInt(pHtmlElement.style.borderBottonWidth);
	var y = ptw.y + pb.height + hBorder;
	x = ((x + s.x) >= ws.x) ? x - (x + s.x - ws.x): x;
	//y = ((y + s.y) >= ws.y) ? y - (y + s.y - ws.y) : y;

	//this.setLocation(x, y);
	menu.popup(0, x, y);
};


// Private methods

DwtButton.prototype._toggleMenu =
function () {
	if (this._shouldToggleMenu){
		if (!this._menu.isPoppedup()){
			this.popup();
			this._menuUp = true;
		} else {
			this._menu.popdown();
			this._menuUp = false;
		}
	} else {
		this.popup();
	}
};

// Activates the button.
DwtButton.prototype._mouseOverListener = 
function(ev) {
    if (this._hoverImageInfo) {
        this.setImage(this._hoverImageInfo);
    }
    this.setClassName(this._activatedClassName);
    if (this._dropDownCell && this._dropDownHovImg && !this.noMenuBar && this.isListenerRegistered(DwtEvent.SELECTION)) {
		AjxImg.setImage(this._dropDownCell, this._dropDownHovImg);
    }
    ev._stopPropagation = true;
}

// Triggers the button.
DwtButton.prototype._mouseDownListener = 
function(ev) {
	if (ev.button != DwtMouseEvent.LEFT)
		return;
		
    if (this._dropDownCell && this._dropDownDepImg) {
		AjxImg.setImage(this._dropDownCell, this._dropDownDepImg);
    }
	switch (this._actionTiming) {
	  case DwtButton.ACTION_MOUSEDOWN:
		var el = this.getHtmlElement();
		this.trigger();
		if (this.isListenerRegistered(DwtEvent.SELECTION)) {
			var selEv = DwtShell.selectionEvent;
                       DwtUiEvent.copy(selEv, ev);
                       selEv.item = this;
                       selEv.detail = 0;
                       this.notifyListeners(DwtEvent.SELECTION, selEv);
		} else if (this._menu) {
			this._toggleMenu();
		}
		// So that listeners may remove this object from the flow, and not
		// get errors, when DwtControl tries to do a this.getHtmlElement ()
		// ROSSD - I don't get this, basically this method does a 
		// this.getHtmlElement as the first thing it does
		// so why would the line below cause a problem. It does have the
		// side-effect of making buttons behave weirdly
		// in that they will not remain active on mouse up
		//el.className = this._origClassName;
		break;
	  case DwtButton.ACTION_MOUSEUP:
		this.trigger();
		break;
	}
}

DwtButton.prototype.trigger =
function (){
    if (this._depressedImageInfo) {
        this.setImage(this._depressedImageInfo);
    }
	this.setClassName(this._triggeredClassName);
	this.isTriggered = true;	
};

DwtButton.prototype.deactivate =
function (){
	if (this._depressedImageInfo){
		this.setImage(this._hoverImageInfo);
	}
	
	if (this._style & DwtButton.TOGGLE_STYLE){
		this._toggled = !this._toggled;
	}
	this.setClassName((!this._toggled) ? this._activatedClassName : 
					  this._toggledClassName);
};

// Button has been pressed, notify selection listeners.
DwtButton.prototype._mouseUpListener = 
function(ev) {
	if (ev.button != DwtMouseEvent.LEFT)
		return;

    if (this._dropDownCell && this._dropDownHovImg && !this.noMenuBar){
		AjxImg.setImage(this._dropDownCell, this._dropDownHovImg);
    }	
	switch (this._actionTiming) {
	  case DwtButton.ACTION_MOUSEDOWN:
 	    this.deactivate();
		break;

	  case DwtButton.ACTION_MOUSEUP:
	    var el = this.getHtmlElement();
		if (this.isTriggered) {
			this.deactivate();
			if (this.isListenerRegistered(DwtEvent.SELECTION)) {
				var selEv = DwtShell.selectionEvent;
				DwtUiEvent.copy(selEv, ev);
				selEv.item = this;
				selEv.detail = 0;
				this.notifyListeners(DwtEvent.SELECTION, selEv);
			} else if (this._menu) {
				this._toggleMenu();
			}
		}
		// So that listeners may remove this object from the flow, and not
		// get errors, when DwtControl tries to do a this.getHtmlElement()
		// ROSSD - I don't get this, basically this method does a this.getHtmlElement as the first thing it does
		// so why would the line below cause a problem. It does have the side-effect of making buttons behave weirdly
		// in that they will not remain active on mouse up
		//el.className = this._origClassName;	
		break;
	}
};

DwtButton.prototype._setMouseOutClassName =
function() {
    this.setClassName((this._toggled) ? this._toggledClassName : this._origClassName);
}

// Button no longer activated/triggered.
DwtButton.prototype._mouseOutListener = 
function(ev) {
    if (this._hoverImageInfo) {
        this.setImage(this._enabledImageInfo);
    }
	this._setMouseOutClassName();
    this.isTriggered = false;

    if (this._dropDownCell){
		AjxImg.setImage(this._dropDownCell, this._dropDownImg);
    }	
}


// Pops up the dropdown menu.
DwtButton._dropDownCellMouseDownHdlr = 
function(ev) {
	var obj = DwtUiEvent.getDwtObjFromEvent(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	
	if (mouseEv.button == DwtMouseEvent.LEFT) {
	    if (this._depImg){
			AjxImg.setImage(this, this._depImg);
	    }	

		DwtEventManager.notifyListeners(DwtEvent.ONMOUSEDOWN, mouseEv);

		if (obj._menu instanceof AjxCallback) {
			obj.popup();
		}	

		if (obj._dropDownEvtMgr.isListenerRegistered(DwtEvent.SELECTION)) {
	    	var selEv = DwtShell.selectionEvent;
	    	DwtUiEvent.copy(selEv, mouseEv);
	    	selEv.item = obj;
	    	obj._dropDownEvtMgr.notifyListeners(DwtEvent.SELECTION, selEv);
	        
	    } else if (mouseEv.button == DwtMouseEvent.LEFT) {
			obj._toggleMenu();
		}
	}

	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;
}

// Updates the current mouse event (set from the previous mouse down).
DwtButton._dropDownCellMouseUpHdlr = 
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);	

	if (mouseEv.button == DwtMouseEvent.LEFT) {
	    if (this._hovImg && !this.noMenuBar) {
			AjxImg.setImage(this, this._hovImg);
	    }	
	}
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;
}

/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a menu item. Menu items can be part of a radio group, or can be checked style menu items
*
* @constructor
* @class
*
* @author Ross Dargahi
* @param parent			the parent widget
* @param style 			menu item's style
* @param radioGroupId 	radio group that the menu item is part of
* @param index 			position in menu
* @param className		a CSS class
* @param posStyle		positioning style
*/
function DwtMenuItem(parent, style, radioGroupId, index, className, posStyle) {

	className = className || "DwtMenuItem";
	DwtComposite.call(this, parent, className, posStyle);

	if (!(parent instanceof DwtMenu))
		throw new DwtException("Parent must be a DwtMenu object", DwtException.INVALIDPARENT, "DwtMenuItem");
		
	this._style = style ? style : DwtMenuItem.CASCADE_STYLE;
	if (parent._style == DwtMenu.BAR_STYLE && this._style != DwtMenuItem.PUSH_STYLE)
		throw new DwtException("DwtMenuItemInit: invalid style", DwtException.INVALID_PARAM, "DwtMenuItem"); 

	this._setMouseEventHdlrs();
	this._origClassName = className;
	this._selectedClassName = className + "-" + DwtCssStyle.SELECTED;
	this._triggeredClassName = className + "-" + DwtCssStyle.TRIGGERED;
	this._iconAreaClassName = className + "-IconArea";
	this._iconAreaSelClassname = this._iconAreaClassName + "-" + DwtCssStyle.SELECTED;
	this._checkedAreaClassName = className + "-CheckedArea";
	this._checkedAreaSelClassname = this._checkedAreaClassName + "-" + DwtCssStyle.SELECTED;
	this._table = document.createElement("table");
	this._table.cellSpacing = this._table.cellPadding = 0;
	this._table.border = 0;
	this._table.borderCollapse = "separate";
	this._row = this._table.insertRow(0);

	switch (this._style) {
		case DwtMenuItem.SEPARATOR_STYLE:
			this._createSeparatorStyle();
			break;
		case DwtMenuItem.PUSH_STYLE:
			this._createPushStyle();
			break;
		case DwtMenuItem.RADIO_STYLE:
		case DwtMenuItem.CHECK_STYLE:
			this._createCheckedStyle(radioGroupId);
			break;
	    case DwtMenuItem.SELECT_STYLE:
			this._createSelectStyle();
			break;
		default:
			this._createCascadeStyle();
	}

	this._mouseOverListener = new AjxListener(this, DwtMenuItem.prototype._mouseOverListener);
	this._mouseOutListener = new AjxListener(this, DwtMenuItem.prototype._mouseOutListener);
	this._mouseUpListener = new AjxListener(this, DwtMenuItem.prototype._mouseUpListener);
	this._mouseDownListener = new AjxListener(this, DwtMenuItem.prototype._mouseDownListener);
	this.addListener(DwtEvent.ONMOUSEOVER, this._mouseOverListener);
	this.addListener(DwtEvent.ONMOUSEOUT, this._mouseOutListener);
	this.addListener(DwtEvent.ONMOUSEUP, this._mouseUpListener);
	this.addListener(DwtEvent.ONMOUSEDOWN, this._mouseDownListener);
	this.getHtmlElement().appendChild(this._table);
	if (parent._addItem)
		parent._addItem(this, index);
	this.setCursor("default");
	this._menu = null;
	this._menuDisposeListener = new AjxListener(this, DwtMenuItem.prototype._menuDisposed)
}

DwtMenuItem.prototype = new DwtComposite;
DwtMenuItem.prototype.constructor = DwtMenuItem;

DwtMenuItem.prototype.toString = 
function() {
	return "DwtMenuItem";
}

DwtMenuItem.CHECKED = 1;
DwtMenuItem.UNCHECKED = 2;

DwtMenuItem.NO_STYLE = 0;
DwtMenuItem.CHECK_STYLE = 1;
DwtMenuItem.RADIO_STYLE = 2;
DwtMenuItem.SEPARATOR_STYLE = 3;
DwtMenuItem.CASCADE_STYLE = 4;
DwtMenuItem.PUSH_STYLE = 5;
DwtMenuItem.SELECT_STYLE = 6;

DwtMenuItem._IMAGECELL_DIM = "22px";
DwtMenuItem._CASCADE_DIM = "16px";
DwtMenuItem._CHECKEDCELL_DIM = "13px";
DwtMenuItem._FILLCELL_DIM = "7px";
DwtMenuItem._MENU_POPUP_DELAY = 250;
DwtMenuItem._MENU_POPDOWN_DELAY = 250

DwtMenuItem.create =
function(parent, imageInfo, text, disImageInfo, enabled, style, radioGroupId, idx, className, posStyle) {
	var mi = new DwtMenuItem(parent, style, radioGroupId, idx, className, posStyle);
	if (imageInfo)
		mi.setImage(imageInfo);
	if (text)
		mi.setText(text);
	if (disImageInfo)
		mi.setDisabledImage(disImageInfo);
	mi.setEnabled(enabled !== false);
	return mi;
}


DwtMenuItem.prototype.addSelectionListener = 
function(listener) {
	this.addListener(DwtEvent.SELECTION, listener);
}

DwtMenuItem.prototype.removeSelectionListener = 
function(listener) {
  this.removeListener(DwtEvent.SELECTION, listener);     	
}

DwtMenuItem.prototype.getChecked =
function() {
	return this._itemChecked;
}

DwtMenuItem.prototype.setChecked =
function(checked, skipNotify) {
	this._setChecked(checked, null, skipNotify);
}

DwtMenuItem.prototype._setChecked =
function(checked, ev, skipNotify) {
	if ((this._style == DwtMenuItem.CHECK_STYLE || this._style == DwtMenuItem.RADIO_STYLE)
		&& this._itemChecked != checked) {
		this._itemChecked = checked;
		
		if (checked) {
			if (this._style == DwtMenuItem.CHECK_STYLE) {
				AjxImg.setImage(this._checkedCell, "MenuCheck");
			} else {
				AjxImg.setImage(this._checkedCell, "MenuRadio");
				// This will cause the parent menu to deselect the currently selected radio item
				this.parent._radioItemSelected(this, skipNotify);
			}
			var gp = this.parent.parent ? this.parent.parent : null;
			if (gp && (gp instanceof DwtButton) && (gp._followIconStyle == this._style))
				gp.setImage(this._imageInfo);
		} else {
			AjxImg.setImage(this._checkedCell, "Blank_9");
		}
		
		if (skipNotify) return;
		
		// If we are being called as a result of a UI action then ev will not be null and we ahve
		// to initialize our selection event based on the the event.
		var selEv = DwtShell.selectionEvent;
		if (ev)
			DwtUiEvent.copy(selEv, ev);
		else
			selEv.reset();
		selEv.item = this;
		selEv.detail = (checked) ? DwtMenuItem.CHECKED : DwtMenuItem.UNCHECKED;
		this.notifyListeners(DwtEvent.SELECTION, selEv);			
	}
}

DwtMenuItem.prototype.setEnabled =
function(enabled) {
	if (enabled != this._enabled) {
		DwtControl.prototype.setEnabled.call(this, enabled);
		if (enabled) {
			this.addListener(DwtEvent.ONMOUSEOVER, this._mouseOverListener);
			this.addListener(DwtEvent.ONMOUSEOUT, this._mouseOutListener);
			this.addListener(DwtEvent.ONMOUSEUP, this._mouseUpListener);
			this.addListener(DwtEvent.ONMOUSEDOWN, this._mouseDownListener);
			if (this._imageInfo)
				this._setImage(this._imageInfo);
			if (this._textCell)
				this._textCell.className = "Text";
		} else {
			this.removeListener(DwtEvent.ONMOUSEOVER, this._mouseOverListener);
			this.removeListener(DwtEvent.ONMOUSEOUT, this._mouseOutListener);
			this.removeListener(DwtEvent.ONMOUSEUP, this._mouseUpListener);
			this.removeListener(DwtEvent.ONMOUSEDOWN, this._mouseDownListener);
			if (this._disabledImageInfo)
				this._setImage(this._disabledImageInfo);
			if (this._textCell)
				this._textCell.className = "DisabledText";
		}
	}
}


DwtMenuItem.prototype.getDisabledImage =
function() {
	return this._disabledImage;
}

DwtMenuItem.prototype.setDisabledImage =
function(imageInfo) {
	this._disabledImageInfo = imageInfo;
	if (!this._enabled && imageInfo)
		this._setImage(imageInfo);
}

DwtMenuItem.prototype.getImage =
function() {
	return this._imageInfo;
}

DwtMenuItem.prototype.setImage =
function(imageInfo) {
	this._imageInfo = imageInfo;
	if (this._enabled || (!this._enabled && !this._disabledImageInfo))
		this._setImage(imageInfo);
}

DwtMenuItem.prototype._setImage =
function(imageInfo) {
	if (this._imageInfo == null)
		return;
		
	if (this._iconCell == null) {
		this._addIconCell(this);
		this.parent._menuItemHasIcon();
	}
		
	/* TODO First check to see if the item already has an image cell. If
	 * it does not, then add it, and call up to the Menu to notify
	 * all children to add the image cell*/ 
	if (this._style != DwtMenuItem.SEPARATOR_STYLE) {
		AjxImg.setImage(this._iconCell, imageInfo);
	}
}

DwtMenuItem.prototype.getMenu =
function() {
	if (this._menu instanceof AjxCallback) {
		var callback = this._menu;
		this.setMenu(callback.run());
	}
	return this._menu;
}

/**
 * Adds a sub-menu to this menu item.
 *
 * @param menuOrCallback  The dropdown menu or an AjxCallback object. If a
 *                        callback is given, it is called the first time the
 *                        menu is requested. The callback must return a valid 
 *                        DwtMenu object.
 */
DwtMenuItem.prototype.setMenu = 
function(menuOrCallback) {
	if (this._menu == menuOrCallback) {
		return;
	} 
	if (this._menu && !(this._menu instanceof AjxCallback)) {
		this._menu.removeDisposeListener(this._menuDisposeListener);
	}

	if (this._style == DwtMenuItem.CASCADE_STYLE || this._style == DwtMenuItem.CHECK_STYLE
		|| this._style == DwtMenuItem.RADIO_STYLE) {
		if (menuOrCallback) {
			if (!this._menu)
				this.parent._submenuItemAdded()
			AjxImg.setImage(this._cascCell, "Cascade");
		} else if (!menuOrCallback) {
			if (this._menu)
				this.parent._submenuItemRemoved();
			if (this._cascCell)
				AjxImg.setImage(this._cascCell, "Blank_16");
		}
	}
	this._menu = menuOrCallback;
	if (menuOrCallback && !(menuOrCallback instanceof AjxCallback))
		menuOrCallback.addDisposeListener(this._menuDisposeListener);
};

DwtMenuItem.prototype.setSize = 
function(width, height) {
	DwtComposite.prototype.setSize.call(this, width, height);
	if (width != DwtControl.DEFAULT) {
		width = (typeof(width) == "number") ? width + "px" : width;
		this._table.style.width = width;
	}
	if (height != DwtControl.DEFAULT) {
		height = (typeof(height) == "number") ? height + "px" : height;
		this._table.style.height = height;
	}
}

DwtMenuItem.prototype.getText =
function() {
	if ((this._style == DwtMenuItem.SEPARATOR_STYLE) != 0) return null;
	return this._textCell.innerHTML;
}

DwtMenuItem.prototype.setText =
function(text) {
	if ((this._style == DwtMenuItem.SEPARATOR_STYLE) != 0) return;
	this._textCell.innerHTML = text;
}

DwtMenuItem.prototype._createSeparatorStyle =
function() {
	this._table.style.width = "100%";
	fillCell = this._row.insertCell(0);
	fillCell.className = this._className + "-Separator";
	
	if (this.parent._menuHasCheckedItems())
		this._checkItemAdded();
		
	if (this.parent._menuHasItemsWithIcons()) {
		this._addIconCell();
	}
}

DwtMenuItem.prototype._createPushStyle =
function() {
	var i = 0;
	this._textCell = this._row.insertCell(i++);
	this._textCell.className = "Text";
	
	if (this.parent._menuHasItemsWithIcons()) {
		this._addIconCell();
	}
}

DwtMenuItem.prototype._createSelectStyle =
function() {
	this._table.style.width = "100%";
	this._textCell = this._row.insertCell(-1);
	this._textCell.className = "Text";
};

DwtMenuItem.prototype._createCascadeStyle =
function() {
	this._table.style.width = "100%";
	
	var i = 0;
	this._textCell = this._row.insertCell(i++);
	this._textCell.className = "Text";
	
	if (this.parent._menuHasSubmenus())
		this._submenuItemAdded()

	if (this.parent._menuHasCheckedItems())
		this._checkItemAdded();
		
	if (this.parent._menuHasItemsWithIcons()) {
		this._addIconCell();
	}
}

DwtMenuItem.prototype._createCheckedStyle =
function(radioGroupId) {
	this._createCascadeStyle();
	this._checkItemAdded();
	this._radioGroupId = (radioGroupId != null) ? radioGroupId : 0;
	this._itemChecked = false;
}

/* This method is called by DwtMenuItem.prototype._createCheckedStyle when a check or radio style
 * menu item is being created. It is also called by DwtMenu._addItem when a check/radio style item
 * is added to the menu and it allows for the menu item to add a column so that it can align with
 * the new checked item */
DwtMenuItem.prototype._checkItemAdded =
function() {
	if (this._checkedCell == null) {
		this._checkedCell = this._row.insertCell(0);
		this._checkedCell.noWrap = true;
		this._checkedCell.align = "center";
		this._checkedCell.width = DwtMenuItem._CHECKEDCELL_DIM;
		this._checkedCell.height = (this._style != DwtMenuItem.SEPARATOR_STYLE) ?  DwtMenuItem._CHECKEDCELL_DIM : 1;
		this._checkedCell.className = this._checkedAreaClassName;
	}
}

/* This method is explicitly called by DwtMenu.removeChild when the last check/radio item is removed
 * from the menu. It allows for the item to remove its "bogus" check column*/
DwtMenuItem.prototype._checkedItemsRemoved =
function() {
	this._row.deleteCell(0);
	this._checkedCell = null;
}

DwtMenuItem.prototype._submenuItemAdded =
function() {
	if (this._cascCell == null) {
		this._cascCell = this._row.insertCell(-1);
		this._cascCell.noWrap = true;
		this._cascCell.style.width = DwtMenuItem._CASCADE_DIM;
		this._cascCell.style.height = (this._style != DwtMenuItem.SEPARATOR_STYLE) ?  DwtMenuItem._CASCADE_DIM : 1;;
	}
}

/* This method is explicitly called by DwtMenu.removeChild when the last submenu is removed
 * from the menu. It allows for the item to remove its "bogus" cascade column*/
DwtMenuItem.prototype._submenuItemRemoved =
function() {
	this._row.deleteCell(this._row.cells.length - 1);
	this._cascCell = null;
}

DwtMenuItem.prototype._addIconCell =
function() {
	if (this._iconCell == null) {
		var i = (!this._checkedCell) ? 0 : 1;
		this._iconCell = this._row.insertCell(i++);
		this._iconCell.noWrap = true;
		this._iconCell.align = "center";
		this._iconCell.width =  DwtMenuItem._IMAGECELL_DIM;
		this._iconCell.height = (this._style != DwtMenuItem.SEPARATOR_STYLE) ?  DwtMenuItem._IMAGECELL_DIM : 1;
		this._iconCell.className = this._iconAreaClassName;	
	}
}

DwtMenuItem.prototype._menuDisposed =
function(ev) {
	this.setMenu(null);
}

DwtMenuItem.prototype._popupMenu =
function(delay) {
	var menu = this.getMenu();
	var pp = this.parent.parent;
	var pb = this.getBounds();
	var ws = menu.shell.getSize();
	var s = menu.getSize();
	var x;
	var y;
	var vBorder;
	var hBorder;
	var ppHtmlElement = pp.getHtmlElement();
	if (pp._style == DwtMenu.BAR_STYLE) {
		vBorder = (ppHtmlElement.style.borderLeftWidth == "") ? 0 : parseInt(ppHtmlElement.style.borderLeftWidth);
		x = pb.x + vBorder;
		hBorder = (ppHtmlElement.style.borderTopWidth == "") ? 0 : parseInt(ppHtmlElement.style.borderTopWidth);
		hBorder += (ppHtmlElement.style.borderBottomWidth == "") ? 0 : parseInt(ppHtmlElement.style.borderBottonWidth);
		y = pb.y + pb.height + hBorder;		
		x = ((x + s.x) >= ws.x) ? x - (x + s.x - ws.x): x;
		//y = ((y + s.y) >= ws.y) ? y - (y + s.y - ws.y) : y;
	} else { // Drop Down
		vBorder = (ppHtmlElement.style.borderLeftWidth == "") ? 0 : parseInt(ppHtmlElement.style.borderLeftWidth);
		vBorder += (ppHtmlElement.style.borderRightWidth == "") ? 0 : parseInt(ppHtmlElement.style.borderRightWidth);
		x = pb.x + pb.width + vBorder;
		hBorder = (ppHtmlElement.style.borderTopWidth == "") ? 0 : parseInt(ppHtmlElement.style.borderTopWidth);
		y = pb.y + hBorder;
		x = ((x + s.x) >= ws.x) ? pb.x - s.x - vBorder: x;
		//y = ((y + s.y) >= ws.y) ? y - (y + s.y - ws.y) : y;
	}
	//this.setLocation(x, y);

	menu.popup(delay, x, y);
};

DwtMenuItem.prototype._popdownMenu =
function() {
	//if (this._menu && this._menu.isPoppedup())
		this._deselect(0);
}

DwtMenuItem.prototype._deselect =
function(msec) {
	if (this._style == DwtMenuItem.CASCADE_STYLE || this._style == DwtMenuItem.CHECK_STYLE
		|| this._style == DwtMenuItem.RADIO_STYLE) {
		if (this._iconCell)
			this._iconCell.className = this._iconAreaClassName;
		if (this._checkedCell)
			this._checkedCell.className = this._checkedAreaClassName;		
		msec = (msec == null) ? DwtMenuItem._MENU_POPDOWN_DELAY : msec;
	}
	var menu = this.getMenu();
	if (menu)
		menu.popdown(msec);
	this.setClassName(this._origClassName);
	this.setCursor("default");
}

DwtMenuItem.prototype._isMenuPoppedup =
function() {
	var menu = this.getMenu();
	return (menu && menu.isPoppedup()) ? true : false;
}

DwtMenuItem.prototype._mouseOverListener = 
function(ev) {
	if (this.parent.__selectedId != this._htmlElId && this._menu) {
		// NOTE: This ensures menu is repositioned if used by more than one item
		this._deselect(0);
	}
	this.parent.__selectedId = this._htmlElId;
	//this.parent.popup(); // REVISIT: Why does a rollover popup the parent?
	if (this._style == DwtMenuItem.SEPARATOR_STYLE)
		return;
	var activeItem = this.parent._getActiveItem();
	this.parent.clearExternallySelectedItems();
	if (this._style == DwtMenuItem.CASCADE_STYLE || this._style == DwtMenuItem.CHECK_STYLE
		|| this._style == DwtMenuItem.RADIO_STYLE) {
		if (activeItem)
			activeItem._deselect();	
		if (this._iconCell)
			this._iconCell.className = this._iconAreaSelClassName;
		if (this._checkedCell)
			this._checkedCell.className = this._checkedAreaSelClassName;
		if (this._menu) {
			this._popupMenu(DwtMenuItem._MENU_POPUP_DELAY);
		}
		this.setSelectedStyle();
	} else if (this._style == DwtMenuItem.PUSH_STYLE || this._style == DwtMenuItem.SELECT_STYLE) {
		if (activeItem)
			activeItem._deselect(0);
		if (activeItem && this._menu) {
			this._popupMenu(0);
			this.setSelectedStyle();
		} else {
			this.setSelectedStyle()
		}
	}
	ev._stopPropagation = true;
}

DwtMenuItem.prototype.setSelectedStyle = 
function () {
	this.setClassName(this._selectedClassName);
	this._isSelected = true;
};

DwtMenuItem.prototype.setTriggeredStyle = 
function () {
	this.setCursor("wait");
	this.setClassName(this._triggeredClassName);
};

DwtMenuItem.prototype._mouseOutListener = 
function(ev) {
	if (this._style == DwtMenuItem.SEPARATOR_STYLE)
		return;
	var menu = this.getMenu();
	if (menu == null || !menu.isPoppedup())
		this._deselect();
}

DwtMenuItem.prototype._mouseDownListener = 
function(ev) {
	if (ev.button != DwtMouseEvent.LEFT)
		return;
	this.setTriggeredStyle();
}

DwtMenuItem.prototype._mouseUpListener = 
function(ev) {
	if (ev.button != DwtMouseEvent.LEFT)
		return;

	if (this._style == DwtMenuItem.CHECK_STYLE) {
		this._deselect();
		this._setChecked(!this._itemChecked, ev);
		DwtMenu.closeActiveMenu();
	} else if (this._style == DwtMenuItem.RADIO_STYLE) {
		if (!this._itemChecked) {
			this._setChecked(!this._itemChecked, ev);
			if (this._menu) {
				this._popupMenu(0);
			} else {
				DwtMenu.closeActiveMenu();
			}
		} else if (this._menu){
			this._popupMenu(0);
		} else {
			DwtMenu.closeActiveMenu();
			// at the very least, notify menu item was clicked again
			var selEv = DwtShell.selectionEvent;
			if (ev)
				DwtUiEvent.copy(selEv, ev);
			else
				selEv.reset();
			selEv.item = this;
			selEv.detail = (this._itemChecked) ? DwtMenuItem.CHECKED : DwtMenuItem.UNCHECKED;
			this.notifyListeners(DwtEvent.SELECTION, selEv);			
		}
	} else if (this._style != DwtMenuItem.PUSH_STYLE) {
		if (this._menu) {
			// We know we have a menu to popup
			this._popupMenu(0);
		} else if (this.isListenerRegistered(DwtEvent.SELECTION)) {
			this._deselect();
			var selEv = DwtShell.selectionEvent;
			DwtUiEvent.copy(selEv, ev);
			selEv.item = selEv.dwtObj;
			selEv.detail = 0;
			this.notifyListeners(DwtEvent.SELECTION, selEv);
			DwtMenu.closeActiveMenu();
		}  else {
			this._deselect();
			DwtMenu.closeActiveMenu();
		}
	} else if (this._style == DwtMenuItem.PUSH_STYLE){
		if (this._menu){
			if (!this._isMenuPoppedup()){
				this._popupMenu(0);
			} else {
				this._deselect(0);
			}
		}
	}
	return true;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a menu object to menu items can be added. Menus can be created in various styles as
* follows:
*
* DwtMenu.BAR_STYLE - Traditional menu bar.
* DwtMenu.POPUP_STYLE - Popup menu
* DwtMenu.DROPDOWN_STYLE - Used when a menu is a drop down (e.g. parent is a button or another menu item);
* DwtMenu.COLOR_PICKER_STYLE - Menu is hosting a single color picker;
* DwtMenu.CALENDAR_PICKER_STYLE - Menu is hostng a single calendar; 
*
* @constructor
* @class
*
* @author Ross Dargahi
* @param parent		the parent widget
* @param style 		menu's style
* @param className	a CSS class
* @param posStyle	positioning style
* @param dialog 	Dialog that this menu is a part of (if any)
*/
function DwtMenu(parent, style, className, posStyle, dialog) {

	if (arguments.length == 0) return;
	if (parent) {
		if (parent instanceof DwtMenuItem || parent instanceof DwtButton)
			this._style = DwtMenu.DROPDOWN_STYLE;
		else
			this._style = style || DwtMenu.POPUP_STYLE;
		if (!posStyle) 
			posStyle = (this._style == DwtMenu.BAR_STYLE) ? DwtControl.STATIC_STYLE : DwtControl.ABSOLUTE_STYLE; 
	}
	className = className || "DwtMenu";

	// Hack to force us to hang off of the shell for positioning.
	DwtComposite.call(this, (parent instanceof DwtShell) ? parent : parent.shell, className, posStyle);
	this.parent = parent;
	if (parent == null) 
		return;
	this._dialog = dialog;
	
	var htmlElement = this.getHtmlElement();
	
	Dwt.setLocation(htmlElement, Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
	
	// Don't need to create table for color picker and calendar picker styles
	if (this._style != DwtMenu.COLOR_PICKER_STYLE && this._style != DwtMenu.CALENDAR_PICKER_STYLE) {
		this._table = document.createElement("table");
		this._table.border = 0;
		this._table.cellPadding = 0;
		this._table.cellSpacing = 0;
		htmlElement.appendChild(this._table);
		this._table.backgroundColor = DwtCssStyle.getProperty(htmlElement, "background-color");
	}

	if (style != DwtMenu.BAR_STYLE) {
		this.setZIndex(Dwt.Z_HIDDEN);
 		this._isPoppedup = false;		
	} else {
		DwtMenu._activeMenuIds.add(htmlElement.id);
		this._isPoppedup = true;
 	}
	this._popdownAction = new AjxTimedAction(this, this._doPopdown);
	this._popdownActionId = -1;
	this._popupAction = new AjxTimedAction(this, this._doPopup);
	this._popupActionId = -1;
 	if ((this.parent instanceof DwtMenuItem && this.parent.parent._style == DwtMenu.BAR_STYLE)
		|| !(this.parent instanceof DwtMenuItem)){
		this._outsideListener = new AjxListener(this, this._outsideMouseDownListener);
	}

	this._numCheckedStyleItems = 0;	
	this._menuItemsHaveIcons = false;
	this._menuItemsWithSubmenus = 0;
	
	/* The global capture is used to detect mouse down events outside of the popped up menus and specifically
	 * outside of our scope of influence (particularly when Dwt is being used in existing HTML */
	this._menuCapObj = new DwtMouseEventCapture(this, "DwtMenu", null, DwtMenu._capMouseDownHdlr, null, null, null, false)
}

DwtMenu.prototype = new DwtComposite;
DwtMenu.prototype.constructor = DwtMenu;

DwtMenu.prototype.toString = 
function() {
	return "DwtMenu";
}

DwtMenu.BAR_STYLE = 1;
DwtMenu.POPUP_STYLE = 2;
DwtMenu.DROPDOWN_STYLE = 3;
DwtMenu.COLOR_PICKER_STYLE =  4;
DwtMenu.CALENDAR_PICKER_STYLE = 5;

DwtMenu._activeMenuUp = false;
DwtMenu._activeMenuIds = new AjxVector();

DwtMenu.prototype.addPopupListener = 
function(listener) {
	this.addListener(DwtEvent.POPUP, listener);
}

DwtMenu.prototype.removePopupListener = 
function(listener) {
	this.removeListener(DwtEvent.POPUP, listener);
}

DwtMenu.prototype.addPopdownListener = 
function(listener) {
	this.addListener(DwtEvent.POPDOWN, listener);
}

DwtMenu.prototype.removePopdownListener = 
function(listener) {
	this.removeListener(DwtEvent.POPDOWN, listener);
}

DwtMenu.prototype.getItem =
function(index) {
	return this._children.get(index);
}

DwtMenu.prototype.getItemById =
function(key, id) {
	var items = this.getItems();
    for (var i = 0; i < items.length; i++) {
	    var itemId = items[i].getData(key);
		if (itemId == id)
			return items[i];
	}
	return null;
}

DwtMenu.prototype.getItemCount =
function() {
	return this._children.size();
}

DwtMenu.prototype.getItems =
function() {
	return this._children.getArray();
}

DwtMenu.prototype.getSelectedItem =
function(style) {
	var a = this._children.getArray();
	for (var i = 0; i < a.length; i++) {
		var mi = a[i];
		if ((!style || (mi._style == style)) && mi.getChecked())
			return mi;
	}
	return null;
}

DwtMenu.prototype.isPoppedup =
function() {
	return this._isPoppedup;
}

DwtMenu.prototype.popup =
function(msec, x, y) {
	if (this._style == DwtMenu.BAR_STYLE) 
		return;
	if (this._popdownActionId != -1) {
		AjxTimedAction.cancelAction(this._popdownActionId);
		this._popdownActionId = -1;
	} else {
		if (this._isPoppedup || (this._popupActionId != -1 && msec && msec > 0)) {
			return;
		} else if (this._popupActionId != -1){
			AjxTimedAction.cancelAction(this._popupActionId);
			this._popupActionId = -1;
		}
		if (!msec) {
			this._doPopup(x, y);
		} else {
			this._popupAction.args = [x, y];
			this._popupActionId = AjxTimedAction.scheduleAction(this._popupAction, msec);
		}
	}
}

DwtMenu.prototype.popdown =
function(msec) {
	if (this._style == DwtMenu.BAR_STYLE) return;

	if (this._popupActionId != -1) {
		AjxTimedAction.cancelAction(this._popupActionId);	
		this._popupActionId = -1;
	} else {
		if (!this._isPoppedup || this._popdownActionId != -1) 
			return;
		if (msec == null || msec == 0)
			this._doPopdown();
		else
			this._popdownActionId = AjxTimedAction.scheduleAction(this._popdownAction, msec);
	}
}

/**
 * This allows the caller to associate one object with the menu. Association
 * means, for events, treat the menu, and this object as one. If I click on
 * elements pertaining to this object, we will think of them as part of the
 * menu. 
 * @see _outsideMouseListener.
 */
DwtMenu.prototype.setAssociatedObj =
function(dwtObj) {
	this._associatedObj = dwtObj;
};

DwtMenu.prototype.setAssociatedElementId =
function(id){
	this._associatedElId = id;
}

/*
* Checks a menu item (the menu must be radio or checkbox style). The menu item
* is identified through the given field/value pair.
*
* @param field		a key for menu item data
* @param value		value for the data of the menu item to check
*/
DwtMenu.prototype.checkItem =
function(field, value, skipNotify) {
    var items = this._children.getArray();
    for (var i = 0; i < items.length; i++) {
    	var item = items[i];
		if (item._style != DwtMenuItem.CHECK_STYLE && item._style != DwtMenuItem.RADIO_STYLE)
			continue;
		var val = item.getData(field);
     	if (val == value)
    		item.setChecked(true, skipNotify);
    }
}

DwtMenu.prototype.setSelectedItem =
function(index) {
	var mi = this._children.get(index);
	mi.setSelectedStyle();
	this._externallySelected = mi;
};

DwtMenu.prototype.clearExternallySelectedItems =
function() {
	if (this._externallySelected != null) {
		this._externallySelected._deselect();
		this._externallySelected = null;
	}
};

DwtMenu.prototype.removeChild =
function(child) {
	if (this._style == DwtMenu.BAR_STYLE) {
		var cell = child.getHtmlElement().parentNode;
		this._table.rows[0].deleteCell(Dwt.getCellIndex(cell));
	} else {
		var sz = this._children.size();
		// If item we're removing is check/radio style, and its last such item 
		// in the menu, then we must instruct our other children to delete a 
		// "checked column" to ensure that things line up
		if (sz > 1 && (child._style == DwtMenuItem.CHECK_STYLE || child._style == DwtMenuItem.RADIO_STYLE)) {
			if (this._numCheckedStyleItems == 1) {
				var a = this._children.getArray();
				for (var i = 0; i < sz; i++) {
					if (a[i] != child)
						a[i]._checkedItemsRemoved();
				}
			}
			this._numCheckedStyleItems--;
		}
		
		// If item we're removing has a submenu, and its the last such item in 
		// the menu, then we must instruct our other children to delete their 
		// cascade cell to ensure that things line up
		if (sz > 1 && child.getMenu())
			this._submenuItemRemoved();
		
		this._table.deleteRow(child.getHtmlElement().parentNode.parentNode.rowIndex);
	}
	this._children.remove(child);
}

// Override DwtComposite.addChild to do nothing
DwtMenu.prototype.addChild = 
function(child) {
	// Color pickers and calendars are not menu aware so we have to deal with
	// them acordingly
	if ((child instanceof DwtColorPicker) || (child instanceof DwtCalendar))
		this._addItem(child);
}

DwtMenu.prototype._addItem =
function(item, index) {
	if (this._style == DwtMenu.COLOR_PICKER_STYLE || this._style == DwtMenu.CALENDAR_PICKER_STYLE) {
		// Item better be a color picker & we better not have any children
		if (this._children.size() > 0 || !(item.parent instanceof DwtMenu) 
			|| ((this._style == DwtMenu.COLOR_PICKER_STYLE && !(item instanceof DwtColorPicker))
			    || (this._style == DwtMenu.CALENDAR_PICKER_STYLE && !(item instanceof DwtCalendar))))
			new DwtException("Invalid child", DwtException.INVALID_PARAM, "DwtMenu.prototype._addItem");
		this._children.add(item);
		item.reparentHtmlElement(this.getHtmlElement());
	} else {
		var row;
		var col;
		if (this._style == DwtMenu.BAR_STYLE){
			var rows = this._table.rows;
			row = (rows.length != 0) ? rows[0]: this._table.insertRow(0);
			if (index == null || index > row.cells.length)
				index = rows.cells.length;
			col = row.insertCell(index);
			col.align = "center";
			col.vAlign = "middle";
			var spc = row.insertCell(-1);
			spc.nowrap = true;
			spc.width = "7px"
		} else {
			// If item we're adding is check/radio style, and its the first such 
			// item in the menu, then we must instruct our other children to add 
			// a "checked column" to ensure that things line up
			if (item._style == DwtMenuItem.CHECK_STYLE || item._style == DwtMenuItem.RADIO_STYLE) { 
				if (this._numCheckedStyleItems == 0) {
					var sz = this._children.size();
					if (sz > 0) {
						var a = this._children.getArray();
						for (var i = 0; i < sz; i++) {
							if (a[i]._style != DwtMenuItem.CHECK_STYLE && a[i]._style != DwtMenuItem.RADIO_STYLE)
								a[i]._checkItemAdded();
						}
					}
				}
				this._numCheckedStyleItems++;
			}
			if (index == null || index > this._table.rows.length)
				index = -1;
			row = this._table.insertRow(index);
			col = row.insertCell(0);
		}
		col.noWrap = true;
		col.appendChild(item.getHtmlElement());
		this._children.add(item, index);
	}
}

DwtMenu.prototype._radioItemSelected =
function(child, skipNotify) {
	var radioGroupId = child._radioGroupId;
	var sz = this._children.size();
	var a = this._children.getArray();
	for (var i = 0; i < sz; i++) {
		if (a[i] != child && a[i]._style == DwtMenuItem.RADIO_STYLE && a[i]._radioGroupId == radioGroupId
			&& a[i]._itemChecked) {
			a[i].setChecked(false, skipNotify);
			break;
		}
	}
}

DwtMenu.prototype._menuHasCheckedItems =
function() {
	return (this._numCheckedStyleItems > 0);
}

DwtMenu.prototype._menuHasSubmenus =
function() {
	return (this._menuItemsWithSubmenus > 0);
}

DwtMenu.prototype._menuHasItemsWithIcons =
function() {
	return this._menuItemsHaveIcons;
}

/* Once an icon is added to any menuItem, then the menu will be considered
 * to contain menu items with icons for perpetuity */
DwtMenu.prototype._menuItemHasIcon =
function(item) {
	if (!this._menuItemsHaveIcons) {
		var sz = this._children.size();
		if (sz > 0) {
			var a = this._children.getArray();
			for (var i = 0; i < sz; i++) {
				if (a[i] != item)
					a[i]._addIconCell();
			}
		}
	}
	this._menuItemsHaveIcons = true;
}

DwtMenu.prototype._submenuItemAdded =
function() {
	if (this._menuItemsWithSubmenus == 0) {
		var sz = this._children.size();
		var a = this._children.getArray();
		for (var i = 0; i < sz; i++)
			a[i]._submenuItemAdded();
	}
	this._menuItemsWithSubmenus++;
}

DwtMenu.prototype._submenuItemRemoved =
function() {
	if (this._menuItemsWithSubmenus == 1) {
		var sz = this._children.size();
		var a = this._children.getArray();
		for (var i = 0; i < sz; i++)
			a[i]._submenuItemRemoved();
	}
	this._menuItemsWithSubmenus--;
}


DwtMenu.prototype._doPopup =
function(x, y) {
	var ws = this.shell.getSize();
	var s = this.getSize();

	if (((this._style == DwtMenu.POPUP_STYLE || (this._style == DwtMenu.DROPDOWN_STYLE && this.parent instanceof DwtMenuItem)) && s.y >= ws.y) || 
		(this._style == DwtMenu.DROPDOWN_STYLE && y + s.y >= ws.y)) {
		var space = this._style == DwtMenu.POPUP_STYLE || (this._style == DwtMenu.DROPDOWN_STYLE && this.parent instanceof DwtMenuItem) ? ws.y : ws.y - y;
		var rows = this._table.rows;
		var numRows = rows.length;
		var height = s.y;
		for (var i = numRows - 1; i >= 0; i--) {
			var row = rows[i];
			// bug fix #6904 - safari returns zero for row heights 
			// (see http://bugzilla.opendarwin.org/show_bug.cgi?id=7242), 
			// so hardcode for now
			height -= AjxEnv.isSafari ? 15 : Dwt.getSize(row).y;
			if (height < space) {
				break;
			}
		}
		var count = i;
		for (var j = count; j < numRows; j++) {
			var row = rows[(j - count) % count];
			var cell = row.insertCell(-1);
			cell.className = "DwtMenuCascadeCell";
			var child = rows[j].cells[0].firstChild;
			while (child != null) {
				cell.appendChild(child);
				child = child.nextSibling;
			}
		}
		for (j = rows.length - 1; j >= count; j--) {
			this._table.deleteRow(count);
		}
		var offset = numRows % count;
		if (offset > 0) {
			for (var j = offset; j < count; j++) {
				var row = rows[j];
				var cell = row.insertCell(-1);
				cell.className = "DwtMenuCascadeCell";
				cell.empty = true;
				cell.innerHTML = "&nbsp;";
			}
		}
		
		s = this.getSize();
	}

	// Popup menu type
	var newX = ((x + s.x) >= ws.x) ? x - (x + s.x - ws.x): x;
	var newY = ((y + s.y) >= ws.y) ? y - (y + s.y - ws.y) : y;	
	this.setLocation(newX, newY);	
	
	this.notifyListeners(DwtEvent.POPUP, this);

	// Hide the tooltip
	var tooltip = this.shell.getToolTip();
	if (tooltip)
		tooltip.popdown();

	// 5/2/2005
	// EMC -- changed this to Z_DIALOG_MENU so that you don't have to pass 
	// dialog object. This helps if you are adding an object to a dialog -- 
	// where the object doesn't know anything about its container.
	// var zIndex = this._dialog ? this._dialog.getZIndex() + Dwt.Z_INC : Dwt.Z_MENU;
	var zIndex = this._dialog ? Dwt.Z_DIALOG_MENU : Dwt.Z_MENU;
	this.setZIndex(zIndex);
	this._popupActionId = -1;
	this._isPoppedup = true;
	if (this._outsideListener) {
		this.shell._setEventHdlrs([DwtEvent.ONMOUSEDOWN,DwtEvent.ONMOUSEWHEEL]);
		this.shell.addListener(DwtEvent.ONMOUSEDOWN, this._outsideListener);
		this.shell.addListener(DwtEvent.ONMOUSEWHEEL, this._outsideListener);
	}
	if (!DwtMenu._activeMenu) {
		DwtMenu._activeMenu = this;
		DwtMenu._activeMenuUp = true;
		DwtEventManager.addListener(DwtEvent.ONMOUSEDOWN, DwtMenu._outsideMouseDownListener);
		DwtEventManager.addListener(DwtEvent.ONMOUSEWHEEL, DwtMenu._outsideMouseDownListener);
	}

	DwtMenu._activeMenuIds.add(this._htmlElId);
	DwtMenu._activeMenuIds.sort();	
	
	// Capture events only if we are not a sub-menu. Event capturing is to catch mouse-events outside
	// of our framework (esp. vital when DWT is being used in existing HTML content)
	if (!this._menuCapObj.capturing()) {
		this._menuCapObj.capture();	
		this._capturing = true;
	} else {
		this._capturing = false;
	}
	
	// NOTE: This hack is needed for FF/Moz because the containing div
	//       allows the inner table to overflow. When the menu cascades
	//       and the menu items get pushed off of the visible area, the
	//       div's border doesn't surround the menu items. This hack
	//       forces the outer div's width to surround the table.
	if (AjxEnv.isGeckoBased && this._table) {
		var htmlEl = this.getHtmlElement();
		htmlEl.style.width = s.x + "px";
	}
};

DwtMenu.prototype.getSize =
function(incScroll) {
	if (this._table) {
		return Dwt.getSize(this._table, incScroll);
	}
	return DwtComposite.prototype.getSize.call(this, incScroll);
};

DwtMenu.prototype._doPopdown =
function() {
	// Notify all sub menus to pop themselves down
	var a = this._children.getArray();
	var s = this._children.size();
	for (var i = 0; i < s; i++) {
		if ((a[i] instanceof DwtMenuItem) && a[i]._style != DwtMenuItem.SEPARATOR_STYLE)
			a[i]._popdownMenu();
	}
	this.setZIndex(Dwt.Z_HIDDEN);
	this.setLocation(Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
	
	this.notifyListeners(DwtEvent.POPDOWN, this);
	
	// TODO: release capture if you have it
	if (this._outsideListener) {
		this.shell._setEventHdlrs([DwtEvent.ONMOUSEDOWN,DwtEvent.ONMOUSEWHEEL], true);
		this.shell.removeListener(DwtEvent.ONMOUSEDOWN, this._outsideListener);
		this.shell.removeListener(DwtEvent.ONMOUSEWHEEL, this._outsideListener);
	}

	if (DwtMenu._activeMenu == this) {
		DwtMenu._activeMenu = null;
		DwtMenu._activeMenuUp = false;
		DwtEventManager.removeListener(DwtEvent.ONMOUSEDOWN, DwtMenu._outsideMouseDownListener);
		DwtEventManager.removeListener(DwtEvent.ONMOUSEWHEEL, DwtMenu._outsideMouseDownListener);
	}
	DwtMenu._activeMenuIds.remove(this._htmlElId);
	this._popdownActionId = -1;
	this._isPoppedup = false;
	
	if (this._capturing) {
		this._menuCapObj.release();
		this._capturing = false;
	}

	if ((this._style == DwtMenu.POPUP_STYLE || this._style == DwtMenu.DROPDOWN_STYLE) &&
		this._table.rows.length && this._table.rows[0].cells.length) {
		var numColumns = this._table.rows[0].cells.length;
		var numRows = this._table.rows.length;
		for (var i = 1; i < numColumns; i++) {
			for (var j = 0; j < numRows; j++) {
				var cell = this._table.rows[j].cells[i];
				if (!cell.empty) {
					var child = cell.firstChild;
					var row = this._table.insertRow(this._table.rows.length);
					var cell = row.insertCell(0);
					while (child != null) {
						cell.appendChild(child);
						child = child.nextSibling;
					}
				}
			}
		}
		for (var j = 0; j < numRows; j++) {
			var row = this._table.rows[j];
			for (var i = row.cells.length - 1; i > 0; i--) {
				row.deleteCell(i);
			}
		}
	}
};

DwtMenu.prototype._getActiveItem = 
function(){
	var a = this._children.getArray();
	var s = this._children.size();
	for (var i = 0; i < s; i++) {
		if (a[i]._isMenuPoppedup())
			return a[i];
	}
	return null;
}

/* Note that a hack has been added to DwtHtmlEditor to call this method when the 
 * editor gets focus. The reason for this is that the editor uses an Iframe 
 * whose events are independent of the menu's document. In this case event will 
 * be null.
 */
DwtMenu._outsideMouseDownListener =
function(ev) {
    if (DwtMenu._activeMenuUp) {
		// figure out if we are over the menu that is up
		var menu = DwtMenu._activeMenu;
		var nearestDwtObj = DwtUiEvent.getDwtObjFromEvent(ev);
		if (menu._associatedObj && menu._associatedObj == nearestDwtObj) {
			return false;
		}

		// assuming that the active menu is the parent of all other menus
		// that are up, search through the array of child menu dom IDs as
		// well as our own.
		var id = menu._htmlElId;
		var htmlEl = DwtUiEvent.getTarget(ev);
		while (htmlEl != null) {
			if (htmlEl.id && htmlEl.id != "" && 
				(htmlEl.id == id || htmlEl.id == menu._associatedElId ||
				 DwtMenu._activeMenuIds.binarySearch(htmlEl.id) != -1 )) {
				return false;
			}
			htmlEl = htmlEl.parentNode;
		}

		// If we've gotten here, the mousedown happened outside the active
		// menu, so we hide it.
		menu.popdown();
	}
	// propagate the event
	ev._stopPropagation = false;
	ev._returnValue = true;
	return true;
};

DwtMenu._capMouseDownHdlr =
function(ev) {
	var menu = DwtMouseEventCapture.getTargetObj();
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	DwtMenu._outsideMouseDownListener(mouseEv);
	DwtUiEvent.setBehaviour(ev, false, true);
	return true;
}

/*
* Returns true if any menu is currently popped up.
*/
DwtMenu.menuShowing =
function() {
	return DwtMenu._activeMenuUp;
};

DwtMenu.closeActiveMenu =
function() {
	if (DwtMenu._activeMenuUp){
		DwtMenu._activeMenu.popdown();
	}
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a new message dialog.
* @constructor
* @class
* This class represents a reusable message dialog box. Messages can be informational, warning, or
* critical.
*/
function DwtMessageDialog(parent, className, buttons, extraButtons) {
	if (arguments.length == 0) return;
	this._msgCellId = Dwt.getNextId();
	buttons = buttons ? buttons : [DwtDialog.OK_BUTTON];
	DwtDialog.call(this, parent, className, null, buttons, extraButtons);
	this.setContent(this._contentHtml());
	this._msgCell = document.getElementById(this._msgCellId);
	this.addEnterListener(new AjxListener(this, this._enterListener));
};

DwtMessageDialog.prototype = new DwtDialog;
DwtMessageDialog.prototype.constructor = DwtMessageDialog;

DwtMessageDialog.CRITICAL_STYLE = 1;
DwtMessageDialog.INFO_STYLE = 2;
DwtMessageDialog.WARNING_STYLE = 3;

DwtMessageDialog.TITLE = new Object();
DwtMessageDialog.TITLE[DwtMessageDialog.CRITICAL_STYLE] = AjxMsg.criticalMsg;
DwtMessageDialog.TITLE[DwtMessageDialog.INFO_STYLE] = AjxMsg.infoMsg
DwtMessageDialog.TITLE[DwtMessageDialog.WARNING_STYLE] = AjxMsg.warningMsg;

DwtMessageDialog.ICON = new Object();
DwtMessageDialog.ICON[DwtMessageDialog.CRITICAL_STYLE] = "Critical_32";
DwtMessageDialog.ICON[DwtMessageDialog.INFO_STYLE] = "Information_32";
DwtMessageDialog.ICON[DwtMessageDialog.WARNING_STYLE] = "Warning_32";


// Public methods

DwtMessageDialog.prototype.toString = 
function() {
	return "DwtMessageDialog";
};

/**
* Sets the message style (info/warning/critical) and content.
*
* @param msgStr		message text
* @param detailStr	additional text to show via Detail button
* @param style		style (info/warning/critical)
* @param title		dialog box title
*/
DwtMessageDialog.prototype.setMessage =
function(msgStr, style, title) {
	style = style ? style : DwtMessageDialog.INFO_STYLE;
	title = title ? title : DwtMessageDialog.TITLE[style];
	this.setTitle(title);
	if (msgStr) {
		var html = new Array();
		var i = 0;
		html[i++] = "<table cellspacing=0 cellpadding=0 border=0><tr>";
		html[i++] = "<td valign='top'>";
		html[i++] = AjxImg.getImageHtml(DwtMessageDialog.ICON[style]);
		html[i++] = "</td><td class='DwtMsgArea'>";
		html[i++] = msgStr;
		html[i++] = "</td></tr></table>";
		this._msgCell.innerHTML = html.join("");
	} else {
		this._msgCell.innerHTML = "";
	}
};

/**
* Resets the message dialog so it can be reused.
*/
DwtMessageDialog.prototype.reset = 
function() {
	this._msgCell.innerHTML = "";
	DwtDialog.prototype.reset.call(this);
};

// Private methods

DwtMessageDialog.prototype._contentHtml = 
function() {
	return "<div id='" + this._msgCellId + "' class='DwtMsgDialog'></div>";
};

DwtMessageDialog.prototype._enterListener =
function(ev) {
	this._runEnterCallback();
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/** 
 * Html Editor
 *
 * @author Ross Dargahi
 */
function DwtHtmlEditor(parent, className, posStyle, content, mode, blankIframeSrc) {
	if (arguments.length == 0) return;
	this.setBlankIframeSrc(blankIframeSrc);
	className = className || "DwtHtmlEditor";
	DwtComposite.call(this, parent, className, posStyle);
	
	this._mode = mode == DwtHtmlEditor.HTML && this.isHtmlEditingSupported()
		? mode : DwtHtmlEditor.TEXT;

	this.__eventClosure = AjxCallback.simpleClosure(this.__eventClosure, this);

	// init content
	this._initialStyle = this._getInitialStyle(true);
	var initialHtml = "<html><head>" + this._getInitialStyle(false) + "</head><body></body></html>";
	if (!content)
		content = this._mode == DwtHtmlEditor.HTML ? initialHtml : "";
	
	this._pendingContent = content;
	this._htmlModeInited = false;

	this._initialize();
}

DwtHtmlEditor.prototype = new DwtComposite();
DwtHtmlEditor.prototype.constructor = DwtHtmlEditor;

// Modes
DwtHtmlEditor.HTML = 1;
DwtHtmlEditor.TEXT = 2;

// Styles
DwtHtmlEditor.H1 = 1;
DwtHtmlEditor.H2 = 2;
DwtHtmlEditor.H3 = 3;
DwtHtmlEditor.H4 = 4;
DwtHtmlEditor.H5 = 5;
DwtHtmlEditor.H6 = 6;
DwtHtmlEditor.PARAGRAPH = 7;
DwtHtmlEditor.ADDRESS = 8;
DwtHtmlEditor.PREFORMATTED = 9;

DwtHtmlEditor._STYLES = ["", "<h1>", "<h2>", "<h3>", "<h4>", "<h5>", "<h6>", "<p>", "<address>", "<pre>"];

// Font Family
DwtHtmlEditor.ARIAL = 1;
DwtHtmlEditor.COURIER = 2;
DwtHtmlEditor.TIMES = 3;
DwtHtmlEditor.VERDANA = 4;

// Font Styles
DwtHtmlEditor.BOLD_STYLE = "bold";
DwtHtmlEditor.ITALIC_STYLE = "italic";
DwtHtmlEditor.UNDERLINE_STYLE = "underline";
DwtHtmlEditor.STRIKETHRU_STYLE = "strikethrough";
DwtHtmlEditor.SUBSCRIPT_STYLE = "subscript";
DwtHtmlEditor.SUPERSCRIPT_STYLE = "superscript";

// Justification
DwtHtmlEditor.JUSTIFY_LEFT = "justifyleft";
DwtHtmlEditor.JUSTIFY_CENTER = "justifycenter";
DwtHtmlEditor.JUSTIFY_RIGHT = "justifyright";
DwtHtmlEditor.JUSTIFY_FULL = "justifyfull";

// Indent
DwtHtmlEditor.OUTDENT = "outdent";
DwtHtmlEditor.INDENT = "indent";

// Elements
DwtHtmlEditor.HORIZ_RULE = "inserthorizontalrule";
DwtHtmlEditor.ORDERED_LIST = "insertorderedlist";
DwtHtmlEditor.UNORDERED_LIST = "insertunorderedlist";

// Direction
DwtHtmlEditor.DIRECTION_R2L;
DwtHtmlEditor.DIRECTION_L2R;

// PRIVATE Class Attributes

// Font Family Definitions & RegExs
DwtHtmlEditor._ARIAL = "Arial, Helvetica, sans-serif";
DwtHtmlEditor._COURIER = "Courier New, Courier, mono";
DwtHtmlEditor._TIMES = "Times New Roman, Times, serif";
DwtHtmlEditor._VERDANA = "Verdana, Arial, Helvetica, sans-serif";

DwtHtmlEditor._ARIAL_RE = /arial|helvetica|sans-serif/;
DwtHtmlEditor._TIMES_RE = /times|serif/;
DwtHtmlEditor._VERDANA_RE = /verdana/;
DwtHtmlEditor._COURIER_RE = /courier|mono/;


DwtHtmlEditor._H1_RE = /Heading 1|h1/;
DwtHtmlEditor._H2_RE = /Heading 2|h2/;
DwtHtmlEditor._H3_RE = /Heading 2|h3/;
DwtHtmlEditor._H4_RE = /Heading 2|h4/;
DwtHtmlEditor._H5_RE = /Heading 2|h5/;
DwtHtmlEditor._H6_RE = /Heading 2|h6/;
DwtHtmlEditor._PARAGRAPH_RE = /Normal|p/;
DwtHtmlEditor._ADDRESS_RE = /Address|address/;
DwtHtmlEditor._PREFORMATTED_RE = /Formatted|pre/;

DwtHtmlEditor._FONT_NAME = "fontname";
DwtHtmlEditor._FONT_SIZE = "fontsize";
DwtHtmlEditor._FONT_COLOR = "forecolor";
DwtHtmlEditor._FONT_HILITE = "hilitecolor";
DwtHtmlEditor._FONT_HILITE_IE = "backcolor";
DwtHtmlEditor._FORMAT_BLOCK = "formatblock";

/*cut
copy
paste
undo
redo
*/

DwtHtmlEditor._INITDELAY = 50;


DwtHtmlEditor._BLOCK_ELEMENTS = {
	address:1, body:1, div:1, dl:1, fieldset:1, form:1, h1:1, h2:1, h3:1, h4:1, h5:1, h6:1, 
	iframe:1, li:1, ol:1, p:1, pre:1, quote:1, table:1, tbody:1, td:1, textarea:1, tfoot: 1, 
	thead:1, tr:1, ul:1
};

DwtHtmlEditor._KEY2CMDS = {
	"b":DwtHtmlEditor.BOLD_STYLE, "i":DwtHtmlEditor.ITALIC_STYLE, "u":DwtHtmlEditor.UNDERLINE_STYLE, 
	"s":DwtHtmlEditor.STRIKETHRU_STYLE, "l":DwtHtmlEditor.JUSTIFY_LEFT, "e":DwtHtmlEditor.JUSTIFY_CENTER, 
	"r":DwtHtmlEditor.JUSTIFY_RIGHT, "j":DwtHtmlEditor.JUSTIFY_FULL, "1":DwtHtmlEditor._STYLES[1],
	"2":DwtHtmlEditor._STYLES[1], "3":DwtHtmlEditor._STYLES[3], "4":DwtHtmlEditor._STYLES[4], 
	"5":DwtHtmlEditor._STYLES[5], "6":DwtHtmlEditor._STYLES[6], "0":"DUMP"
};

DwtHtmlEditor.prototype.focus =
function() {
	if (this._mode == DwtHtmlEditor.TEXT) {
		document.getElementById(this._textAreaId).focus();
	} else {
		try {
			this._getIframeWin().focus();
			// Hack to fix IE focusing bug
			if (AjxEnv.isIE) {
				if (this._currInsPt) {
					if (this._currInsPt.text.length <= 1)
						this._currInsPt.collapse(false);
					this._currInsPt.select();
				}
			}
		} catch (ex) {
			// whateva
		}
	}
}

DwtHtmlEditor.prototype.addStateChangeListener = 
function(listener) {
	this.addListener(DwtEvent.STATE_CHANGE, listener);
}

DwtHtmlEditor.prototype.removeStateChangeListener = 
function(listener) { 
	this.removeListener(DwtEvent.STATE_CHANGE, listener);
}

DwtHtmlEditor.prototype.clear =
function() {
	this.setContent("");
}

DwtHtmlEditor.prototype.enable =
function(enable) {
	if (this._textAreaId != null)
		document.getElementById(this._textAreaId).disabled = !enable;
	if (this._iFrameId != null)
		document.getElementById(this._iframeId).disabled = !enable;
}

DwtHtmlEditor.prototype.setBlankIframeSrc = 
function(src) {
	this._blankIframeSrc = src;
};

DwtHtmlEditor.prototype.isHtmlEditingSupported =
function() {
	return (!AjxEnv.isGeckoBased && !AjxEnv.isIE) ? false : true;
}

/**
 * Get the content
*/
DwtHtmlEditor.prototype.getContent =
function() {
	if (this._mode == DwtHtmlEditor.HTML) {
		var iframeDoc = this._getIframeDoc();
		return iframeDoc && iframeDoc.body ? (this._initialStyle + this._getIframeDoc().body.innerHTML) : "";
	} else {
		return document.getElementById(this._textAreaId).value;
	}
}

/**
 * Set the content to be displayed. This can be HTML
*/
DwtHtmlEditor.prototype.setContent =
function(content) {
	if (this._mode == DwtHtmlEditor.HTML) {
		// If the html is initialed then go ahead and set the content, else let the
		// _finishHtmlModeInit run before we try setting the content
		if (this._htmlModeInited) {
			this._pendingContent = content ? ((content instanceof AjxVector) ? content[0] : content) : "";
			this._setContentOnTimer();
		} else {
			var ta = new AjxTimedAction(this, this.setContent, [content]);
			AjxTimedAction.scheduleAction(ta, DwtHtmlEditor._INITDELAY + 1);
		}
	} else {
		document.getElementById(this._textAreaId).value = (content || "");
	}
}

DwtHtmlEditor.prototype.insertElement =
function(element) {
	this._execCommand(element);
}

/** Inserts a table at the current cursor position 
 * 
 * @param rows [Int] - The number of rows in the table
 * @param cols [Int] - The number of columns in the table
 * @param width [String] - The width of the table. The units should be part of this value e.g. "100%" or "10px"
 * @param cellSpacing [Int] - Cell spacing in the table
 * @param cellPadding [Int] - Cell padding in the table
 * @param alignment [String] - The alignment of the table. This is one of valid alignment values for the HTML
 *    <table> element 
 */
DwtHtmlEditor.prototype.insertTable =
function(rows, cols, width, cellSpacing, cellPadding, alignment) {
DBG.println("Rows: " + rows);
DBG.println("Cols: " + cols);
DBG.println("Width: " + width);
DBG.println("CellSpacing: " + cellSpacing);
DBG.println("CellPadding: " + cellPadding);
DBG.println("alignment: " + alignment);
	if (this._mode != DwtHtmlEditor.HTML)
		return;
    
	var doc = this._getIframeDoc();
	var table = doc.createElement("table");
  
	if (width) table.width = width;
	if (alignment) table.align = alignment.toLowerCase();
	if (cellSpacing) table.cellSpacing = cellSpacing; 
	if (cellPadding) table.cellPadding = cellPadding;
	
	table.border = 1;
	table.style.border = "1px solid #000";   
    table.rules = "all";
	table.style.borderCollapse = "collapse";
  
  	var tdWidth = "";
  	if (1)
  		tdWidth = Math.floor(100 / cols) + "%";

	var tbody = doc.createElement("tbody");
	table.appendChild(tbody); 		
	for (var i = 0; i < rows; i++) {
		var tr = doc.createElement("tr");
		tbody.appendChild(tr);
		for (var j = 0; j < cols; j++) {
			var td = doc.createElement("td");
			if (tdWidth)
				td.style.width = tdWidth;
			if (AjxEnv.isGeckoBased)
				td.appendChild(doc.createElement("br"));
			tr.appendChild(td);
    	}
	}
  
	this._insertNodeAtSelection(table);
}

DwtHtmlEditor.prototype._insertNodeAtSelection =
function(node) {
	if (!AjxEnv.isIE) {
		var range = this._getRange();
		this._getIframeWin().getSelection().removeAllRanges()
		range.deleteContents();
		range.insertNode(node);
		range.selectNodeContents(node);
	} else {
		this._getRange().pasteHTML(node.outerHTML);
	}
}


/**
* Changes the editor mode.
*
* @param mode	The new mode
* @param convert	If new mode -> HTML and convert, then the content of the widget is escaped. If
*		mode -> Text and convert, then text is stripped out of content
*/
DwtHtmlEditor.prototype.setMode =
function(mode, convert) {
	if (mode == this._mode || 
		(mode != DwtHtmlEditor.HTML && mode != DwtHtmlEditor.TEXT))
	{
		return;
	}

	this._mode = mode;
	if (mode == DwtHtmlEditor.HTML) {
		var textArea = document.getElementById(this._textAreaId);
		var iFrame;
		var idoc = this._getIframeDoc();

		// bug fix #6788 - Safari seems to lose its document so recreate
		if (this._iFrameId != null && idoc) {
			idoc.body.innerHTML = (convert) 
				? AjxStringUtil.convertToHtml(textArea.value) 
				: textArea.value;
			iFrame = document.getElementById(this._iFrameId);
		} else {
			iFrame = this._initHtmlMode((convert) 
				? AjxStringUtil.convertToHtml(textArea.value) 
				: textArea.value);
		}
		Dwt.setVisible(textArea, false);
		Dwt.setVisible(iFrame, true);

		// XXX: mozilla hack
		if (AjxEnv.isGeckoBased)
			this._enableDesignMode(this._getIframeDoc());
	} else {
		var textArea = this._textAreaId != null
			? document.getElementById(this._textAreaId)
			: this._initTextMode(true);
		
		// If we have pending content, then an iFrame is being created. This can happen
		// if the widget is instantiated and immediate setMode is called w/o getting out
		// to the event loop where _finishHtmlMode is triggered
		var content = (!this._pendingContent) 
			? this._getIframeDoc().innerHTML 
			: (this._pendingContent || "");

		textArea.value = (convert) 
			? this._convertHtml2Text() 
			: this._getIframeDoc().innerHTML;;

		Dwt.setVisible(document.getElementById(this._iFrameId), false);
		Dwt.setVisible(textArea, true);	
	}
}

DwtHtmlEditor.prototype.setTextDirection =
function(direction) {
	if (this._mode != DwtHtmlEditor.HTML)
		return;
		
	var dir = (direction == DwtHtmlEditor.DIRECTION_R2L) ? "rtl" : "ltr";
	var el = this._getParentElement();
	
	DBG.println("EL: " + el.tagName.toLowerCase() + " - " + DwtHtmlEditor._BLOCK_ELEMENTS[el.tagName.toLowerCase()]);

	while (el && !DwtHtmlEditor._BLOCK_ELEMENTS[el.tagName.toLowerCase()])
		el = el.parentNode;
		
	if (el)
		el.style.direction = el.style.direction == dir ? "" : dir;
}

// Font sizes should be 1-7
DwtHtmlEditor.prototype.setFont =
function(family, style, size, color, hiliteColor) {
	if (family) {
		switch (family) {
			case DwtHtmlEditor.ARIAL:
				this._execCommand(DwtHtmlEditor._FONT_NAME, DwtHtmlEditor._ARIAL);
				break;			
			case DwtHtmlEditor.COURIER:
				this._execCommand(DwtHtmlEditor._FONT_NAME, DwtHtmlEditor._COURIER);
				break;			
			case DwtHtmlEditor.TIMES:
				this._execCommand(DwtHtmlEditor._FONT_NAME, DwtHtmlEditor._TIMES);
				break;	
			case DwtHtmlEditor.VERDANA:
				this._execCommand(DwtHtmlEditor._FONT_NAME, DwtHtmlEditor._VERDANA);
				break;	
		}
	}
	
	if (style)
		this._execCommand(style);
		
	if (size && size > 0 && size < 8)
		this._execCommand(DwtHtmlEditor._FONT_SIZE, size);
		
	if (color)
		this._execCommand(DwtHtmlEditor._FONT_COLOR, color);

	if (hiliteColor)
		this._execCommand((AjxEnv.isIE) ? DwtHtmlEditor._FONT_HILITE_IE : DwtHtmlEditor._FONT_HILITE, hiliteColor);
}

DwtHtmlEditor.prototype.setJustification =
function(justification) {
	this._execCommand(justification);
}

DwtHtmlEditor.prototype.setIndent =
function(indent) {
	this._execCommand(indent);
}

DwtHtmlEditor.prototype.setStyle =
function(style) {
	this._execCommand(DwtHtmlEditor._FORMAT_BLOCK, DwtHtmlEditor._STYLES[style]);
}

DwtHtmlEditor.prototype.setSize =
function(width, height) {
	DwtComposite.prototype.setSize.call(this, width, height);
	var htmlEl = this.getHtmlElement();
	
	if (this._iFrameId != null) {
		var iFrame = document.getElementById(this._iFrameId);
		iFrame.width = htmlEl.style.width;
		iFrame.height = htmlEl.style.height;
	} else {
		var textArea = document.getElementById(this._textAreaId);
		textArea.style.width = htmlEl.style.width;
		textArea.style.height = htmlEl.style.height;
	}
}

DwtHtmlEditor.prototype.getIframe = 
function() {
	return document.getElementById(this._iFrameId);
}

DwtHtmlEditor.prototype._initialize = 
function() {
	if (this._mode == DwtHtmlEditor.HTML) 
		this._initHtmlMode(this._pendingContent);
	else
		this._initTextMode();
}

DwtHtmlEditor.prototype._initTextMode =
function(ignorePendingContent) {
	var htmlEl = this.getHtmlElement();
	this._textAreaId = "textarea_" + Dwt.getNextId();
	var textArea = document.createElement("textarea");
	textArea.className = "DwtHtmlEditorTextArea";
	textArea.id = this._textAreaId;
	htmlEl.appendChild(textArea);
	
	// We will ignore pending content if we are called from setMode. See setMode for
	// documentation
	if (!ignorePendingContent) {
		textArea.value = this._pendingContent;
		this._pendingContent = null;
	}
	return textArea;
}

DwtHtmlEditor.prototype._initHtmlMode =
function(content) {
	var iFrame = this._createIFrameEl();

	this._keyEvent = new DwtKeyEvent();
	this._stateEvent = new DwtHtmlEditorStateEvent();
	this._stateEvent.dwtObj = this;

	this._updateStateAction = new AjxTimedAction(this, this._updateState);

	this._pendingContent = content || "";

	// IE can sometimes race ahead and execute script before the underlying component is created
	var timedAction = new AjxTimedAction(this, this._finishHtmlModeInit);
	AjxTimedAction.scheduleAction(timedAction, DwtHtmlEditor._INITDELAY);
	
	return iFrame;
}

/**
* @param useDiv 	Set this to true if prepending to the message body. False is 
* 					used to set the default settings for compose editor so as 
* 					you type the fonts appear as they would if the message we 
* 					being read by the receiver
*/
DwtHtmlEditor.prototype._getInitialStyle = 
function(useDiv) {
	var initFontFamily = this._getInitialFontFamily();
	var initFontSize = this._getInitialFontSize();
	var initFontColor = this._getInitialFontColor();

	var html = new Array();
	var i = 0;
	
	if (useDiv) {
		html[i++] = "<div style='";
		html[i++] = "font-family:" + initFontFamily + ";";
		html[i++] = "font-size:" + initFontSize + ";";
		html[i++] = "color:" + initFontColor + ";";
		html[i++] = "'>";
	} else {
		html[i++] = "<style type='text/css'>";
		html[i++] = "p { ";
		html[i++] = "font-family:" + initFontFamily + ";";
		html[i++] = "font-size:" + initFontSize + ";";
		html[i++] = "color:" + initFontColor + ";";
		html[i++] = " } ";
		html[i++] = "body { ";
		html[i++] = "font-family:" + initFontFamily + ";";
		html[i++] = "font-size:" + initFontSize + ";";
		html[i++] = "color:" + initFontColor + ";";
		html[i++] = " } ";
		html[i++] = "</style>";
	}
	return html.join("");
}

// overload me to initialize to different font family
DwtHtmlEditor.prototype._getInitialFontFamily = 
function() {
	return DwtHtmlEditor._TIMES;
}

// overload me to initialize to different font size
DwtHtmlEditor.prototype._getInitialFontSize = 
function() {
	return "12pt";
}

// overload me to initialize to different font color
DwtHtmlEditor.prototype._getInitialFontColor = 
function() {
	return "black";
}

DwtHtmlEditor.prototype._createIFrameEl = 
function() {
	var htmlEl = this.getHtmlElement();
	this._iFrameId = "iframe_" + Dwt.getNextId();
	var iFrame = document.createElement("iframe");
	iFrame.id = this._iFrameId;
	iFrame.className = "DwtHtmlEditorIFrame";
	iFrame.setAttribute("border", "0", false);
	iFrame.setAttribute("frameborder", "0", false);
	iFrame.setAttribute("vspace", "0", false);
// 	iFrame.setAttribute("marginwidth", "0", false);
// 	iFrame.setAttribute("marginheight", "0", false);
	if (AjxEnv.isIE && location.protocol == "https:")
		iFrame.src = this._blankIframeSrc || "";
	htmlEl.appendChild(iFrame);
	
	return iFrame;
}

DwtHtmlEditor.prototype._finishHtmlModeInit =
function(params) {
	var doc = this._getIframeDoc();	
	try {
		doc.body.innerHTML = this._pendingContent || "";
	} catch (ex) {
		DBG.println("XXX: Error initializing HTML mode :XXX");
		return;
	}

	this._enableDesignMode(doc);
	this.focus();
	this._updateState();
	this._htmlModeInited = true;

	// bug fix #4722 - setting design mode for the first time seems to null 
	// out iframe doc's body in IE - so create a new body...
	if (AjxEnv.isIE) {
		doc.open();
		doc.write("");
		doc.close();
		doc.body.innerHTML = this._pendingContent || "";
	}

	this._registerEditorEventHandlers(document.getElementById(this._iFrameId), doc);
}

DwtHtmlEditor.prototype._getIframeDoc =
function() {
	return Dwt.getIframeDoc(document.getElementById(this._iFrameId));
}

DwtHtmlEditor.prototype._getIframeWin =
function() {
	return Dwt.getIframeWindow(document.getElementById(this._iFrameId));
}

DwtHtmlEditor.prototype._getParentElement = 
function() {
	if (AjxEnv.isIE) {
		var iFrameDoc = this._getIframeDoc();
		var selection = iFrameDoc.selection;
		var range = selection.createRange();
		if (selection.type == "None" || selection.type == "Text")
			// If selection is None still have a parent element
			return selection.createRange().parentElement();
		else if (selection.type == "Control")
			return selection.createRange().item(0);
		else
			return iFrameDoc.body;
	} else {
		try {
			var range = this._getRange();
			var p = range.commonAncestorContainer;
			if (!range.collapsed && range.startContainer == range.endContainer 
				&& range.startOffset - range.endOffset <= 1 && range.startContainer.hasChildNodes())
				p = range.startContainer.childNodes[range.startOffset];
			while (p.nodeType == 3)
				p = p.parentNode;
			return p;
		} catch (e) {
			return null;
		}
	}
}

DwtHtmlEditor.prototype._getRange =
function() {
	var iFrameDoc = this._getIframeDoc();
	if (AjxEnv.isIE) {
		return iFrameDoc.selection;
	} else {
		this.focus();
		var selection = this._getIframeWin().getSelection();
		if (selection != null) {
			try {
				return selection.getRangeAt(0);
			} catch(e) {
				return iFrameDoc.createRange();
			}
		} else {
			return iFrameDoc.createRange();
		}
	}
}

// This is transformed into a "simple closure" in the constructor.  Simply
// dispatch the call to _handleEditorEvent passing the right event depending on
// the browser.
DwtHtmlEditor.prototype.__eventClosure =
function(ev) {
	return this._handleEditorEvent(AjxEnv.isIE ? this._getIframeWin().event : ev);
};

DwtHtmlEditor.prototype._registerEditorEventHandlers =
function(iFrame, iFrameDoc) {
	var events = ["mouseup", "keydown", "keypress", "drag", "mousedown"];
	// Note that since we're not creating the closure here anymore, it's
	// safe to call this function any number of times (we do this for
	// Gecko/Linux to work around bugs).  The browser won't add the same
	// event if it already exists (DOM2 requirement)
	for (var i = 0; i < events.length; ++i) {
		if (AjxEnv.isIE) {
			iFrameDoc.attachEvent("on" + events[i], this.__eventClosure);
		} else {
			iFrameDoc.addEventListener(events[i], this.__eventClosure, true);
		}
	}
};

DwtHtmlEditor.prototype._handleEditorEvent =
function(ev) {
	var retVal = true;

	// If we have a mousedown event, then let DwtMenu know. This is a nasty hack that we have to do since
	// the iFrame is in a different document etc
	if (ev.type == "mousedown") {
		DwtMenu._outsideMouseDownListener(ev);
	}
	
	if (DwtKeyEvent.isKeyPressEvent(ev)) {
		var ke = this._keyEvent;
		ke.setFromDhtmlEvent(ev);
		if (ke.ctrlKey) {
			var key = String.fromCharCode(ke.charCode).toLowerCase();
			var cmd = null;
			var value = null;	

			switch (key) {
			    case '1':
			    case '2':
			    case '3':
			    case '4':
			    case '5':
			    case '6':
					cmd = DwtHtmlEditor._FORMAT_BLOCK;
					value = DwtHtmlEditor._KEY2CMDS[key];
					break;
					
				case '0':
					try {
						this.setMode((this._mode == DwtHtmlEditor.HTML) ? DwtHtmlEditor.TEXT : DwtHtmlEditor.HTML, true);
					} catch (e) {
						DBG.println("EXCEPTION!: " + e);
					}
					ke._stopPropagation = true;
					ke._returnValue = false;
					ke.setToDhtmlEvent(ev);
					retVal = false;
					break;
					
				default:
					// IE Has full on keyboard shortcuts
					//if (!AjxEnv.isIE)
						cmd = DwtHtmlEditor._KEY2CMDS[key];
					break;
			}
			if (cmd) {
				DBG.println("CMD: " + cmd);			
				this._execCommand(cmd, value);
				DBG.println("AFTER EXEC");
				ke._stopPropagation = true;
				ke._returnValue = false;
				ke.setToDhtmlEvent(ev);
				retVal = false;
			}
		}
	}
	
	// TODO notification for any updates etc
	// Set's up the a range for the current ins point or selection. This is IE only because the iFrame can
	// easily lose focus (e.g. by clicking on a button in the toolbar) and we need to be able to get back
	// to the correct insertion point/selection.
	if (AjxEnv.isIE) {
		var iFrameDoc = this._getIframeDoc();
		this._currInsPt = iFrameDoc.selection.createRange();
		// If just at the insertion point, then collapse so that we don't get
		// a range selection on a call to DwtHtmlEditor.focus()
		if (iFrameDoc.selection.type == "None") {
			this._currInsPt.collapse(false);
			this._currInsPt.text = "";
		}
	}
	
	if (this._stateUpdateActionId != null) 
		AjxTimedAction.cancelAction(this._stateUpdateActionId);
	
	this._stateUpdateActionId = AjxTimedAction.scheduleAction(this._updateStateAction, 100);

	return retVal;
}

DwtHtmlEditor.prototype._updateState =
function() {
	if (this._mode != DwtHtmlEditor.HTML)
		return;
		
	this._stateUpdateActionId = null;
	var ev = this._stateEvent;
	ev.reset();

	var iFrameDoc = this._getIframeDoc();
	try {	
		ev.isBold = iFrameDoc.queryCommandState(DwtHtmlEditor.BOLD_STYLE);
		ev.isItalic = iFrameDoc.queryCommandState(DwtHtmlEditor.ITALIC_STYLE);
		ev.isUnderline = iFrameDoc.queryCommandState(DwtHtmlEditor.UNDERLINE_STYLE);
		ev.isStrikeThru = iFrameDoc.queryCommandState(DwtHtmlEditor.STRIKETHRU_STYLE);
		ev.isSuperscript = iFrameDoc.queryCommandState(DwtHtmlEditor.SUPERSCRIPT_STYLE);
		ev.isSubscript = iFrameDoc.queryCommandState(DwtHtmlEditor.SUBSCRIPT_STYLE);
		ev.isOrderedList = iFrameDoc.queryCommandState(DwtHtmlEditor.ORDERED_LIST);
		ev.isUnorderedList = iFrameDoc.queryCommandState(DwtHtmlEditor.UNORDERED_LIST);
		
		// Don't futz with the order of the if statements below. They are important due to the 
		// nature of the RegExs
		var family = iFrameDoc.queryCommandValue(DwtHtmlEditor._FONT_NAME);
		if (family) {
			family = family.toLowerCase();
			if (family.search(DwtHtmlEditor._VERDANA_RE) != -1)
				ev.fontFamily = DwtHtmlEditor.VERDANA;
			else if (family.search(DwtHtmlEditor._ARIAL_RE) != -1)
				ev.fontFamily = DwtHtmlEditor.ARIAL;		
			else if (family.search(DwtHtmlEditor._TIMES_RE) != -1)
				ev.fontFamily = DwtHtmlEditor.TIMES;
			else if (family.search(DwtHtmlEditor._COURIER_RE) != -1)
				ev.fontFamily = DwtHtmlEditor.COURIER;
		}
		
		ev.fontSize = iFrameDoc.queryCommandValue(DwtHtmlEditor._FONT_SIZE);
		ev.backgroundColor = iFrameDoc.queryCommandValue((AjxEnv.isIE) ? "backcolor" : "hilitecolor");
		ev.color = iFrameDoc.queryCommandValue("forecolor");
		ev.justification = null;
		ev.direction = null;
		
		var style = iFrameDoc.queryCommandValue(DwtHtmlEditor._FORMAT_BLOCK);
		if (style) {
			if (style.search(DwtHtmlEditor._H1_RE) != -1)
				ev.style = DwtHtmlEditor.H1;
			else if (style.search(DwtHtmlEditor._H2_RE) != -1)
				ev.style = DwtHtmlEditor.H2;
			else if (style.search(DwtHtmlEditor._H3_RE) != -1)
				ev.style = DwtHtmlEditor.H3;
			else if (style.search(DwtHtmlEditor._H4_RE) != -1)
				ev.style = DwtHtmlEditor.H4;
			else if (style.search(DwtHtmlEditor._H5_RE) != -1)
				ev.style = DwtHtmlEditor.H5;
			else if (style.search(DwtHtmlEditor._H6_RE) != -1)
				ev.style = DwtHtmlEditor.H6;
			else if (style.search(DwtHtmlEditor._PARAGRAPH_RE) != -1)
				ev.style = DwtHtmlEditor.PARAGRAPH;
			else if (style.search(DwtHtmlEditor._ADDRESS_RE) != -1)
				ev.style = DwtHtmlEditor.ADDRESS;
			else if (style.search(DwtHtmlEditor._PREFORMATTED_RE) != -1)
				ev.style = DwtHtmlEditor.PREFORMATTED;
		}
		
		if (iFrameDoc.queryCommandState(DwtHtmlEditor.JUSTIFY_LEFT))
			ev.justification = DwtHtmlEditor.JUSTIFY_LEFT;
		else if (iFrameDoc.queryCommandState(DwtHtmlEditor.JUSTIFY_CENTER))
			ev.justification = DwtHtmlEditor.JUSTIFY_CENTER;
		else if (iFrameDoc.queryCommandState(DwtHtmlEditor.JUSTIFY_RIGHT))
			ev.justification = DwtHtmlEditor.JUSTIFY_RIGHT;
		else if (iFrameDoc.queryCommandState(DwtHtmlEditor.JUSTIFY_FULL))
			ev.justification = DwtHtmlEditor.JUSTIFY_FULL;


		// Notify any listeners
		if (this.isListenerRegistered(DwtEvent.STATE_CHANGE))
			this.notifyListeners(DwtEvent.STATE_CHANGE, ev);
	} catch (ex) {
		if (AjxEnv.isGeckoBased) {
			this._enableDesignMode(iFrameDoc);
		}
	}
}

DwtHtmlEditor.prototype._enableDesignMode =
function(iFrameDoc) {
	if (!iFrameDoc) return;
	
	try {
		iFrameDoc.designMode = "on";
		// Probably a regression of FF 1.5.0.1/Linux requires us to
		// reset event handlers here (Zimbra bug: 6545).
		if (AjxEnv.isGeckoBased && (AjxEnv.isLinux || AjxEnv.isMac))
			this._registerEditorEventHandlers(document.getElementById(this._iFrameId), iFrameDoc);
	} catch (ex) {
		//Gecko may take some time to enable design mode..
		if (AjxEnv.isGeckoBased) {
			var ta = new AjxTimedAction(this, this._enableDesignMode, [iFrameDoc]);
			AjxTimedAction.scheduleAction(ta, 10);
			return true;
		} else {
			// TODO Should perhaps throw an exception?
			return false;
		}
	}
}

DwtHtmlEditor.prototype._setContentOnTimer = 
function() {
	var iframeDoc = this._getIframeDoc();
	try {
		iframeDoc.body.innerHTML = this._pendingContent;
		// XXX: mozilla hack
		if (AjxEnv.isGeckoBased)
			this._enableDesignMode(iframeDoc);
	} catch (ex) {
		var ta = new AjxTimedAction(this, this._setContentOnTimer);
		AjxTimedAction.scheduleAction(ta, 10);
		return true;
	}
}

DwtHtmlEditor.prototype._execCommand =
function(command, option) {
	if (this._mode != DwtHtmlEditor.HTML)
		return;
		
// DBG.println("CMD: " + command + " - Option: " + option);

	try {
		this.focus();
		this._getIframeDoc().execCommand(command, false, option);	
	} catch (e) {
		// perhaps retry the command?
		this._enableDesignMode(this._getIframeDoc());
	}
	this._updateState();
}

DwtHtmlEditor.prototype._convertHtml2Text =
function() {
	var iFrameDoc = this._getIframeDoc();
	return iFrameDoc && iFrameDoc.body ? 
		AjxStringUtil.convertHtml2Text(iFrameDoc.body) : "";
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/

/**
* Creates an input field.
* @constructor
* @class
* This class represents an input field..
*
* CSS Elements
*	<className> input 			specifies the look of the input field during normal editing
*   <className>-error input		specifies the look of the input field in an error state
*
*
* @author Ross Dargahi
*
* @param parent				[DwtComposite]		the parent widget
* @param type				[constant]			the data type of the input field
* @param initialValue		[string]			the initial value of the field
* @param size				[int]				size of the input field (in characters)
* @param rows				[int]				number of rows (more than 1 means textarea)
* @param maxLen				[int]				maximum length (in characters) of the input
* @param errorIconStyle		[constant]			error icon style
* @param validationStyle	[constant]			validation type
* @param validator			[function]			custom validation function
* @param validatorCtxtObj	[object]			object context for validation function
* @param className			[string]			CSS class
* @param posStyle			[constant]			positioning style
*/
function DwtInputField(params) {

	if (arguments.length == 0) return;
	this._origClassName = params.className ? params.className : "DwtInputField";
	this._errorClassName = this._origClassName + "-Error";
	DwtControl.call(this, params.parent, params.className, params.posStyle);

	this._type = params.type ? params.type : DwtInputField.STRING;
	this._errorIconStyle = params.errorIconStyle ? params.errorIconStyle :
							params.validator ? DwtInputField.ERROR_ICON_RIGHT : DwtInputField.ERROR_ICON_NONE;
	this._validationStyle = params.validationStyle ? params.validationStyle : DwtInputField.ONEXIT_VALIDATION;

	var inputFieldId = Dwt.getNextId();
	var errorIconId = Dwt.getNextId();
	var htmlEl = this.getHtmlElement();
	if (this._errorIconStyle == DwtInputField.ERROR_ICON_NONE) {
		if (params.rows && params.rows > 1) {
			htmlEl.innerHTML =["<textarea id='", inputFieldId, "' rows=", params.rows, "></textarea"].join("");
		} else {
			htmlEl.innerHTML = ["<input autocomplete='off' id='", inputFieldId, "' type='",
				(this._type != DwtInputField.PASSWORD) ? "text" : "password", "'/>"].join("");
		}
				
	} else {
		var htmlArr = ["<table cellspacing='0' cellpadding='0'><tr>"];
		var i = 1;
		if (this._errorIconStyle == DwtInputField.ERROR_ICON_LEFT)
			htmlArr[i++] = ["<td style='padding-right:2px;'id='", errorIconId, "'></td>"].join("");

		htmlArr[i++] = ["<td><input autocomplete='off' id='", inputFieldId, "' type='",
			(this._type != DwtInputField.PASSWORD) ? "text" : "password",
			"'/></td>"].join("");

		if (this._errorIconStyle == DwtInputField.ERROR_ICON_RIGHT)
			htmlArr[i++] = ["<td style='padding-left:2px;' id='", errorIconId, "'></td>"].join("");

		htmlArr[i++] = "</tr></table>";
		htmlEl.innerHTML = htmlArr.join("");

		if (this._errorIconStyle != DwtInputField.ERROR_ICON_NONE) {
			this._errorIconTd = document.getElementById(errorIconId);
			this._errorIconTd.vAlign = "middle";
			this._errorIconTd.innerHTML = DwtInputField._NOERROR_ICON_HTML;
		}
	}

	this._inputField = document.getElementById(inputFieldId);
	Dwt.associateElementWithObject(this._inputField, this);

	this._inputField.onkeyup = DwtInputField._keyUpHdlr;
	this._inputField.onblur = DwtInputField._blurHdlr;

	if (params.size)
		this._inputField.size = params.size;
	if (params.maxLen)
		this._inputField.maxLength = this._maxLen = params.maxLen;

	this.setCursor("default");

	this._inputField.value = params.initialValue || "";

	this.setValidatorFunction(params.validatorCtxtObj, params.validator);
	this._setMouseEventHdlrs(false);
	this._setKeyPressEventHdlr(false);
};

DwtInputField.prototype = new DwtControl;
DwtInputField.prototype.constructor = DwtInputField;

// Error Icon Style
DwtInputField.ERROR_ICON_LEFT = 1;
DwtInputField.ERROR_ICON_RIGHT = 2;
DwtInputField.ERROR_ICON_NONE = 3;

// Validation Style
DwtInputField.CONTINUAL_VALIDATION = 1; // validate field after each character is typed
DwtInputField.ONEXIT_VALIDATION    = 2; // validate the field (i.e. after TAB or CR)
DwtInputField.MANUAL_VALIDATION    = 3; // validate the field  manually

// types
DwtInputField.NUMBER 	= 1; // Integer or float input filed
DwtInputField.INTEGER	= 2; // Integer input field (no floating point numbers)
DwtInputField.FLOAT		= 3; // Numeric input field
DwtInputField.STRING	= 4; // String input field
DwtInputField.PASSWORD	= 5; // Password input field
DwtInputField.DATE 		= 6; // Date input field

DwtInputField._ERROR_ICON_HTML = AjxImg.getImageHtml("ClearSearch");
DwtInputField._NOERROR_ICON_HTML = AjxImg.getImageHtml("Blank_9");

// Public methods

DwtInputField.prototype.toString =
function() {
	return "DwtInputField";
};

/**
* Sets the validator function. This function is executed during validation
*
* @param obj [object] If present then the validator function is executed within
*		the context of this object
* @param validator [function] Validator function
*/
DwtInputField.prototype.setValidatorFunction =
function(obj, validator) {
	if (validator) {
		this._validator = validator;
		this._validatorObj = obj;
	} else {
		switch (this._type) {
			case DwtInputField.NUMBER:	this._validator = DwtInputField.validateNumber; break;
		    case DwtInputField.INTEGER:	this._validator = DwtInputField.validateInteger; break;
		    case DwtInputField.FLOAT:	this._validator = DwtInputField.validateFloat; break;
		    case DwtInputField.STRING:
		    case DwtInputField.PASSWORD:this._validator = DwtInputField.validateString;	break;
		    case DwtInputField.DATE: 	this._validator = DwtInputField.validateDate; break;
		    default: 					this._validator = DwtInputField.validateAny;
		}
	}
};

/**
* Sets the validator to be a regular expression instead of a function
*
* @param regExp [reg exp] regular exxression
* @param errorString Error string to set for tooltip if the user enters invalid data
*/
DwtInputField.prototype.setValidatorRegExp =
function(regExp, errorString) {
	this._validator = regExp;
	this._validatorObj = null;
	this._errorString = errorString || "";
};

/**
* Sets a validation callback. This callback is invoked any time
* the input field is validated. The callback is invoked with two
* parameters. The first (params[0]) is the value of the input field
* The second is a boolean that if true indicates if the value is valid
*
* @param callback [AjxCallback] The callback
*/
DwtInputField.prototype.setValidationCallback =
function(callback) {
	this._validationCallback = callback;
};

/**
* Gets the internal native input element
*
* @return native input element
*/
DwtInputField.prototype.getInputElement =
function() {
	return this._inputField;
};

/**
* Gets the input fields current value
*
* @return Input field's current value
*/
DwtInputField.prototype.getValue =
function() {
	return this._inputField.value;
};

/**
 * Sets a new value for the input field
 *
 * XXX: if we're disabled, the validation step messes up the style
 */
DwtInputField.prototype.setValue =
function(value, noValidate) {
	this._inputField.value = value;
	if (!noValidate) {
		value = this._validateInput(value);
		if (value != null)
			this._inputField.value = value;
	}
};

/**
 * This method is only applicable for numeric input fields. It sets
 * the valid range (inclusive) of numeric values for the field
 *
 * @param min minimum permittedvalue. If null, then no minimum is established
 * @param max maximum permitted value. If null, then no maximum is established
 */
DwtInputField.prototype.setValidNumberRange =
function(min, max) {
	this._minNumVal = min;
	this._maxNumVal = max;
	var value = this._validateInput(this._inputField.value);
	if (value != null)
		this._inputField.value = value;
};

DwtInputField.prototype.setValidStringLengths =
function(minLen, maxLen) {
	this._minLen = minLen || 0;
	if (maxLen != null) {
		this._inputField.maxLength = maxLen;
		this._maxLen = maxLen;
	}
};

DwtInputField.prototype.setNumberPrecision =
function(decimals) {
	this._decimals = decimals;
};

DwtInputField.prototype.setReadOnly =
function(readonly) {
	this._inputField.setAttribute("readonly", (readonly == null ? true : readonly));
};

DwtInputField.prototype.setRequired =
function(required) {
	this._required = required == null ? true : required;
};

DwtInputField.prototype.disabled = 
function(disabled) {
	this.getInputElement().disabled = disabled;
};

DwtInputField.prototype.isDisabled = 
function() {
	return this.getInputElement().disabled;
};

DwtInputField.prototype.focus = 
function() {
	this.getInputElement().focus();
};

DwtInputField.prototype.blur = 
function() {
	this.getInputElement().blur();
};

DwtInputField.prototype.setVisible = 
function(visible) {
	Dwt.setVisible(this.getInputElement(), visible);
};

/**
 * Checks the validity of the input field's value
 *
 * @return a canonical value if valid, or null if the field's value is not
 * valid.  Check for correction using dwtInputField.isValid() != null.
 */
DwtInputField.prototype.isValid =
function() {
	try {
		if (typeof this._validator == "function") {
			return this._validatorObj
				? this._validator.call(this._validatorObj, this._inputField.value)
				: this._validator(this._inputField.value);
		} else {
			return this._validator.test(this._inputField.value);
		}
	} catch(ex) {
		if (typeof ex == "string")
			return null;
		else
			throw ex;
	}
};

/**
 * Validates the current input in the field. This method should be called
 * if the validation style has been set to DwtInputField.MANUAL_VALIDATION
 * and it is time for the field to be validated
 *
 * @return true if the field is valid, else false
 */
DwtInputField.prototype.validate =
function() {
	var value = this._validateInput(this._inputField.value);
	if (value != null) {
		this._inputField.value = value;
		return true;
	} else {
		return false;
	}
};

/* Built-in validators */

DwtInputField.validateNumber =
function(value) {
	var n = new Number(value);
	if (isNaN(n) || (Math.round(n) != n))
		throw AjxMsg.notAnInteger;
	return DwtInputField.validateFloat.call(this, value);
};

DwtInputField.validateInteger =
function(value) {
	var n = new Number(value);
	if (isNaN(n) || (Math.round(n) != n))
		throw AjxMsg.notAnInteger;
	return value;
};

DwtInputField.validateFloat =
function(value) {
	if (this._required && value == "")
		throw AjxMsg.valueIsRequired;
	var n = new Number(value);
	if (isNaN(n))
		throw AjxMsg.notANumber;
	if (this._minNumVal && value < this._minNumVal)
		throw AjxMessageFormat.format(AjxMsg.numberLessThanMin, this._minNumVal);
	if (this._maxNumVal && value > this._maxNumVal)
		throw AjxMessageFormat.format(AjxMsg.numberMoreThanMax, this._maxNumVal);

	// make canonical value
	if (this._decimals != null) {
		var str = n.toString();
		var pos = str.indexOf(".");
		if (pos == -1)
			pos = str.length;
		value = n.toPrecision(pos + this._decimals);
	} else {
		value = n.toString();
	}

	return value;
};

DwtInputField.validateString =
function(value) {
	if (this._required && value == "")
		throw AjxMsg.valueIsRequired;
	if (this._minLen != null && value.length < this._minLen)
		throw AjxMessageFormat.format(AjxMsg.stringTooShort, this._minLen);
	if (this._maxLen != null && value.length > this._maxLen)
		throw AjxMessageFormat.format(AjxMsg.stringTooLong, this._maxLen);
	return value;
};

DwtInputField.validateDate = 
function(value) {
	if (this._required && value == "")
		throw AjxMsg.valueIsRequired;
	
	if (AjxDateUtil.simpleParseDateStr(value) == null) {
		throw AjxMsg.invalidDatetimeString;
	}

	return value;
};

DwtInputField.validateAny =
function(value) {
	if (this._required && value == "")
		throw AjxMsg.valueIsRequired;
	// note that null will always be regarded as invalid. :-) I guess this
	// is OK.  An input field never has a null value.
	return value;
};

// Private methods

DwtInputField.prototype._validateRegExp =
function(value) {
	if (this._required && value == "")
		throw AjxMsg.valueIsRequired;
	if (this._regExp && !this._regExp.test(value)) {
		throw this._errorString;
	}
	return value;
};

DwtInputField._keyUpHdlr =
function(ev) {
	var keyEv = DwtShell.keyEvent;
	keyEv.setFromDhtmlEvent(ev);

	var obj = keyEv.dwtObj;
	var keyCode = keyEv.keyCode;

	// ENTER || TAB
	var val = null;
	/** 
	 * CL - processing 0D and 09 caused focus issues. Blur handling below is sufficient
	 */
	/*
	if ((keyCode == 0x0D || keyCode == 0x09)
	    && obj._validationStyle == DwtInputField.ONEXIT_VALIDATION)
		val = obj._validateInput(keyEv.target.value);
	else 
	*/
	if (obj._validationStyle == DwtInputField.CONTINUAL_VALIDATION)
		val = obj._validateInput(keyEv.target.value);

	if (val != null)
		keyEv.target.value = val;

	return true;
};

DwtInputField._blurHdlr =
function(ev) {
	var obj = DwtUiEvent.getDwtObjFromEvent(ev);
	if (obj && obj._validationStyle == DwtInputField.ONEXIT_VALIDATION) {
		var val = obj._validateInput(obj._inputField.value);
		if (val != null)
			obj._inputField.value = val;
	}
};

DwtInputField.prototype._validateInput =
function(value) {
	var isValid = true;
	var retVal;
	var errorStr;

	try {
		if (typeof this._validator == "function") {
			retVal = value = this._validatorObj
				? this._validator.call(this._validatorObj, value)
				: this._validator(value);
		} else if (!this._validator.test(value)) {
			errorStr = this._errorString;
		}
	} catch(ex) {
		if (typeof ex == "string")
			errorStr = ex;
		else
			throw ex;
	}

	if (errorStr) {
		this.getHtmlElement().className = this._errorClassName;
		if (this._errorIconTd)
			this._errorIconTd.innerHTML = DwtInputField._ERROR_ICON_HTML;
		this.setToolTipContent(errorStr);
		isValid = false;
		retVal = null;
	} else {
		this.getHtmlElement().className = this._origClassName;
		if (this._errorIconTd)
			this._errorIconTd.innerHTML = DwtInputField._NOERROR_ICON_HTML;
		this.setToolTipContent(null);
		isValid = true;
	}

	if (this._validationCallback)
		this._validationCallback.run(this, isValid, value);

	return retVal;
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtSash(parent, style, className, threshold, posStyle) {
	if (arguments.length == 0) return;
	className = className ? className : "DwtSash";
	posStyle = posStyle ? posStyle : DwtControl.ABSOLUTE_STYLE;
	DwtControl.call(this, parent, className, posStyle);

    var htmlElement = this.getHtmlElement();
	if (style == null || style != DwtSash.HORIZONTAL_STYLE) {
		this._style = DwtSash.VERTICAL_STYLE;
		htmlElement.style.cursor = AjxEnv.isIE ? "row-resize" : "n-resize";
		htmlElement.innerHTML = DwtBorder.getBorderHtml("h_sash");
	} else {
		this._style = DwtSash.HORIZONTAL_STYLE;
		htmlElement.style.cursor = AjxEnv.isIE ? "col-resize" : "e-resize";
	}
	this._threshold = (threshold > 0) ? threshold : 1;

	this._captureObj = new DwtMouseEventCapture(this, "DwtSash", DwtSash._mouseOverHdlr,
			DwtSash._mouseDownHdlr, DwtSash._mouseMoveHdlr, 
			DwtSash._mouseUpHdlr, DwtSash._mouseOutHdlr);
	this.setHandler(DwtEvent.ONMOUSEDOWN, DwtSash._mouseDownHdlr);
	this.setHandler(DwtEvent.ONMOUSEOVER, DwtSash._mouseOverHdlr);
	this.setHandler(DwtEvent.ONMOUSEOUT, DwtSash._mouseOutHdlr);

	this.setZIndex(Dwt.Z_VIEW);
}

DwtSash.prototype = new DwtControl;
DwtSash.prototype.constructor = DwtSash;

DwtSash.prototype.toString = 
function() {
	return "DwtSash";
}

DwtSash.HORIZONTAL_STYLE  = 1;
DwtSash.VERTICAL_STYLE = 2;

// The callback function will be called with a proposed delta. It should return a value indication
// how much of a delta was actually applied.
DwtSash.prototype.registerCallback =
function(callbackFunc, callbackObj) {
	this._callbackFunc = callbackFunc;
	this._callbackObj = callbackObj;
}

DwtSash._mouseOverHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

DwtSash._mouseDownHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);	
	if (mouseEv.button != DwtMouseEvent.LEFT) {
		DwtUiEvent.setBehaviour(ev, true, false);
		return false;
	}
	var sash = mouseEv.dwtObj;
	if (sash._callbackFunc != null) {
		sash._captureObj.capture();
		sash._startCoord = (sash._style == DwtSash.HORIZONTAL_STYLE) 
				? mouseEv.docX : mouseEv.docY;
	}
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

DwtSash._mouseMoveHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);	
	var delta = 0;
	var sash = DwtMouseEventCapture.getTargetObj();
	if (sash._style == DwtSash.HORIZONTAL_STYLE) {
		if (mouseEv.docX > 0 && mouseEv.docX != sash._startCoord)
			delta = mouseEv.docX - sash._startCoord;
	} else  {
		if (mouseEv.docY > 0 && mouseEv.docY != sash._startCoord)
			delta = mouseEv.docY - sash._startCoord;
	}
		
	if (Math.abs(delta) >= sash._threshold) {
		if (sash._callbackObj != null)
			delta = sash._callbackFunc.call(sash._callbackObj, delta);
		else 
			delta = sash._callbackFunc(delta);		
		sash._startCoord += delta;
		// If movement happened, then shift our location by the actual amount of movement
		if (delta != 0 && sash._posStyle == Dwt.ABSOLUTE_STYLE) {
			if (sash._style == DwtSash.HORIZONTAL_STYLE)
				sash.setLocation(sash.getLocation().x + delta, Dwt.DEFAULT);
			else
				sash.setLocation(Dwt.DEFAULT, sash.getLocation().y + delta);
		}
	}
		
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

DwtSash._mouseUpHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);	
	if (mouseEv.button != DwtMouseEvent.LEFT) {
		DwtUiEvent.setBehaviour(ev, true, false);
		return false;
	}
	
	if (DwtMouseEventCapture.getTargetObj()._callbackFunc != null)
		DwtMouseEventCapture.getCaptureObj().release();
		
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

DwtSash._mouseOutHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtToolBar(parent, className, posStyle, cellSpacing, cellPadding, style) {

	if (arguments.length == 0) return;
	className = className || "DwtToolBar";
	DwtComposite.call(this, parent, className, posStyle);
	
	this._style = style ? style : DwtToolBar.HORIZ_STYLE;
	this._table = document.createElement("table");
	this._table.border = 0;
	this._table.cellPadding = cellPadding ? cellPadding : 0;
	this._table.cellSpacing = cellSpacing ? cellSpacing : 0;
	this.getHtmlElement().appendChild(this._table);
	this._table.backgroundColor = DwtCssStyle.getProperty(this.parent.getHtmlElement(), "background-color");

	this._numFillers = 0;
}

DwtToolBar.prototype = new DwtComposite;
DwtToolBar.prototype.constructor = DwtToolBar;

DwtToolBar.HORIZ_STYLE	= 1;
DwtToolBar.VERT_STYLE	= 2;

DwtToolBar.ELEMENT		= 1;
DwtToolBar.SPACER		= 2;
DwtToolBar.SEPARATOR	= 3;
DwtToolBar.FILLER		= 4;

DwtToolBar.DEFAULT_SPACER = 10;

DwtToolBar.prototype.toString = 
function() {
	return "DwtToolBar";
}

// bug fix #33 - IE defines box model differently
DwtToolBar.prototype.__itemPaddingRight = AjxEnv.isIE ? "4px" : "0px";

DwtToolBar.prototype.getItem =
function(index) {
	return this._children.get(index);
}

DwtToolBar.prototype.getItemCount =
function() {
	return this._children.size();
}

DwtToolBar.prototype.getItems =
function() {
	return this._children.toArray();
}

DwtToolBar.prototype.addSpacer =
function(size, index) {
	var el = this._createSpacerElement();
	var dimension = this._style == DwtToolBar.HORIZ_STYLE ? "width" : "height";
	el.style[dimension] = size || DwtToolBar.DEFAULT_SPACER;

	this._addItem(DwtToolBar.SPACER, el, index);
	return el;
}

DwtToolBar.prototype._createSpacerElement = 
function() {
	return document.createElement("div");
}

DwtToolBar.prototype.addSeparator =
function(className, index) {
	var el = this._createSeparatorElement();
	el.className = className;
	this._addItem(DwtToolBar.SEPARATOR, el, index);
	return el;
}

DwtToolBar.prototype._createSeparatorElement = DwtToolBar.prototype._createSpacerElement;
DwtToolBar.prototype._createFillerElement = DwtToolBar.prototype._createSpacerElement;

DwtToolBar.prototype.addFiller =
function(className, index) {
	var el = this._createFillerElement();
	el.className = className || this._defaultFillClass;
	this._addItem(DwtToolBar.FILLER, el, index);
	return el;
}

DwtToolBar.prototype.addChild =
function(child, index) {
	this._children.add(child);
	var htmlEl = child._removedEl ? child._removedEl : child.getHtmlElement();
	this._addItem(DwtToolBar.ELEMENT, htmlEl, index);
}

DwtToolBar.prototype._addItem =
function(type, element, index) {

	var row, col;
	if (this._style == DwtToolBar.HORIZ_STYLE) {
		row = (this._table.rows.length != 0) ? this._table.rows[0]: this._table.insertRow(0);
		row.align = "center";
		row.vAlign = "middle";
		
		var cellIndex = index || row.cells.length;
		col = row.insertCell(cellIndex);
		col.align = "center";
		col.vAlign = "middle";
		col.noWrap = true;
		// bug fix #33 - IE defines box model differently
		col.style.paddingRight = this.__itemPaddingRight;

		if (type == DwtToolBar.FILLER) {
			this._numFillers++;
			var perc = Math.floor(100 / this._numFillers);
			col.style.width = [perc, "%"].join("");
		} else {
			col.style.width = "1";
		}
			
		col.appendChild(element);
	} else {
		var rowIndex = index || -1;
		row = this._table.insertRow(rowIndex);
		row.align = "center";
		row.vAlign = "middle";
		
		col = row.insertCell(0);
		col.align = "center";
		col.vAlign = "middle";
		col.noWrap = true;

		if (type == DwtToolBar.FILLER) {
			this._numFillers++;
			var perc = Math.floor(100 / this._numFillers);
			col.style.height = [perc, "%"].join("");
		}

		col.appendChild(element);
	}
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* @class
* This static class  allows you to draw "interesting" borders
*		(eg: borders that are composed of multiple images)
*
*	Note that images for the border are used in the same style as AjxImg.
*
*
*	TODO: get the borders working with the AjxImg scheme to do hires/lores images.
*
* @author Owen Williams
*/

function DwtBorder() {
}

DwtBorder._borderTemplates = {};

DwtBorder.getBorderTemplate = 
function(style) {
	return this._borderTemplates[style];
};

DwtBorder.getBorderHtml = 
function (style, substitutions, innerDivId) {
	return AjxBuffer.append(
				this.getBorderStartHtml(style, substitutions),
				(innerDivId ? "<div id=" + innerDivId + "></div>" : ""),
				this.getBorderEndHtml(style, substitutions)
			);
};

DwtBorder.getBorderStartHtml = 
function(style, substitutions) {
	var template = this._borderTemplates[style];
	if (template == null) {
		DBG.println("DwtBorder.getBorderStartHtml(",style,"): no border template found.");
		return "";
	}

	var html = template.start;
	if (substitutions != null) {
		html = DwtBorder.performSubstitutions(html, substitutions);
	}
	return html;
};

DwtBorder.getBorderEndHtml = 
function(style, substitutions) {
	var template = this._borderTemplates[style];
	if (template == null || template == "") return "";

	var html = template.end;
	if (substitutions != null) {
		html = DwtBorder.performSubstitutions(html, substitutions);
	}
	return html;
};

DwtBorder.getBorderHeight = 
function(style) {
	var template = this._borderTemplates[style];
	return template ? template.height : 0;
};

DwtBorder.getBorderWidth = 
function(style) {
	var template = this._borderTemplates[style];
	return template ? template.width : 0;
};

DwtBorder.performSubstitutions = 
function (html, substitutions) {
	for (var prop in substitutions) {
		var str = "<!--$" + prop + "-->";
		if (html.indexOf(str)) {
			html = html.split(str).join(substitutions[prop]);
		}
		// MOW: Why is this here?  This will make substitution twice as slow... do we need it?
		var str = "{$"+prop+"}";
		if (html.indexOf(str)) {
			html = html.split(str).join(substitutions[prop]);
		}
	}
	return html;
};

DwtBorder.registerBorder = 
function (style, template) {
	this._borderTemplates[style] = template;
};

DwtBorder.registerBorder(
	"1pxBlack",
	{
		start:"<div style='border:1px solid black'>",
		end:"</div>",
		width:2,
		height:2
	}
);	
	
DwtBorder.registerBorder(
	"card",	
	{
		start:"<table class=card_border_table cellspacing=0 cellpadding=0>"+
				"<tr><td class=card_spacer_TL><div class=ImgCard_TL></div></td>"+
					"<td class=ImgCard_T__H></td>"+
					"<td class=card_spacer_TR><div class=ImgCard_TR></div></td>"+
				"</tr>"+
				"<tr><td class=ImgCard_L__V></td>"+
					"<td class=card_spacer_BG>"+
						"<div class=card_contents>",
		end:			"</div class=card_contents>"+
					"</td>"+
					"<td class=ImgCard_R__V></td>"+
				"</tr>"+
				"<tr><td class=card_spacer_BL><div class=ImgCard_BL></div></td>"+
					"<td class=ImgCard_B__H></td>"+
					"<td class=card_spacer_BR><div class=ImgCard_BR></div></td>"+
				"</tr>"+
			"</table>",
		width:20,
		height:20
	
	}
);

DwtBorder.registerBorder(
	"cardSel",
	{
		start:"<table class=card_border_table cellspacing=0 cellpadding=0>"+
				"<tr><td class=card_spacer_TL><div class=ImgCardSel_TL></div></td>"+
					"<td class=ImgCardSel_T__H></td>"+
					"<td class=card_spacer_TR><div class=ImgCardSel_TR></div></td>"+
				"</tr>"+
				"<tr><td class=ImgCardSel_L__V></td>"+
					"<td class=card_spacer_BG>"+
						"<div class=card_contents>",
		end:			"</div class=card_contents>"+
					"</td>"+
					"<td class=ImgCardSel_R__V></td>"+
				"</tr>"+
				"<tr><td class=card_spacer_BL><div class=ImgCardSel_BL></div></td>"+
					"<td class=ImgCardSel_B__H></td>"+
					"<td class=card_spacer_BR><div class=ImgCardSel_BR></div></td>"+
				"</tr>"+
			"</table>",
		width:19,
		height:18
	
	}
);

var dialogPieces = {
	start:AjxBuffer.concat(
				 "<table class='DialogTable' cellpadding='0' Xborder=1>",
					// top edge
					"<tr><td class='border_outset_c'><div class='ImgDialogOutset_TL'></div></td>",
						"<td colspan=3 class='ImgDialogOutset_T__H'></td>",
						"<td class='border_outset_c'><div class='ImgDialogOutset_TR'></div></td>",
						(AjxEnv.useTransparentPNGs ? "<td rowspan=2 valign=top class='border_shadow_v'><div class='ImgShadowBig_TR'></div><div class='ImgShadowBig_R__V' style='height:100%'></div></td>" : ""),
					"</tr>",
					// titlebar
					"<tr><td class='ImgDialogOutset_L__V' style='height:100%'></td>",
						"<td colspan=3 id='<!--$titleId-->' class='DialogTitle'>",
						  "<table class='dialog_table' cellpadding='0'><tr>",
							"<td class='DialogTitleCell'><!--$icon--></td>",
							"<td id='<!--$titleTextId-->' class='DialogTitleCell'><!--$title--></td>",
							"<td class='DialogTitleCell'><div class='<!--$closeIcon2-->' style='cursor:pointer'></div></td>",
							"<td class='DialogTitleCell'><div class='<!--$closeIcon1-->' style='cursor:pointer'></div></td>",
						"</tr></table></td>",
						"<td class='ImgDialogOutset_R__V' style='height:100%'></td>",
					"</tr>"
				),
	
	topNoToolbar: AjxBuffer.concat(
					// top inside edge
					"<tr><td class='ImgDialogOutset_L__V' style='height:100%'></td>",
						"<td class='DialogBody'><div class='ImgDialogInset_TL'></div></td>",
						"<td class='DialogBody' Xstyle='width:100%'><div class='ImgDialogInset_T__H'></div></td>",
						"<td class='DialogBody'><div class='ImgDialogInset_TR'></div></td>",
						"<td class='ImgDialogOutset_R__V' style='height:100%'></td>",
						(AjxEnv.useTransparentPNGs ? "<td class='ImgShadowBig_R__V'></div></td>"  : ""),
					"</tr>",
					// dialog center
					"<tr><td class='ImgDialogOutset_L__V' style='height:100%'></td>",
						"<td class='DialogBody ImgDialogInset_L__V' style='height:100%'></td>",
						"<td class='DialogBody'>"
				),
	
	topWithToolbar: AjxBuffer.concat(
					// top inside edge
					"<tr><td class='ImgDialogOutset_L__V' style='height:100%'></td>",
						"<td class='DialogToolbar'><div class='ImgDialogInset_TL'></div></td>",
						"<td class='DialogToolbar' style='width:100%'><div class='ImgDialogInset_T__H'></div></td>",
						"<td class='DialogToolbar'><div class='ImgDialogInset_TR'></div></td>",
						"<td class='ImgDialogOutset_R__V' style='height:100%'></td>",
						(AjxEnv.useTransparentPNGs ? "<td class='ImgShadowBig_R__V'></div></td>" : ""),
					"</tr>",
					// top toolbar
					"<tr><td class='ImgDialogOutset_L__V' style='height:100%'></td>",
						"<td class='DialogToolbar'><div class='ImgDialogInset_L__V' style='height:20'></div></td>",
						"<td class='DialogToolbar'></td>",
						"<td class='DialogToolbar'><div class='ImgDialogInset_R__V' style='height:20'></div></td>",
						"<td class='ImgDialogOutset_R__V' style='height:100%'></td>",
						(AjxEnv.useTransparentPNGs ? "<td class='ImgShadowBig_R__V'></div></td>" : ""),
					"</tr>",
					"<tr><td class='ImgDialogOutset_L__V' style='height:100%'></td>",
						"<td class='ImgDialogToolbarSep_L'></td>",
						"<td class='ImgDialogToolbarSep__H'></td>",
						"<td class='ImgDialogToolbarSep_R'></td>",
						"<td class='ImgDialogOutset_R__V' style='height:100%'></td>",
						(AjxEnv.useTransparentPNGs ? "<td class='ImgShadowBig_R__V'></div></td>" : ""),
					"</tr>",
					// dialog center
					"<tr><td class='ImgDialogOutset_L__V' style='height:100%'></td>",
						"<td class='DialogBody ImgDialogInset_L__V' style='height:100%'></td>",
						"<td class='DialogBody'>"
				),
	
	bottomNoToolbar: AjxBuffer.concat(
						"</td> ",
						"<td class='DialogBody ImgDialogInset_R__V' style='height:100%'></td>",
						"<td class='ImgDialogOutset_R__V' style='height:100%'></td>",
						(AjxEnv.useTransparentPNGs ? "<td class='ImgShadowBig_R__V'></div></td>" : ""),
					"</tr>",
					// bottom inside edge
					"<tr><td class='ImgDialogOutset_L__V' style='height:100%'></td>",
						"<td class='DialogBody'><div class='ImgDialogInset_BL'></div></td>",
						"<td class='DialogBody'><div class='ImgDialogInset_B__H'></div></td>",
						"<td class='DialogBody'><div class='ImgDialogInset_BR'></div></td>",
						"<td class='ImgDialogOutset_R__V' style='height:100%'></td>",
						(AjxEnv.useTransparentPNGs ? "<td class='ImgShadowBig_R__V'></div></td>" : ""),
					"</tr>"
				),
	
	bottomWithToolbar: AjxBuffer.concat(
						"</td>",
						"<td class='DialogBody ImgDialogInset_R__V' style='height:100%'></td>",
						"<td class='ImgDialogOutset_R__V' style='height:100%'></td>",
						(AjxEnv.useTransparentPNGs ? "<td class='ImgShadowBig_R__V'></div></td>" : ""),
					"</tr>",
					// bottom toolbar
					"<tr><td class='ImgDialogOutset_L__V' style='height:100%'></td>",
						"<td class='ImgDialogToolbarSep_L'></td>",
						"<td class='ImgDialogToolbarSep__H'></td>",
						"<td class='ImgDialogToolbarSep_R'></td>",
						"<td class='ImgDialogOutset_R__V' style='height:100%'></td>",
						(AjxEnv.useTransparentPNGs ? "<td class='ImgShadowBig_R__V'></div></td>" : ""),
					"</tr>",
					"<tr><td class='ImgDialogOutset_L__V' style='height:100%'></td>",
						"<td class='DialogToolbar'><div class='ImgDialogInset_L__V' style='height:20'></td>",
						"<td class='DialogToolbar'><div id='<!--$id-->_bottom_toolbar'></div></td>",
						"<td class='DialogToolbar'><div class='ImgDialogInset_R__V' style='height:20'></td>",
						"<td class='ImgDialogOutset_R__V' style='height:100%'></td>",
						(AjxEnv.useTransparentPNGs ? "<td class='ImgShadowBig_R__V'></div></td>" : ""),
					"</tr>",
					// bottom inside edge
					"<tr><td class='ImgDialogOutset_L__V' style='height:100%'></td>",
						"<td class='DialogToolbar'><div class='ImgDialogInset_BL'></div></td>",
						"<td class='DialogToolbar'><div class='ImgDialogInset_B__H'></div></td>",
						"<td class='DialogToolbar'><div class='ImgDialogInset_BR'></div></td>",
						"<td class='ImgDialogOutset_R__V' style='height:100%'></td>",
						(AjxEnv.useTransparentPNGs ? "<td class='ImgShadowBig_R__V'></div></td>" : ""),
					"</tr>"	
				),
	
	end: AjxBuffer.concat(
					// bottom edge
					"<tr><td><div class='ImgDialogOutset_bl'></div></td>",
						"<td colspan=3 class='ImgDialogOutset_B__H'></td>",
						"<td><div class='ImgDialogOutset_br'></div></td>",
						(AjxEnv.useTransparentPNGs ? "<td class='ImgShadowBig_R__V'></div></td>" : ""),
					"</tr>",
					// bottom shadow
						(AjxEnv.useTransparentPNGs ? 
							"<tr><td colspan=5><table cellspacing=0 cellpadding=0 border=0><tr><td><div class='ImgShadowBig_BL'></div><td>"+
									"<td width=100%><div class='ImgShadowBig_B__H' style='width:100%'></div></td></tr></table>"+
								"</td>"+
								"<td class=dialog_shadow_c><div class='ImgShadowBig_BR'></div><td>"+
							"</tr>"
						  : ""
						),
			     "</table>"
				)
}

DwtBorder.registerBorder(
	"dialog",
	{
		start:	dialogPieces.start + dialogPieces.topNoToolbar,
		end: dialogPieces.bottomNoToolbar + dialogPieces.end,
		width:40,
		height:45
	}
);

DwtBorder.registerBorder(
	"dialogWithTopToolbar",
	{
		start:	dialogPieces.start + dialogPieces.topWithToolbar,
		end: dialogPieces.bottomNoToolbar + dialogPieces.end,
		width:40,
		height:45
	}
);

DwtBorder.registerBorder(
	"dialogWithBottomToolbar",
	{
		start:	dialogPieces.start + dialogPieces.topNoToolbar,
		end: dialogPieces.bottomWithToolbar + dialogPieces.end,
		width:40,
		height:45
	}
);

DwtBorder.registerBorder(
	"dialogWithBothToolbars",
	{
		start:	dialogPieces.start + dialogPieces.topWithToolbar,
		end: dialogPieces.bottomWithToolbar + dialogPieces.end,
		width:40,
		height:45
	}
);

DwtBorder.registerBorder(
	"h_sash",
	{	
		start: AjxBuffer.concat(
				"<table width=100% cellspacing=0 cellpadding=0><tr>",
					"<td><div  class=ImgHSash_L></div></td>",
					"<td class=ImgHSash__H style='width:50%'></td>",
					"<td><div class=ImgHSashGrip></div></td>",
					"<td class=ImgHSash__H style='width:50%'></td>",
					"<td><div  class=ImgHSash_TR></div></td>",
				"</tr></table>"
			),
		end:"",
		width:10,	//NOT ACCURATE
		height:7
	}
);

DwtBorder.registerBorder(
	"calendar_appt",
	{	
		start:AjxBuffer.concat(	
			"<div id='<!--$id-->_body' class='appt_body <!--$bodyColor-->'>",
				"<table style='width:100%;height:100%'cellspacing=0 cellpadding=2>",
				"<tr class='<!--$headerColor-->'>",
					"<td class=appt<!--$newState-->_time id='<!--$id-->_st'><!--$starttime--></td>",
					"<td class=appt_status-<!--$statusKey--> style='text-align:right'><!--$status--></td>",
//					"<td class=appt<!--$newState-->_tag><!--$tag--></td>",
				"</tr>",
				"<tr valign=top>",
					"<td colspan=2 class=appt<!--$newState-->_name style='height:100%'>",
						"<!--$name-->",
						"<BR>",
						"<!--$location-->",
					"</td>",
				"<tr>",
					"<td colspan=2 class=appt_end_time id='<!--$id-->_et'><!--$endtime--></td>",
				"</tr>",
				"</table>",
//				"<div style='position:absolute; bottom:0; right:0;' class=appt_end_time id='<!--$id-->_et'><!--$endtime--></div>",				
			"</div>"
			),
		end: "",
		width:10,	//NOT ACCURATE
		height:7
	}
);

DwtBorder.registerBorder(
	"calendar_appt_bottom_only",
	{	
		start:AjxBuffer.concat(	
			"<div id='<!--$id-->_body' class='appt_body <!--$bodyColor-->'>",
				"<table style='width:100%;height:100%'cellspacing=0 cellpadding=2>",
				"<tr valign=top>",
					"<td colspan=2 class=appt<!--$newState-->_name style='height:100%'>",
						"<!--$name-->",
						"<BR>",
						"<!--$location-->",
					"</td>",
				"<tr>",
					"<td colspan=2 class=appt_end_time id='<!--$id-->_et'><!--$endtime--></td>",
				"</tr>",
				"</table>",
			"</div>"
			),
		end: "",
		width:10,	//NOT ACCURATE
		height:7
	}
);

DwtBorder.registerBorder(
	"calendar_appt_30",
	{	
		start:AjxBuffer.concat(
			"<div id='<!--$id-->_body' class='appt_30_body <!--$headerColor-->'>",
				"<table width=100% cellspacing=0 cellpadding=2>",
				"<tr>",
					"<td class=appt_30<!--$newState-->_name><!--$name--></td>",
//					"<td class=appt<!--$newState-->_tag><!--$tag--></td>",
				"</tr>",
				"</table>",
			"</div>"
		),
		end:	"",
		width:4,
		height:4
	}
);

DwtBorder.registerBorder(
	"calendar_appt_allday",
	{	
		start:AjxBuffer.concat(
			"<div id='<!--$id-->_body' <!--$body_style--> class='appt_allday_body <!--$headerColor-->'>",
				"<table width=100% cellspacing=0 cellpadding=2>",
				"<tr>",
					"<td class=appt_allday<!--$newState-->_name><!--$name--></td>",
//					"<td class=appt<!--$newState-->_tag><!--$tag--></td>",
				"</tr>",
				"</table>",
			"</div>"
		),
		end:	"",
		width:4,
		height:4
	}
);

// NOTE:  For the hover border, we show a PNG transparency shadow if the platform supports it cleanly
//			(eg: in FF, not in IE or Linux)
DwtBorder.registerBorder( 
	"hover", 
	{ 
		start: AjxBuffer.concat(
				"<div id='{$id}_tip_t' class='hover_tip_top ImgHoverTip_T'></div>",
				"<table class=hover_frame_table border=0 cellspacing=0 cellpadding=0>", 
					"<tr>", 
						"<td id='{$id}_border_tl' class=ImgHover_TL></td>", 
						"<td id='{$id}_border_tm' class=ImgHover_T__H></td>", 
						"<td id='{$id}_border_tr' class=ImgHover_TR></td>", 
						(AjxEnv.useTransparentPNGs ? "<td class='ImgCurvedShadow_TR'></td>" : ""),
					"</tr>", 
					"<tr>",
						"<td id='{$id}_border_ml' class=ImgHover_L__V></td>", 
						"<td id='{$id}_border_mm' class=ImgHover__BG><div id='{$id}_contents' class=hover_contents>"
			),
		end: AjxBuffer.concat(
						"</div></td>", 
						"<td id='{$id}_border_mr' class=ImgHover_R__V></td>", 
						(AjxEnv.useTransparentPNGs ? "<td valign=top><div class='ImgCurvedShadow_T2R'></div><div class='ImgCurvedShadow_R__V' style='height:100%;'></div></td>" : ""),
					"</tr>", 
					"<tr>",
						"<td id='{$id}_border_bl' class=ImgHover_BL></div></td>", 
						"<td id='{$id}_border_bm' class=ImgHover_B__H></td>", 
						"<td id='{$id}_border_br' class=ImgHover_BR></div></td>", 
						(AjxEnv.useTransparentPNGs ? "<td></td>" : ""),
					"</tr>", 
						(AjxEnv.useTransparentPNGs ? 
							"<tr><td class='ImgCurvedShadow_BL'></td>"
								+"<td><div id='{$id}_border_shadow_b' class='ImgCurvedShadow_B__H' style='width:100%;'></td>"
								+"<td></td>"
								+"<td><div style='position:relative;'><div class='ImgCurvedShadow_BR' style='position:absolute;left:-20;top:-14'></div></div></td>"
							+"</tr>" 
							: ""
						),
				"</table>",
				"<div id='{$id}_tip_b' class='hover_tip_bottom ImgHoverTip_B'></div>"
			)
	} 
);

DwtBorder.registerBorder( 
	"SemiModalDialog", 
	{ 
		start: AjxBuffer.concat(
//				"<div id='{$id}_tip_t' class='hover_tip_top ImgSemiModalTip_T'></div>",
				"<table class=hover_frame_table border=0 cellspacing=0 cellpadding=0>", 
					"<tr>", 
						"<td id='{$id}_border_tl' class=ImgSemiModalHeader_TL></td>", 
						"<td id='{$id}_border_tm' class=ImgSemiModalHeader_T__H colspan=2></td>", 
						"<td id='{$id}_border_tr' class=ImgSemiModalHeader_TR></td>", 
						(AjxEnv.useTransparentPNGs ? "<td class='ImgCurvedShadow_TR'></td>" : ""),
					"</tr>", 
					"<tr>",
						"<td id='{$id}_border_ml' class='ImgSemiModalHeader_L__V'></td>", 
						"<td class='ImgSemiModalHeader__BG'><div id='{$id}_title' class='DwtStickyToolTipTitle'>{$title}</div></td>",
						"<td class='ImgSemiModalHeader__BG'><div id='{$id}_close' class='DwtStickyToolTipTitle' style='position:relative;top:-3px;left:20px;align:right;'></div></td>",
						"<td id='{$id}_border_mr' class=ImgSemiModalHeader_R__V></td>", 
						(AjxEnv.useTransparentPNGs ? "<td valign=top><div class='ImgCurvedShadow_T2R'></div><div class='ImgCurvedShadow_R__V' style='height:100%;'></div></td>" : ""),
					"</tr>",
					"<tr>",
						"<td id='{$id}_border_ml' class='ImgSemiModalBody_TL'></td>", 
						"<td id='{$id}_title' class='ImgSemiModalBody_T__H' colspan=2></td>",
						"<td id='{$id}_border_mr' class=ImgSemiModalBody_TR></td>", 
						(AjxEnv.useTransparentPNGs ? "<td><div class='ImgCurvedShadow_R__V' style='height:100%;'></div></td>" : ""),
					"</tr>",
					"<tr>",
						"<td id='{$id}_border_ml' class=ImgSemiModalBody_L__V></td>", 
						"<td id='{$id}_border_mm' class=ImgSemiModalBody__BG colspan=2><div id='{$id}_contents'>"
			),
		end: AjxBuffer.concat(
						"</div></td>", 
						"<td id='{$id}_border_mr' class=ImgSemiModalBody_R__V></td>", 
						(AjxEnv.useTransparentPNGs ? "<td valign=top><div class='ImgCurvedShadow_R__V' style='height:100%;'></div></td>" : ""),
					"</tr>", 
					"<tr>",
						"<td class=ImgSemiModalBody_B1L></div></td>", 
						"<td class=ImgSemiModalBody__BG colspan=2></td>", 
						"<td class=ImgSemiModalBody_B1R></div></td>", 
						(AjxEnv.useTransparentPNGs ? "<td><div class='ImgCurvedShadow_R__V' style='height:100%;'></div></td>" : ""),
					"</tr>", 
					"<tr>",
						"<td id='{$id}_border_bl' class=ImgSemiModalBody_B2L></div></td>", 
						"<td id='{$id}_border_bm' class=ImgSemiModalBody_B2__H colspan=2></td>", 
						"<td id='{$id}_border_br' class=ImgSemiModalBody_B2R></div></td>", 
						(AjxEnv.useTransparentPNGs ? "<td></td>" : ""),
					"</tr>", 
						(AjxEnv.useTransparentPNGs ? 
							"<tr><td class='ImgCurvedShadow_BL'></td>"
								+"<td colspan=2><div id='{$id}_border_shadow_b' class='ImgCurvedShadow_B__H' style='width:100%;'></td>"
								+"<td></td>"
								+"<td><div style='position:relative;'><div class='ImgCurvedShadow_BR' style='position:absolute;left:-20;top:-14'></div></div></td>"
							+"</tr>" 
							: ""
						),
				"</table>",
				"<div id='{$id}_tip_b' class='hover_tip_bottom ImgSemiModalBodyTip_B'></div>"
			)
	} 
);

DwtBorder.registerBorder( 
	"SplashScreen", 
	{ 
		start: AjxBuffer.concat(
				 "<table class='DialogTable' cellpadding='0' Xborder=1>",
					// top edge
					"<tr><td><div style='position:relative'>"+
							"<div class='ImgSplashScreen_blank' style='background-color:white'></div>",
							"<div class=SplashScreenUrl><!--$url--></div>",
							"<div class=SplashScreenShortVersion><!--$shortVersion--></div>",
							"<div class=SplashScreenAppName><!--$appName--></div>",
							"<div class=SplashScreenVersion><!--$version--></div>",
							"<div class=SplashScreenContents><!--$contents--></div>",
							"<div class=SplashScreenLicense><!--$license--></div>",
							"<div class=SplashScreenOKButton id='<!--$buttonId-->'><!--$button--></div>",
						"</div></td>",
						(AjxEnv.useTransparentPNGs ? "<td valign=top class='border_shadow_v'><div class='ImgShadowBig_TR'></div>"+
														"<div class='ImgShadowBig_R__V' style='height:100%'></div></td>" : ""),

					"</tr>"
				),

		end: AjxBuffer.concat(
					// bottom shadow
						(AjxEnv.useTransparentPNGs ? 
							"<tr><td>"+
									"<table cellspacing=0 cellpadding=0 Xborder=1 width=100%><tr>"+
										"<td><div class='ImgShadowBig_BL'></div><td>"+
										"<td width=100%><div class='ImgShadowBig_B__H' style='width:100%'></div></td>"+
									"</tr></table>"+
								"</td>"+
						        "<td class='dialog_shadow_c'><div class='ImgShadowBig_BR'></div></td>"+
							"</tr>"
						  : ""
						),
			     "</table>"
				)
	}
);

DwtBorder.registerBorder( 
	"LoginBanner", 
	{ 
		start: AjxBuffer.concat(
				 "<table class='DialogTable' cellpadding='0' Xborder=1>",
					// top edge
					"<tr><td><div style='position:relative'>"+
							"<div class='ImgLoginBanner_blank'></div>",
							"<div id=LoginBannerUrl><!--$url--></div>",
							"<div id=LoginBannerShortVersion><!--$shortVersion--></div>",
							"<div id=LoginBannerAppName><!--$appName--></div>",
							"<div id=LoginBannerVersion><!--$version--></div>",
						"</div></td>",
					"</tr>",
			     "</table>"
				),
		end:""
	}
);
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtToolTip(shell, className, dialog) {

	this.shell = shell;
	this._dialog = dialog;
	this._div = document.createElement("div");
	this._div.className = className || "DwtToolTip";
	this._div.style.position = DwtControl.ABSOLUTE_STYLE;
	this.shell.getHtmlElement().appendChild(this._div);
	Dwt.setZIndex(this._div, Dwt.Z_HIDDEN);
	Dwt.setLocation(this._div, Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
	var borderStyle = "hover";
	var substitutions = { id: "tooltip" };
	this._borderStart = DwtBorder.getBorderStartHtml(borderStyle, substitutions);
	this._borderEnd = DwtBorder.getBorderEndHtml(borderStyle, substitutions);	
}

DwtToolTip.TOOLTIP_DELAY = 750;

DwtToolTip.prototype.toString = 
function() {
	return "DwtToolTip";
}

DwtToolTip.prototype.getContent =
function() {
	return this._div.innerHTML;
}

DwtToolTip.prototype.setContent =
function(content, setInnerHTML) {
	this._content = content;
	if(setInnerHTML) {
		this._div.innerHTML = this._borderStart + this._content + this._borderEnd;
	}
}
	
DwtToolTip.prototype.popup = 
function(x, y, skipInnerHTML) {
	if (this._content != null) {
		if(!skipInnerHTML) {
			this._div.innerHTML = this._borderStart + this._content + this._borderEnd;
		}

		var element = this._div;
		var baseId = "tooltip";
		var clip = true;
		var dialog = this._dialog;	
		this._positionElement(element, x, y, baseId, clip, dialog);
	}
}

DwtToolTip.prototype.popdown = 
function() {
	if (this._content != null) {
		Dwt.setLocation(this._div, Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
	}
}

DwtToolTip.prototype._positionElement = 
function(element, x, y, baseId, clip, dialog) {
	var WINDOW_GUTTER = 5;
	var POPUP_OFFSET_X = 8;
	var POPUP_OFFSET_Y = 8;

	var tt = document.getElementById(baseId+'_tip_t');
	var tb = document.getElementById(baseId+'_tip_b');
	var t = tt;

	var ex = x;
	var ey = y;

	var w = DwtShell.getShell(window).getSize();
	var ww = w.x;
	var wh = w.y;

	var p = Dwt.getSize(element);
	var pw = p.x;
	var ph = p.y;

	var btEl = document.getElementById(baseId+'_border_tm');
	var blEl = document.getElementById(baseId+'_border_ml');
	var brEl = document.getElementById(baseId+'_border_mr');
	var bbEl = document.getElementById(baseId+'_border_bm');

	var bth = Dwt.getSize(btEl).y;
	var blw = Dwt.getSize(blEl).x;
	var brw = Dwt.getSize(brEl).x;
	var bbh = Dwt.getSize(bbEl).y;

	var ttw = Dwt.getSize(tt).x;
	var tth = Dwt.getSize(tt).y;
	var tbw = Dwt.getSize(tb).x;
	var tbh = Dwt.getSize(tb).y;

	if (AjxEnv.useTransparentPNGs) {
		var bsEl = document.getElementById(baseId+'_border_shadow_b');
		var bsh = Dwt.getSize(bsEl).y;
	}

	/***
	DBG.println(
		"---<br>"+
	    "event: &lt;"+ex+","+ey+"><br>"+
		"window: "+ww+"x"+wh+"<br>"+
	    "popup: "+pw+"x"+ph+"<br>"+
	    "borders: top="+btEl+", left="+blEl+", right="+brEl+", bottom="+bbEl+"<br>"+
	    "borders: top="+bth+", left="+blw+", right="+brw+", bottom="+bbh+"<br>"+
	    "tip: top="+ttw+"x"+tth+", bottom="+tbw+"x"+tbh
    );
    /***/

	var px = ex - pw / 2 - POPUP_OFFSET_X;
	var py;
	
	var ty;
	var tw;

	// tip up
	var adjust = tbh; // NOTE: because bottom tip is relative
	if (ph + ey + tth - bth + POPUP_OFFSET_Y < wh - WINDOW_GUTTER + adjust) {
		py = ey + tth - bth + POPUP_OFFSET_Y;
		tb.style.display = "none";
		ty = bth - tth;
		tw = ttw;
		t = tt;
	}
	
	// tip down
	else {
		py = ey - ph - tbh + bbh - POPUP_OFFSET_Y;
		py += tbh; // NOTE: because bottom tip is relative
		tt.style.display = "none";
		ty = -bbh;
		if (AjxEnv.useTransparentPNGs) {
			ty -= bsh;
		}
		tw = tbw;
		t = tb;
	}

	// make sure popup is wide enough for tip graphic
	if (pw - blw - brw < tw) {
		var contentEl = document.getElementById(baseId+"_contents");
		contentEl.width = tw; // IE
		contentEl.style.width = String(tw)+"px"; // everyone else
	}
	
	// adjust popup x-location
	if (px < WINDOW_GUTTER) {
		px = WINDOW_GUTTER;
	}
	else if (px + pw > ww - WINDOW_GUTTER) {
		px = ww - WINDOW_GUTTER - pw;
	}
	
	// adjust tip x-location
	var tx = ex - px - tw / 2;
	if (tx + tw > pw - brw) {
		tx = pw - brw - tw;
	}
	if (tx < blw) {
		tx = blw;
	}

	t.style.left = tx;
	t.style.top = ty;
	if (clip) {
		if (t == tb) {
			var y = t.offsetTop;
			element.style.clip = "rect(auto,auto,"+(y + tbh)+",auto)";
		}
		else {
			element.style.clip = "rect(auto,auto,auto,auto)";
		}
	}

	Dwt.setLocation(element, px, py);
	var zIndex = dialog ? dialog.getZIndex() + Dwt.Z_INC : Dwt.Z_TOOLTIP;
	Dwt.setZIndex(element, zIndex);
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtStickyToolTip(shell, className, posStyle) {
	className = className || "DwtStickyToolTip";
	posStyle = posStyle || Dwt.ABSOLUTE_STYLE;
	DwtBaseDialog.call(this, shell, className, posStyle, null, DwtBaseDialog.MODELESS);

	this._contentDiv = document.getElementById(this._htmlElId+"_contents");	
	this._contentView = new DwtControl(this);
}
DwtStickyToolTip.prototype = new DwtBaseDialog;
DwtStickyToolTip.prototype.constructor = DwtStickyToolTip;

DwtStickyToolTip.prototype.setTitle = function(title) {
	this._title = title;
	var element = document.getElementById(this._htmlElId+"_title");
	element.innerHTML = title;
}

DwtStickyToolTip.prototype.setContent = function(content) {
	this._contentView.setContent(content);
	this.setView(this._contentView);
}

DwtStickyToolTip.prototype.popup = function(x, y) {
	DwtBaseDialog.prototype.popup.call(this, new DwtPoint(x, y));
}

DwtStickyToolTip.prototype._positionDialog = function (loc) {
	var element = this.getHtmlElement();
	var baseId = this._htmlElId;
	var clip = false;
	
	DwtToolTip.prototype._positionElement.call(this, element, loc.x, loc.y, baseId, clip);
}

DwtStickyToolTip.prototype._createHtml = function() {
	DwtBaseDialog.prototype._createHtml.call(this);
	
	var close = new DwtButton(this, DwtLabel.IMAGE_RIGHT | DwtLabel.ALIGN_RIGHT, "DwtStickyToolTipClose");
	// REVISIT: Do this right...
	close.setImage(["ImgRedCircleClose"]);
	close.addSelectionListener(new AjxListener(this, this._handleClose));
	
	var container = document.getElementById(this._htmlElId+"_close");
	var closeEl = close.getHtmlElement();
	container.appendChild(closeEl);
}
DwtStickyToolTip.prototype._handleClose = function(event) {
	this.popdown();
	this.dispose();
}

DwtStickyToolTip.prototype._getStartBorder = function () {
	// REVISIT
	if (!this._titleHandleId) this._titleHandleId = Dwt.getNextId();
	if (!this._contentId) this._contentId = Dwt.getNextId();
	if (!this._titleCellId) this._titleCellId = Dwt.getNextId();
	
	var borderStyle = "SemiModalDialog";
	//var substitutions = {title : this._title, titleTextId: this._titleCellId, titleId: this._titleHandleId};
	var substitutions = { id: this._htmlElId, title: this._title };
	return DwtBorder.getBorderStartHtml(borderStyle, substitutions);
};

DwtStickyToolTip.prototype._getEndBorder = function () {
	var borderStyle = "SemiModalDialog";
	var substitutions = { id: this._htmlElId };
	return DwtBorder.getBorderEndHtml(borderStyle, substitutions);
};

DwtStickyToolTip.prototype._getContentHtml = function () {
	return "";
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/

/**
* Creates a Tree Item.
* @constructor
* @class
* This class implements a tree item widget.
*
* @author Ross Dargahi
* @param parent		the parent widget
* @param index		location in siblings (optional)
* @param text 		label text for the tree item (optional);
* @param imageInfo	icon for the tree item (optional)
* @param deferred	if true, then the UI elements of the item are not rendered until needed (i.e. when item becomes visible)
* @param className	CSS class (optional)
* @param posStyle	positioning style (absolute, static, or relative - optional defaults to static)
*/
function DwtTreeItem(parent, index, text, imageInfo, deferred, className, posStyle) {
	if (arguments.length==0) return;
	if (parent instanceof DwtTree)
		this._tree = parent;
	else if (parent instanceof DwtTreeItem)
		this._tree = parent._tree;
	else 
		throw new DwtException("DwtTreeItem parent must be a DwtTree or DwtTreeItem", DwtException.INVALIDPARENT, "DwtTreeItem");

	this._origClassName = className ? className : "DwtTreeItem";
	this._textClassName = this._origClassName + "-Text";
	this._selectedClassName = this._origClassName + "-" + DwtCssStyle.SELECTED;
	this._actionedClassName = this._origClassName + "-" + DwtCssStyle.ACTIONED;
	this._dragOverClassName = this._origClassName + "-DragOver";

	DwtComposite.call(this, parent, null, posStyle, true);

	this._imageInfoParam = imageInfo;
	this._textParam = text;
	this._deferred = (deferred !== false);
	this._itemChecked = false;
	this._initialized = false;
	this._selectionEnabled = true;
	this._actionEnabled = true;

	// disable selection if checkbox style
	if (this._tree._isCheckedStyle()) {
		this.enableSelection(false);
		this._selectedClassName = this._origClassName;
	}

	/* if our parent is DwtTree or our parent is initialized and is not deferred type
	 * or is expanded, then initialize ourself, else wait */ 
	if (parent instanceof DwtTree || (parent._initialized && (!parent._deferred || parent._expanded))) {
		this._initialize(index);
	} else {
		parent._addDeferredChild(this, index);
		this._index = index;
	}
}

DwtTreeItem.prototype = new DwtComposite;
DwtTreeItem.prototype.constructor = DwtTreeItem;

DwtTreeItem.prototype.toString = 
function() {
	return "DwtTreeItem";
}

DwtTreeItem._NODECELL_DIM = "16px";

DwtTreeItem.prototype.getChecked =
function() {
	return this._itemChecked;
}

DwtTreeItem.prototype.setChecked =
function(checked, force) {
	if ((this._itemChecked != checked) || force) {
		this._itemChecked = checked;
		if (this._checkBox != null && (this._checkBoxCell && Dwt.getVisible(this._checkBoxCell))) {
			this._checkBox.checked = checked;
			
			// NOTE: This hack is needed because IE actively loses the checked
			//		 state for checkbox elements that are programmatically set
			//		 before being added to the document tree (or even before
			//		 layout, from the looks of things).
			//
			//		 The following code will demonstrate the bug:
			//
			//		 var checkbox = document.createElement("INPUT");
			//		 checkbox.type = "checkbox";
			//		 checkbox.checked = true;
			//		 document.body.appendChild(checkbox);
			//		 alert(checkbox.checked);
			if (this._checkBox._ieHack) {
				if (checked) {
					var checkbox = document.createElement("<INPUT type='checkbox' checked>");
					Dwt.setHandler(checkbox, DwtEvent.ONMOUSEDOWN, DwtTreeItem._checkBoxMouseDownHdlr);
					Dwt.setHandler(checkbox, DwtEvent.ONMOUSEUP, DwtTreeItem._checkBoxMouseUpHdlr);
					this._checkBox.parentNode.replaceChild(checkbox, this._checkBox);
					this._checkBox = checkbox;
				}
				else {
					delete this._checkBox._ieHack;
				}
			}
		}
	}
}

DwtTreeItem.prototype.getExpanded =
function() {
	return this._expanded;
}

/**
* Expands or collapses this tree item.
*
* @param expanded		if true, expands this node, otherwise collapses it
* @param recurse		expand children recursively (doesn't apply to collapsing)
*/
DwtTreeItem.prototype.setExpanded =
function(expanded, recurse) {

	// Go up the chain, ensuring that parents are expanded/initialized
	if (expanded) {
		var p = this.parent;
		while (p instanceof DwtTreeItem && !p._expanded) {
			p.setExpanded(true);
			p = p.parent;
		}
		// Realize any deferred children
		this._realizeDeferredChildren();
	}
		
	// If we have children, then allow for expanding/collapsing
	if (this.getNumChildren()) {
		if (expanded && recurse) {
			if (!this._expanded)
				this._expand(expanded);
			var a = this.getChildren();
			for (var i = 0; i < a.length; i++)
				if (a[i] instanceof DwtTreeItem)
					a[i].setExpanded(expanded, recurse);
		} else if (this._expanded != expanded) {
			this._expand(expanded);
		}
	}
}

DwtTreeItem.prototype.getItemCount =
function() {
	return this._children.size();
}

DwtTreeItem.prototype.getItems =
function() {
	return this._children.getArray();
}

DwtTreeItem.prototype.getImage =
function() {
	return this._imageInfo;
}

DwtTreeItem.prototype.setImage =
function(imageInfo) {
	if (this._initialized) {
		AjxImg.setImage(this._imageCell, imageInfo);
		this._imageInfo = imageInfo;
	} else {
		this._imageInfoParam = imageInfo;
	}	
}

DwtTreeItem.prototype.setDndImage =
function(imageInfo) {
	this._dndImageInfo = imageInfo;
}

DwtTreeItem.prototype.getSelected =
function() {
	return this._selected;
}

DwtTreeItem.prototype.getActioned =
function() {
	return this._actioned;
}

DwtTreeItem.prototype.getText =
function() {
	return this._text;
}

DwtTreeItem.prototype.setText =
function(text) {
	if (this._initialized) {
		if (!text)
			text.data = "";
		this._text = this._textCell.innerHTML = text;
	} else {
		this._textParam = text;
	}
}

DwtTreeItem.prototype.setDndText =
function(text) {
	this._dndText = text;
}

DwtTreeItem.prototype.showCheckBox =
function(show) {
	if (this._checkBoxCell)
		Dwt.setVisible(this._checkBoxCell, show);
}

DwtTreeItem.prototype.showExpansionIcon =
function(show) {
	if (this._nodeCell)
		Dwt.setVisible(this._nodeCell, show);
}

DwtTreeItem.prototype.enableSelection =
function(enable) {
	this._selectionEnabled = enable;
}

DwtTreeItem.prototype.enableAction =
function(enable) {
	this._actionEnabled = enable;
}

/**
* Adds a separator at the given index. If no index is provided, adds it at the
* end. A separator cannot currently be added as the first item (the child div will
* not have been created).
*
* @param index		position at which to add the separator
*/
DwtTreeItem.prototype.addSeparator =
function(index) {
	var child = new Object();
	child._isSeparator = true;
	child._initialized = false;
	this._children.add(child, index);
}

/**
* Makes this tree item, or just part of it, visible or hidden.
*
* @param visible		if true, item (or part of it) becomes visible
* @param itemOnly		apply to this item's DIV only; child items are unaffected
* @param childOnly		apply to this item's child items only
*/
DwtTreeItem.prototype.setVisible =
function(visible, itemOnly, childOnly) {
	if (itemOnly && !childOnly) {
		Dwt.setVisible(this._itemDiv, visible);
	} else if (childOnly && !itemOnly) {
		Dwt.setVisible(this._childDiv, visible);
	} else {
		DwtComposite.prototype.setVisible.call(this, visible);
	}
}

DwtTreeItem.prototype.removeChild =
function(child) {
	if (child._initialized) {
		this._tree._deselect(child);
		this._childDiv.removeChild(child.getHtmlElement());
	}
	this._children.remove(child);

	/* if we have no children and we are expanded, then mark us a collapsed. Also if there
	 * are no deferred children, then make sure we remove the expand/collapse icon and 
	 * replace it with a blank16Icon. */
	if (this._children.size() == 0) {
		if (this._expanded)
			this._expanded = false;
		
		if (this._initialized) {
			AjxImg.setImage(this._nodeCell, "Blank_16");
			var imgEl = AjxImg.getImageElement(this._nodeCell);
			if (imgEl)
				Dwt.clearHandler(imgEl, DwtEvent.ONMOUSEDOWN);
		}
	}
}

DwtTreeItem.prototype._initialize =
function(index) {
	/* PLEASE NOTE! The noWrap = true statements are important to prevent Moz/FF from squishing tree items
	 * the to right in the view! */
	 
	this._setMouseEventHdlrs();
	
	this._itemDiv = document.createElement("div");
	this._itemDiv.className = this._origClassName;
	this.getHtmlElement().appendChild(this._itemDiv);

	this._table = document.createElement("table");
	this._table.cellSpacing = this._table.cellPadding = 0;
	this._table.border = 0;
	this._itemDiv.appendChild(this._table);
	
	this._row = this._table.insertRow(0);
	var i = 0;
	nodeCell = this._row.insertCell(i++);
	nodeCell.style.width = nodeCell.style.height = DwtTreeItem._NODECELL_DIM;
	nodeCell.align = "center";
	nodeCell.noWrap = true;
	this._nodeCell = nodeCell;
	
	// If we have deferred children, then we need to make sure we set up accordingly
	if (this._children.size() > 0) {
		AjxImg.setImage(this._nodeCell, "NodeCollapsed");
		var imgEl = AjxImg.getImageElement(this._nodeCell);
		if (imgEl) {
			Dwt.setHandler(imgEl, DwtEvent.ONMOUSEDOWN, DwtTreeItem._nodeIconMouseDownHdlr);
			Dwt.setHandler(imgEl, DwtEvent.ONMOUSEUP, DwtTreeItem._nodeIconMouseUpHdlr);
		}
	} else {
		AjxImg.setImage(this._nodeCell, "Blank_16");
	}
	
	if (this._tree._isCheckedStyle()) {
      	this._checkBoxCell = this._row.insertCell(i++);
      	this._checkBoxCell.noWrap = true;
      	this._checkBox = document.createElement("input");
      	this._checkBox.type = "checkbox";
      	if (AjxEnv.isIE) {
      		// NOTE: See note in setChecked method to see why this is here.
      		this._checkBox._ieHack = true;
  		}
      	this._checkBoxCell.appendChild(this._checkBox);
		Dwt.setHandler(this._checkBox, DwtEvent.ONMOUSEDOWN, DwtTreeItem._checkBoxMouseDownHdlr);
		Dwt.setHandler(this._checkBox, DwtEvent.ONMOUSEUP, DwtTreeItem._checkBoxMouseUpHdlr);
      	this._checkBox.checked = this._itemChecked;
	}
	
	this._imageCell = this._row.insertCell(i++);
	this._imageCell.className = "imageCell";
	//this._imageCell.style.paddingRight = "3px";
	this._imageCell.noWrap = true;
	if (this._imageInfoParam) {
		AjxImg.setImage(this._imageCell, this._imageInfoParam);
		this._imageInfo = this._imageInfoParam;
	}
	
	this._textCell = this._row.insertCell(i);
    this._textCell.className = this._textClassName;
    this._textCell.noWrap = true;
    if (this._textParam)
		this._textCell.innerHTML = this._text = this._textParam;

    this._expanded = this._selected = this._actioned = false;
    this._gotMouseDownLeft = this._gotMouseDownRight = false;
    this.addListener(DwtEvent.ONMOUSEDOWN, new AjxListener(this, this._mouseDownListener));
    this.addListener(DwtEvent.ONMOUSEOUT, new AjxListener(this, this._mouseOutListener));
    this.addListener(DwtEvent.ONMOUSEUP, new AjxListener(this, this._mouseUpListener));
    this.addListener(DwtEvent.ONDBLCLICK, new AjxListener(this, this._doubleClickListener));  

	this.parent._addItem(this, index);
	this._initialized = true;
}

DwtTreeItem.prototype._addDeferredChild =
function(child, index) {
	// If we are initialized, then we need to add a expansion node
	if (this._initialized && this._children.size() == 0) {
		AjxImg.setImage(this._nodeCell, "NodeCollapsed");
		var imgEl = AjxImg.getImageElement(this._nodeCell);
		if (imgEl) {
			Dwt.setHandler(imgEl, DwtEvent.ONMOUSEDOWN, DwtTreeItem._nodeIconMouseDownHdlr);
			Dwt.setHandler(imgEl, DwtEvent.ONMOUSEUP, DwtTreeItem._nodeIconMouseUpHdlr);
		}
	}
	this._children.add(child, index);
}

DwtTreeItem.prototype.addChild =
function(child) {}

DwtTreeItem.prototype._addItem =
function(item, index) {
	if (!this._children.contains(item))
		this._children.add(item, index);
	
	if (this._childDiv == null) {
		this._childDiv = document.createElement("div");
		if (this.parent != this._tree) {
			this._childDiv.className = "DwtTreeItemChildDiv";
		} else {
			this._childDiv.className = "DwtTreeItemLevel1ChildDiv";
		}
		this.getHtmlElement().appendChild(this._childDiv);
		if (!this._expanded) 
			this._childDiv.style.display = "none";
	}
	
	if (AjxImg.getImageClass(this._nodeCell) == AjxImg.getClassForImage("Blank_16")) {
		if (this._expanded) 
			AjxImg.setImage(this._nodeCell, "NodeExpanded");
		else 
			AjxImg.setImage(this._nodeCell, "NodeCollapsed");
		var imgEl = AjxImg.getImageElement(this._nodeCell);
		if (imgEl)
			Dwt.setHandler(imgEl, DwtEvent.ONMOUSEDOWN, DwtTreeItem._nodeIconMouseDownHdlr);
	}	
	
	var childDiv = this._childDiv;
	var numChildren = childDiv.childNodes.length;
	if (index == null || index >= numChildren || numChildren == 0) {
		childDiv.appendChild(item.getHtmlElement());
	} else {
		childDiv.insertBefore(item.getHtmlElement(), childDiv.childNodes[index]);
	}
}

DwtTreeItem.prototype._getDnDIcon =
function() {
	var icon = document.createElement("div");
	Dwt.setPosition(icon, Dwt.ABSOLUTE_STYLE); 
	var table = document.createElement("table");
	icon.appendChild(table);
	table.cellSpacing = table.cellPadding = 0;
		
	var row = table.insertRow(0);
	var i = 0;
	
	var c = row.insertCell(i++);
	c.noWrap = true;
	if (this._dndImageInfo) {
		AjxImg.setImage(c, this._dndImageInfo);
	} else if (this._imageInfo) {
		AjxImg.setImage(c, this._imageInfo);
	}
	
	c = row.insertCell(i);
    c.noWrap = true;
    c.className = this._origClassName;
	if (this._dndText) {
    	c.innerHTML = this._dndText;
	} else if (this._text) {
    	c.innerHTML = this._text;
	}
	
	this.shell.getHtmlElement().appendChild(icon);
	Dwt.setZIndex(icon, Dwt.Z_DND);
	return icon;
}

DwtTreeItem.prototype._dragEnter =
function() {
	this._preDragClassName = this._textCell.className;
	this._textCell.className = this._dragOverClassName;
}

DwtTreeItem.prototype._dragHover =
function() {
	if (this.getNumChildren() > 0 && !this.getExpanded())
		this.setExpanded(true);
}

DwtTreeItem.prototype._dragLeave =
function() {
	if (this._preDragClassName)
		this._textCell.className = this._preDragClassName;
}

DwtTreeItem.prototype._drop =
function() {
	if (this._preDragClassName)
		this._textCell.className = this._preDragClassName;
}

DwtTreeItem._nodeIconMouseDownHdlr = 
function(ev) {
	var obj = DwtUiEvent.getDwtObjFromEvent(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);	
	if (mouseEv.button == DwtMouseEvent.LEFT) {
		obj._expand(!obj._expanded, ev);
	} else if (mouseEv.button == DwtMouseEvent.RIGHT) {
		mouseEv.dwtObj._tree._itemActioned(mouseEv.dwtObj, mouseEv);
	}

	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;
}

DwtTreeItem._nodeIconMouseUpHdlr = 
function(ev) {
	var obj = DwtUiEvent.getDwtObjFromEvent(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;
}

DwtTreeItem.prototype._expand =
function(expand, ev) {
	if (!expand) {
		this._expanded = false;
		this._childDiv.style.display = "none";
		AjxImg.setImage(this._nodeCell, "NodeCollapsed");
		this._tree._itemCollapsed(this, ev);
	} else {
		// The first thing we need to do is initialize any deferred children so that they
		// actually have content
		this._realizeDeferredChildren();
		this._expanded = true;
		this._childDiv.style.display = "block";
		AjxImg.setImage(this._nodeCell, "NodeExpanded");
		this._tree._itemExpanded(this, ev);
	}	
}

DwtTreeItem.prototype._realizeDeferredChildren =
function() {
	var a = this._children.getArray();
	for (var i = 0; i < a.length; i++) {
		if (!a[i]._initialized) {
			if (a[i]._isSeparator) {
				var div = document.createElement("div");
				div.className = "vSpace";
				this._childDiv.appendChild(div);
				a[i]._initialized = true;
			} else {
				a[i]._initialize(a[i]._index);
			}
		}
	}
}

DwtTreeItem.prototype._isChildOf =
function(item) {
	var test = this.parent;
	while (test && test != this._tree) {
		if (test == item)
			return true;
		test = test.parent;
	}
	return false;
}

DwtTreeItem.prototype._setSelected =
function(selected) {
	if (this._selected != selected) {
		this._selected = selected;
		if (!this._initialized)
			this._initialize();
		if (selected && this._selectionEnabled) {
			this._textCell.className = this._selectedClassName;
			return true;
		} else {
			this._textCell.className = this._textClassName;
			return false;
		}
	}
}

DwtTreeItem.prototype._setActioned =
function(actioned) {
	if (this._actioned != actioned) {
		this._actioned = actioned;
		if (!this._initialized)
			this._initialize();
		if (actioned && this._actionEnabled && !this._selected) {
			this._textCell.className = this._actionedClassName;
			return true;
		} else if (!actioned) {
			this._textCell.className = this._textClassName;
			return false;
		}
	}
}

DwtTreeItem.prototype._mouseDownListener = 
function(ev) {
	if (ev.target == this._childDiv) return;

	if (ev.button == DwtMouseEvent.LEFT && this._selectionEnabled)
		this._gotMouseDownLeft = true;
	else if (ev.button == DwtMouseEvent.RIGHT && this._actionEnabled)
		this._gotMouseDownRight = true;
}

DwtTreeItem.prototype._mouseOutListener = 
function(ev) {
	if (ev.target == this._childDiv) return;

	this._gotMouseDownLeft = false;
	this._gotMouseDownRight = false;
}

DwtTreeItem.prototype._mouseUpListener = 
function(ev) {
	// Ignore any mouse events in the child div i.e. the div which 
	// holds all the items children. In the case of IE, no clicks are
	// reported when clicking in the padding area (note all children
	// are indented using padding-left style); however, mozilla
	// reports mouse events that happen in the padding area
	if (ev.target == this._childDiv) return;

	if (ev.button == DwtMouseEvent.LEFT && this._gotMouseDownLeft)
		this._tree._itemClicked(this, ev);
	else if (ev.button == DwtMouseEvent.RIGHT && this._gotMouseDownRight)
		this._tree._itemActioned(this, ev);
}

DwtTreeItem.prototype._doubleClickListener =
function(ev) {
	// See comment in DwtTreeItem.prototype._mouseDownListener
	if (ev.target == this._childDiv) 
		return;
	var obj = DwtUiEvent.getDwtObjFromEvent(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	if (mouseEv.button == DwtMouseEvent.LEFT || mouseEv.button == DwtMouseEvent.NONE) // NONE for IE bug
		mouseEv.dwtObj._tree._itemDblClicked(mouseEv.dwtObj, mouseEv);
}

DwtTreeItem._checkBoxMouseDownHdlr =
function(ev) {
	var obj = DwtUiEvent.getDwtObjFromEvent(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);	
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;
}

DwtTreeItem._checkBoxMouseUpHdlr =
function(ev) {
	var obj = DwtUiEvent.getDwtObjFromEvent(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	if (mouseEv.button == DwtMouseEvent.LEFT) {
		mouseEv.dwtObj._itemChecked = !mouseEv.dwtObj._itemChecked;	
		mouseEv.dwtObj._tree._itemChecked(mouseEv.dwtObj, mouseEv);
	} else if (mouseEv.button == DwtMouseEvent.RIGHT) {
		mouseEv.dwtObj._tree._itemActioned(mouseEv.dwtObj, mouseEv);
	}
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a Tree widget.
* @constructor
* @class
* This class implements a tree widget. Tree widgets may contain one or more DwtTreeItems.
*
* @author Ross Dargahi
* @param parent		the parent widget
* @param style 		tree style either: DwtTree.SINGLE_STYLE (single selction) or DwtTree.MULTI_STYLE (multiselection);
* @param className	CSS class
* @param posStyle	positioning style (absolute, static, or relative)
*/
function DwtTree(parent, style, className, posStyle) {

	if (arguments.length == 0) return;
	className = className || "DwtTree";
	DwtComposite.call(this, parent, className, posStyle);

	if (style == null) {
		this._style = DwtTree.SINGLE_STYLE;
	} else {
		if (style == DwtTree.CHECKEDITEM_STYLE)
			style |= DwtTree.SINGLE_STYLE;
		this._style = style;
	}
	this._selectedItems = new AjxVector();
	this._selEv = new DwtSelectionEvent(true);
}

DwtTree.prototype = new DwtComposite;
DwtTree.prototype.constructor = DwtTree;

DwtTree.prototype.toString = 
function() {
	return "DwtTree";
}

DwtTree.SINGLE_STYLE = 1;
DwtTree.MULTI_STYLE = 2;
DwtTree.CHECKEDITEM_STYLE = 4;

DwtTree.ITEM_SELECTED = 0;
DwtTree.ITEM_DESELECTED = 1;
DwtTree.ITEM_CHECKED = 2;
DwtTree.ITEM_ACTIONED = 3;
DwtTree.ITEM_DBL_CLICKED = 4;

DwtTree.ITEM_EXPANDED = 1;
DwtTree.ITEM_COLLAPSED = 2;

DwtTree.prototype.addSelectionListener = 
function(listener) {
	this.addListener(DwtEvent.SELECTION, listener);
}

DwtTree.prototype.removeSelectionListener = 
function(listener) {
	this.removeListener(DwtEvent.SELECTION, listener);    	
}

DwtTree.prototype.addTreeListener = 
function(listener) {
	this.addListener(DwtEvent.TREE, listener);
}

DwtTree.prototype.removeTreeListener = 
function(listener) {
	this.removeListener(DwtEvent.TREE, listener);    		
}

DwtTree.prototype.getItemCount =
function() {
	return this._children.size();
}

DwtTree.prototype.getItems =
function() {
	return this._children.getArray();
}

DwtTree.prototype.deselectAll =
function() {
	var a = this._selectedItems.getArray();
	var sz = this._selectedItems.size();
	for (var i = 0; i < sz; i++) {
		a[i]._setSelected(false);
	}
	if (sz > 0)
		this._notifyListeners(DwtEvent.SELECTION, this._selectedItems.getArray(), DwtTree.ITEM_DESELECTED, null, this._selEv);
	this._selectedItems.removeAll();
}

DwtTree.prototype.getSelection =
function() {
	return this._selectedItems.getArray();
}

DwtTree.prototype.setSelection =
function(treeItem, skipNotify) {
	// Remove currently selected items from the selection list. if <treeItem> is in that list, then note it and return
	// after we are done processing the selected list
	var a = this._selectedItems.getArray();
	var sz = this._selectedItems.size();
	var da;
	var j = 0;
	var alreadySelected = false;
	for (var i = 0; i < sz; i++) {
		if (a[i] == treeItem) 
			alreadySelected = true;
		else {
			a[i]._setSelected(false);
			this._selectedItems.remove(a[i]);
			if (da == null)
				da = new Array();
			da[j++] = a[i];
		}
	}

	if (da && !skipNotify)
		this._notifyListeners(DwtEvent.SELECTION, da, DwtTree.ITEM_DESELECTED, null, this._selEv);

	if (alreadySelected)
		return;
	this._selectedItems.add(treeItem);
	
	// Expand all parent nodes, and then set item selected
	var parent = treeItem.parent
	while(parent instanceof DwtTreeItem) {
		parent.setExpanded(true);
		parent = parent.parent;
	}
	if (treeItem._setSelected(true) && !skipNotify)
		this._notifyListeners(DwtEvent.SELECTION, [treeItem], DwtTree.ITEM_SELECTED, null, this._selEv);
}

DwtTree.prototype.getSelectionCount =
function() {
	return this._selectedItems.size();
}

DwtTree.prototype.addChild =
function(child) {}

DwtTree.prototype.addSeparator =
function() {
	var sep = document.createElement("div");
//	sep.className = "horizSep";
	sep.className = "vSpace";
	this.getHtmlElement().appendChild(sep);
}

DwtTree.prototype._addItem =
function(item, index) {
	this._children.add(item, index);
	var thisHtmlElement = this.getHtmlElement();
	var numChildren = thisHtmlElement.childNodes.length;
	if (index == null || index > numChildren) {
		thisHtmlElement.appendChild(item.getHtmlElement());
	} else {
		thisHtmlElement.insertBefore(item.getHtmlElement(), thisHtmlElement.childNodes[index]);	
	}
}

DwtTree.prototype.removeChild =
function(child) {
	this._children.remove(child);
	this._selectedItems.remove(child);
	this.getHtmlElement().removeChild(child.getHtmlElement());
}

/**
* Workaround for IE, which resets checkbox state when an element is appended to the DOM.
* Go through all tree items recursively. If one is checked, make sure the element is checked.
*
* @param treeItem	[DwtTreeItem]	checkbox style tree item
*/
DwtTree.prototype.setCheckboxes =
function(treeItem) {
	if (!this._isCheckedStyle() || !AjxEnv.isIE) return;
	
	var items;
	if (treeItem) {
		treeItem.setChecked(treeItem.getChecked(), true);
		items = treeItem.getItems();
	} else {
		items = this.getItems();
	}
	for (var i = 0; i < items.length; i++)
		this.setCheckboxes(items[i]);
};

DwtTree.prototype._deselect =
function(item) {
	if (this._selectedItems.contains(item)) {
		this._selectedItems.remove(item);
		item._setSelected(false);
		this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_DESELECTED, null, this._selEv);
	}
}

DwtTree.prototype._isCheckedStyle =
function() {
	return ((this._style & DwtTree.CHECKEDITEM_STYLE) != 0);
}

DwtTree.prototype._itemActioned =
function(item, ev) {
	if (this._actionedItem) {
		this._actionedItem._setActioned(false);
		this._notifyListeners(DwtEvent.SELECTION, [this._actionedItem], DwtTree.ITEM_DESELECTED, ev, this._selEv);
	}
	this._actionedItem = item;
	item._setActioned(true);
	this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_ACTIONED, ev, this._selEv);
}

DwtTree.prototype._itemChecked =
function(item, ev) {
	this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_CHECKED, ev, this._selEv);
}

DwtTree.prototype._itemClicked =
function(item, ev) {
	var i;
	var a = this._selectedItems.getArray();
	var numSelectedItems = this._selectedItems.size();
	if (this._style & DwtTree.SINGLE_STYLE || (!ev.shiftKey && !ev.ctrlKey)) {
		if (numSelectedItems > 0) {
			for (i = 0; i < numSelectedItems; i++)
				a[i]._setSelected(false);
			// Notify listeners of deselection
			this._notifyListeners(DwtEvent.SELECTION, this._selectedItems.getArray(), DwtTree.ITEM_DESELECTED, ev, this._selEv);
			this._selectedItems.removeAll();
		}
		this._selectedItems.add(item);
		if (item._setSelected(true))
			this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_SELECTED, ev, this._selEv);
	} else {
		if (ev.ctrlKey) {
			if (this._selectedItems.contains(item)) {
				this._selectedItems.remove(item);
				item._setSelected(false);
				this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_DESELECTED, ev, this._selEv);
			} else {
				this._selectedItems.add(item);
				if (item._setSelected(true))
					this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_SELECTED, ev, this._selEv);
			}
		} else {
			// SHIFT KEY
		}
	}
}

DwtTree.prototype._itemDblClicked = 
function(item, ev) {
	this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_DBL_CLICKED, ev, this._selEv);
}

DwtTree.prototype._itemExpanded =
function(item, ev) {
	this._notifyListeners(DwtEvent.TREE, [item], DwtTree.ITEM_EXPANDED, ev, DwtShell.treeEvent);
}

DwtTree.prototype._itemCollapsed =
function(item, ev) {
	var i;
	if (ev)
		this._notifyListeners(DwtEvent.TREE, [item], DwtTree.ITEM_COLLAPSED, ev, DwtShell.treeEvent);
	var setSelection = false;
	var a = this._selectedItems.getArray();
	var numSelectedItems = this._selectedItems.size();
	var da;
	var j = 0;
	for (i = 0; i < numSelectedItems; i++) {
		if (a[i]._isChildOf(item)) {
			setSelection = true;
			if (da == null)
				da = new Array();
			da[j++] = a[i];
			a[i]._setSelected(false);
			this._selectedItems.remove(a[i]);
		}		
	}

	if (da)
		this._notifyListeners(DwtEvent.SELECTION, da, DwtTree.ITEM_DESELECTED, ev, this._selEv);

	if (setSelection && !this._selectedItems.contains(item)) {
		this._selectedItems.add(item);
		if (item._setSelected(true))
			this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_SELECTED, ev, this._selEv);
	}
}

DwtTree.prototype._notifyListeners =
function(listener, items, detail, srcEv, destEv) {
	if (this.isListenerRegistered(listener)) {
		if (srcEv)
			DwtUiEvent.copy(destEv, srcEv);
		destEv.items = items;
		if (items.length == 1)
			destEv.item = items[0];
		destEv.detail = detail;
		this.notifyListeners(listener, destEv);
	}
}/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a calendar widget
* @constructor
* @class
* The DwtCalendar widget provides a calendar view.
*
* @author Ross Dargahi
* @author Roland Schemers
*
* @param parent 		Parent object
* @param className		This instances class name defaults to DwtCalendar
* @param posStyle		Positioning style defaults to DwtControl.STATIC_STYLE
* @param firstDayOfWeek	The first day of the week. Defaults to DwtCalendar.SUN
* @param forceRollOver 	If true, then clicking on (or setting) the widget to a 
						date that is not part of the current month (i.e. one of 
						the grey prev or next month days) will result in the 
						widget rolling 	the date to that month. Default is true
* @param workingDaysArray	An array specifying the working days. This array 
						assume index 0 - Sunday etc. Defaults to Mon-Fri being 
						working days
* @param hidePrevNextMo Flag indicating whether widget should hide days of the 
						previous/next month
* @param readOnly 		Flag indicating this widget is read-only (should not 
						process events, i.e. mouse clicks)
*/
function DwtCalendar(parent, className, posStyle, firstDayOfWeek, forceRollOver, workingDaysArray, hidePrevNextMo, readOnly) {

	if (arguments.length == 0) return;
	className = className || "DwtCalendar";
	DwtComposite.call(this, parent, className, posStyle);

	this._skipNotifyOnPage = false;
	this._hidePrevNextMo = hidePrevNextMo;
	this._readOnly = readOnly;
	this._uuid = Dwt.getNextId();
	var cn = this._origDayClassName = className + "Day";
	this._todayClassName = " " + className + "Day-today";
	this._selectedDayClassName = " " + cn + "-" + DwtCssStyle.SELECTED;
	this._activatedDayClassName = " " + cn + "-" + DwtCssStyle.ACTIVATED;
	this._triggeredDayClassName = " " + cn + "-" + DwtCssStyle.TRIGGERED;
	this._hiliteClassName = " " + cn + "-hilited";
	this._greyClassName = " " + cn + "-grey"
	
	if (!this._readOnly)
		this._installListeners();
	this.setCursor("default");
	
	this._selectionMode = DwtCalendar.DAY;
	
	this._init();

	this._weekDays = new Array(7);
	this._workingDays = (workingDaysArray == null) ? DwtCalendar._DEF_WORKING_DAYS : workingDaysArray;
	this.setFirstDayOfWeek((firstDayOfWeek == null) ? DwtCalendar.SUN : firstDayOfWeek);
	
	this._forceRollOver = (forceRollOver) ? forceRollOver : true;
}

DwtCalendar.prototype = new DwtComposite;
DwtCalendar.prototype.constructor = DwtCalendar;

DwtCalendar.SUN = 0;
DwtCalendar.MON = 1;
DwtCalendar.TUE = 2;
DwtCalendar.WED = 3;
DwtCalendar.THU = 4;
DwtCalendar.FRI = 5;
DwtCalendar.SAT = 6;

// Selection modes
DwtCalendar.DAY = 1;
DwtCalendar.WEEK = 2;
DwtCalendar.WORK_WEEK = 3;
DwtCalendar.MONTH = 4;

DwtCalendar.RANGE_CHANGE = "DwtCalendar.RANGE_CHANGE";

DwtCalendar._FULL_WEEK = [1, 1, 1, 1, 1, 1, 1];
DwtCalendar._DEF_WORKING_DAYS = [0, 1, 1, 1, 1, 1, 0];
DwtCalendar._DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

DwtCalendar._NO_MONTH = -2;
DwtCalendar._PREV_MONTH = -1;
DwtCalendar._THIS_MONTH = 0;
DwtCalendar._NEXT_MONTH = 1;

DwtCalendar._NORMAL = 1;
DwtCalendar._ACTIVATED = 2;
DwtCalendar._TRIGGERED = 3;
DwtCalendar._SELECTED = 4;
DwtCalendar._DESELECTED = 5;

DwtCalendar.DATE_SELECTED 		= 1;
DwtCalendar.DATE_DESELECTED 	= 2;
DwtCalendar.DATE_DBL_CLICKED 	= 3;

DwtCalendar._LAST_DAY_CELL_IDX = 41;

DwtCalendar._BUTTON_CLASS = "DwtCalendarButton";
DwtCalendar._BUTTON_ACTIVATED_CLASS = DwtCalendar._BUTTON_CLASS + "-" + DwtCssStyle.ACTIVATED;
DwtCalendar._BUTTON_TRIGGERED_CLASS = DwtCalendar._BUTTON_CLASS + "-" + DwtCssStyle.TRIGGERED;

DwtCalendar._TITLE_CLASS = "DwtCalendarTitle";
DwtCalendar._TITLE_ACTIVATED_CLASS = DwtCalendar._TITLE_CLASS + "-" + DwtCssStyle.ACTIVATED;
DwtCalendar._TITLE_TRIGGERED_CLASS = DwtCalendar._TITLE_CLASS + "-" + DwtCssStyle.TRIGGERED;

DwtCalendar.prototype.toString = 
function() {
	return "DwtCalendar";
}

DwtCalendar.prototype.addSelectionListener = 
function(listener) {
	this.addListener(DwtEvent.SELECTION, listener);
}

DwtCalendar.prototype.removeSelectionListener = 
function(listener) { 
	this.removeListener(DwtEvent.SELECTION, listener);
}

DwtCalendar.prototype.addActionListener = 
function(listener) {
	this.addListener(DwtEvent.ACTION, listener);
}

DwtCalendar.prototype.removeActionListener = 
function(listener) { 
	this.removeListener(DwtEvent.ACTION, listener);
}


/* Date range listeners are called whenever the date range of the calendar changes i.e. when it rolls over
 * due to a programatic action via setDate or via user selection
 */
DwtCalendar.prototype.addDateRangeListener = 
function(listener) {
	this.addListener(DwtEvent.DATE_RANGE, listener);
}

DwtCalendar.prototype.removeDateRangeListener = 
function(listener) { 
	this.removeListener(DwtEvent.DATE_RANGE, listener);
}

// call this method with true to not notify selection when paging arrow buttons are clicked
DwtCalendar.prototype.setSkipNotifyOnPage = 
function(skip) {
	this._skipNotifyOnPage = skip;
}

// call this method get whether we are skipping notify on page buttons or not
DwtCalendar.prototype.getSkipNotifyOnPage = 
function() {
	return this._skipNotifyOnPage;
}

DwtCalendar.prototype.setDate =
function(date, skipNotify, forceRollOver, dblClick) {
	
	forceRollOver = (forceRollOver == null) ? this._forceRollOver : forceRollOver;
	
	// Check if the date is available for selection. Basically it is unless we are in
	// work week selection mode and <date> is not a working day
	//if (this._selectionMode == DwtCalendar.WORK_WEEK && !this._currWorkingDays[date.getDay()])
	//	return false;
	
	var newDate = new Date(date.getTime());
	var oldDate = this._date;

	var layout = false;
	var notify = false;
	var cellId;
	
	if (this._date2CellId != null) {
		var idx = (newDate.getFullYear() * 10000) + (newDate.getMonth() * 100) + newDate.getDate();
		var cellId = this._date2CellId[idx];
		
		if (cellId) {
		 	if (cellId == this._selectedCellId)
		 		notify = true;

			var cell = document.getElementById(cellId);
			if (cell._dayType == DwtCalendar._THIS_MONTH)
				notify = true;
			else if (forceRollOver)
				notify = layout = true;
			else
				notify = true;
		} else {
			 notify = layout = true;
		}
	} else {
		notify = layout = true;
	}
	
	// update before layout, notify after layout
	if (notify) {
		if (this._date){
			// 5/13/2005 EMC -- I'm not sure why this was setting the hours to 0.
			// I think it should respect what the user passed in, and only change
			// the parts of the date that it is responsible for.
			//newDate.setHours(0,0,0,0);
			newDate.setHours(this._date.getHours(), this._date.getMinutes(), this._date.getSeconds(), 0);
		}
		this._date = newDate;
		if (!layout && !this._readOnly) {
			this._setSelectedDate();
			this._setToday();
		}
	}
		
	if (layout)
		this._layout();

	if (notify && !skipNotify) {
		var type = dblClick ? DwtCalendar.DATE_DBL_CLICKED : DwtCalendar.DATE_SELECTED;
		this._notifyListeners(DwtEvent.SELECTION, type, this._date);
	}
		
	return true;
}

DwtCalendar.prototype.isSelected =
function(cellId) {
	/* if cellId is the selected day, then return true, else if we are NOT in day
	 * selection mode (i.e. week/work week) then compute the row and index of cellId and
	 * look it up in the week array to see if it is a selectable day */
	if (cellId == this._selectedDayElId) {
		return true;
	} else if (this._selectionMode != DwtCalendar.DAY) {
		/* If the cell is in the same row as the currently selected cell and it is
		 * a selectable day (i.e. a working day in the case of work week), then say it is
		 * selected */
		var cellIdx = this._getDayCellIndex(cellId);
		if (Math.floor(cellIdx / 7) == Math.floor(this._getDayCellIndex(this._selectedDayElId) / 7)
			&& this._currWorkingDays[cellIdx % 7])
			return true;
	}
	return false;
}

DwtCalendar.prototype.getForceRollOver =
function() {
	return this._forceRollOver;
}


DwtCalendar.prototype.setForceRollOver =
function(force) {
	if (force == null)
		return;
	
	if (this._forceRollOver != force){
		this._forceRollOver = force;
		this._layout();
	}
}

DwtCalendar.prototype.getSelectionMode =
function() {
	return this._selectionMode;
}

DwtCalendar.prototype.setSelectionMode =
function(selectionMode) {
	if (this._selectionMode == selectionMode)
		return;
	
	this._selectionMode = selectionMode;
	if (selectionMode == DwtCalendar.WEEK)
		this._currWorkingDays = DwtCalendar._FULL_WEEK;
	else if (selectionMode == DwtCalendar.WORK_WEEK)
		this._currWorkingDays = this._workingDays;
		
	this._layout();
}

/**
 * Sets the working week to workingDaysArray (references it). This function assumes that
 * workingDaysArray[0] = Sunday etc.
 */
DwtCalendar.prototype.setWorkingWeek =
function(workingDaysArray) {
	// TODO Should really create a copy of workingDaysArray
	this._workingDays = this._currWorkingDays = workingDaysArray;
	
	if (this._selectionMode == DwtCalendar.WORK_WEEK) {
		DBG.println("FOO!!!");
		this._layout();
	}
}


/**
 * Enables/disables the highlite (bolding) on the dates in <dates>.
 *
 * @param dates	Dates for which to enable/disable highliting
 * @param enable If true enable hiliting
 * @param clear Clear current highliting
 */
DwtCalendar.prototype.setHilite =
function(dates, enable, clear) {
	if (this._date2CellId == null)
		return;
		
	var cell;
	var aDate;
	if (clear) {
		for (aDate in this._date2CellId) {
			cell = document.getElementById(this._date2CellId[aDate]);
			if (cell._isHilited) {
				cell._isHilited = false;
				this._setClassName(cell, DwtCalendar._NORMAL);
			}	
		}
	}
	
	var cellId;
	for (var i in dates) {
		aDate = dates[i];
		cellId = this._date2CellId[aDate.getFullYear() * 10000 + aDate.getMonth() * 100 + aDate.getDate()];

		if (cellId) {
			cell = document.getElementById(cellId);
			if (cell._isHilited != enable) {
				cell._isHilited = enable;
				this._setClassName(cell, DwtCalendar._NORMAL);
			}
		}
	}
}


DwtCalendar.prototype.getDate =
function() {
	return this._date;
}

DwtCalendar.prototype.setFirstDayOfWeek =
function(firstDayOfWeek) {
	for (var i = 0; i < 7; i++) {
		if (i < firstDayOfWeek)
			this._weekDays[i] = 6 - (firstDayOfWeek -i - 1);
		else
			this._weekDays[i] = i - firstDayOfWeek;
		
		var dowCell = document.getElementById(this._getDOWCellId(i));
		dowCell.innerHTML = AjxDateUtil.WEEKDAY_SHORT[(firstDayOfWeek + i) % 7];
	}
	this._layout();
}

DwtCalendar.prototype.getDateRange =
function () {
	return this._range;
};

DwtCalendar.prototype._getDayCellId =
function(cellId) {
	return "c:" + cellId + ":" + this._uuid;
}

DwtCalendar.prototype._getDayCellIndex =
function(cellId) {
	return cellId.substring(2, cellId.indexOf(":", 3));
}

DwtCalendar.prototype._getDOWCellId =
function(cellId) {
	return "w:" + cellId + ":" + this._uuid;
}


DwtCalendar.prototype._getDaysInMonth =
function(mo, yr) {
	/* If we are not dealing with Feb, then simple lookup
	 * Leap year rules
	 *  1. Every year divisible by 4 is a leap year.
	 *  2. But every year divisible by 100 is NOT a leap year
	 *  3. Unless the year is also divisible by 400, then it is still a leap year.*/
	if (mo != 1)
		return DwtCalendar._DAYS_IN_MONTH[mo];
	else if (yr % 4 != 0 || (yr % 100 == 0 && yr % 400 != 0))
		return 28;
	else
		return 29;
}

DwtCalendar.prototype._installListeners =
function() {
	this._setMouseEventHdlrs();
	this.addListener(DwtEvent.ONMOUSEOVER, new AjxListener(this, this._mouseOverListener));
	this.addListener(DwtEvent.ONMOUSEOUT, new AjxListener(this, this._mouseOutListener));
	this.addListener(DwtEvent.ONMOUSEDOWN, new AjxListener(this, this._mouseDownListener));
	this.addListener(DwtEvent.ONMOUSEUP, new AjxListener(this, this._mouseUpListener));
	this.addListener(DwtEvent.ONDBLCLICK, new AjxListener(this, this._doubleClickListener));
}

DwtCalendar.prototype._notifyListeners =
function(eventType, type, detail, ev) {
	if (!this.isListenerRegistered(eventType))
		return;
	var selEv = DwtShell.selectionEvent;
	if (ev)
		DwtUiEvent.copy(selEv, ev);
	else 
		selEv.reset();
	selEv.item = this;
	selEv.detail = detail;
	selEv.type = type;
	this.notifyListeners(eventType, selEv);
}

DwtCalendar.prototype._layout =
function() {
	if (this._date == null) 
		return false;

	if (!this._calWidgetInited)
		this._init();
		
	var date = new Date(this._date.getTime());
	date.setDate(1);
	var year = date.getFullYear();
	var month  = date.getMonth();
	var firstDay = date.getDay();
	var daysInMonth = this._getDaysInMonth(month, year);
	var day = 1;
	var nextMoDay = 1;

	this._date2CellId = new Object();
	this._selectedDayElId = null;
		
	// Figure out how many days from the previous month we have to fill in (see comment below)
	if (!this._hidePrevNextMo) {
	    if (month != 0) {
	    	var lastMoDay = this._getDaysInMonth(month - 1, year) - this._weekDays[firstDay] + 1;
	    	var lastMoYear = year;
	    	var lastMoMonth = month - 1;
	    	if (month != 11) {
	     		var nextMoMonth = month + 1;
	    		var nextMoYear = year;
	    	} else {
	      		var nextMoMonth = 0;
	    		var nextMoYear = year + 1;
	    	}
	     } else {
	     	var lastMoDay = this._getDaysInMonth(11, year - 1) - this._weekDays[firstDay] + 1;
	     	var lastMoYear = year - 1;
	     	var lastMoMonth = 11
	     	var nextMoMonth = 1;
	     	var nextMoYear = year;
	    }
	}

	for (var i = 0; i < 6; i++) {
    	for (var j = 0; j < 7; j++) {
 	   		var dayCell = document.getElementById(this._getDayCellId(i * 7 + j));
 	   		
 	   		if (dayCell._isHilited == null)
 	   			dayCell._isHilited = false;
 	   			
    		if (day <= daysInMonth) {
    			/* The following if statement deals with the first day of this month not being
    			 * the first day of the week. In this case we must fill the preceding days with
    			 * the final days of the previous month */
     			if (i != 0 || j >= this._weekDays[firstDay]) {
    				this._date2CellId[(year * 10000) + (month * 100) + day] = dayCell.id;
    				dayCell._day = day;
   					dayCell._month = month
    			 	dayCell._year = year;
     				dayCell.innerHTML = day++;
    				//dayCell.className = this._origDayClassName;
    				dayCell._dayType = DwtCalendar._THIS_MONTH;
    				if (this._readOnly) {
    					dayCell.style.fontFamily = "Arial";
    					dayCell.style.fontSize = "10px";
    				}
    			} else {
    				if (this._hidePrevNextMo) {
    					dayCell.innerHTML = "";
    				} else {
	    				this._date2CellId[(lastMoYear * 10000) + (lastMoMonth * 100) + lastMoDay] = dayCell.id;
	    				dayCell._day = lastMoDay;
	    				dayCell._month = lastMoMonth
	    			 	dayCell._year = lastMoYear;
						dayCell.innerHTML = lastMoDay++;
						//dayCell.className = this._origDayClassName + " " + this._greyClassName;
						dayCell._dayType = DwtCalendar._PREV_MONTH;		
					}
				}
			} else if (!this._hidePrevNextMo) {
				/* Fill any remaining slots with days from next month */
    			this._date2CellId[(nextMoYear * 10000) + (nextMoMonth * 100) + nextMoDay] = dayCell.id;
    			dayCell._day = nextMoDay;
    			dayCell._month = nextMoMonth
    			dayCell._year = nextMoYear;
				dayCell.innerHTML = nextMoDay++;
				dayCell._dayType = DwtCalendar._NEXT_MONTH;
				//dayCell.className = this._origDayClassName + " " + this._greyClassName;
			}
			this._setClassName(dayCell, DwtCalendar._NORMAL);
     	}
    }
    
	this._setTitle(month, year);
	
	// Compute the currently selected day
	//this._selectedDayElId = null;
	if (!this._readOnly) {
		this._setSelectedDate();
		this._setToday();
	}
	
	this._setRange();
}

DwtCalendar.prototype._setRange =
function() {
	
	var cell = document.getElementById(this._getDayCellId(0));
	var start = new Date(cell._year, cell._month, cell._day, 0, 0, 0, 0);

	cell = document.getElementById(this._getDayCellId(DwtCalendar._LAST_DAY_CELL_IDX));
	
	var daysInMo = this._getDaysInMonth(cell._month, cell._year);
	var end;
	if (cell._day < daysInMo)
		end = new Date(cell._year, cell._month, cell._day + 1, 0, 0, 0, 0);
	else if (cell._month < 11)
		end = new Date(cell._year, cell._month + 1, 1, 0, 0, 0, 0);
	else
		end = new Date(cell._year + 1, 0, 1, 0, 0, 0, 0);
	
	if (this._range == null)
		this._range = new Object();
	else if (this._range.start.getTime() == start.getTime() && this._range.end.getTime() == end.getTime())
		return false;
	
	this._range.start = start;
	this._range.end = end;
	
	// Notify any listeners
	if (!this.isListenerRegistered(DwtEvent.DATE_RANGE))
		return;
		
	if (!this._dateRangeEvent)
		this._dateRangeEvent = new DwtDateRangeEvent(true);
		
	this._dateRangeEvent.item = this;
	this._dateRangeEvent.start = start;
	this._dateRangeEvent.end = end;
	this.notifyListeners(DwtEvent.DATE_RANGE, this._dateRangeEvent);
}

DwtCalendar.prototype._setToday =
function() {
	var cell;
	var today = new Date();
	var todayDay = today.getDate();
	
	if (!this._todayDay || this._todayDay != todayDay) {
		if (this._todayCellId != null) {
			cell = document.getElementById(this._todayCellId);
			cell._isToday = false;
			this._setClassName(cell, DwtCalendar._NORMAL);
		}
		
		this._todayCellId = this._date2CellId[(today.getFullYear() * 10000) + (today.getMonth() * 100) + todayDay];
		if (this._todayCellId != null) {
			cell = document.getElementById(this._todayCellId);
			cell._isToday = true;
			this._setClassName(cell, DwtCalendar._NORMAL);
		}
	}
}

DwtCalendar.prototype._setSelectedDate =
function() {
	var day = this._date.getDate();
	var month = this._date.getMonth();
	var year = this._date.getFullYear();
	var cell;
	
	if (this._selectedDayElId) {
		cell = document.getElementById(this._selectedDayElId);
		this._setClassName(cell, DwtCalendar._DESELECTED);
	}	
	
	var cellId = this._date2CellId[(year * 10000) + (month * 100) + day];
	cell = document.getElementById(cellId);
	this._selectedDayElId = cellId;
	this._setClassName(cell, DwtCalendar._SELECTED);
}

DwtCalendar.prototype._setCellClassName = 
function(cell, className, mode) {
	if (cell._dayType != DwtCalendar._THIS_MONTH)
		className += this._greyClassName;
					
	if (this._selectionMode == DwtCalendar.DAY && cell.id == this._selectedDayElId
		&& mode != DwtCalendar._DESELECTED) {
			className += this._selectedDayClassName;
	} else if (this._selectionMode != DwtCalendar.DAY && mode != DwtCalendar._DESELECTED &&
			   this._selectedDayElId != null) {
		var idx = this._getDayCellIndex(cell.id);
		if (Math.floor(this._getDayCellIndex(this._selectedDayElId) / 7) == Math.floor(idx / 7)
			&& this._currWorkingDays[idx % 7])
			className += this._selectedDayClassName;
	}
	
	if (cell._isHilited)
		className += this._hiliteClassName;	
			
	if (cell._isToday)
		className += this._todayClassName;

	return className;
}

DwtCalendar.prototype._setClassName = 
function(cell, mode) {
	var className = "";
	
	if (mode == DwtCalendar._NORMAL) {
		className = this._origDayClassName;
	} else if (mode == DwtCalendar._ACTIVATED) {
		className = this._activatedDayClassName;
	} else if (mode == DwtCalendar._TRIGGERED) {
		className = this._triggeredDayClassName;
	} else if (this._selectionMode != DwtCalendar.DAY
			   && (mode == DwtCalendar._SELECTED || mode == DwtCalendar._DESELECTED)) {
		/* If we are not in day mode, then we need to highlite multiple cells e.g. the whole
		 * week if we are in week mode */
		var firstCellIdx = Math.floor(this._getDayCellIndex(this._selectedDayElId) / 7) * 7;

		for (var i = 0; i < 7; i++) {
			className = this._origDayClassName;
			var aCell = document.getElementById(this._getDayCellId(firstCellIdx++));
			aCell.className = this._setCellClassName(aCell, className, mode);
		}
		return;
	}

	cell.className = this._setCellClassName(cell, className, mode);
}

DwtCalendar.prototype._setTitle =
function(month, year) {
	var cell = document.getElementById(this._monthCell);
	var formatter = DwtCalendar.getMonthFormatter();
	var date = new Date(year, month);
	cell.innerHTML = formatter.format(date);
}

DwtCalendar.prototype._init =
function() {
	var html = new Array(100);
	var idx = 0;
	this._monthCell = "t:" + this._uuid;
	
	// Construct the header row with the prev/next year and prev/next month icons as well as the 
	// month/year title cell
	html[idx++] = "<table width=100% cellspacing='0' cellpadding='0' style='border-collapse:collapse;'>";
	html[idx++] = 		"<tr><td class=DwtCalendarTitlebar>"; 
	html[idx++] = 			"<table width='100%' cellspacing='0' cellpadding='0'>";
	html[idx++] = 				"<tr>";
	html[idx++] = 	             	"<td class='";
	html[idx++] = 	             		DwtCalendar._BUTTON_CLASS;
	html[idx++] = 	             		"' id='b:py:";
	html[idx++] = 	             		this._uuid;
	html[idx++] = 					    "'>";
	html[idx++] = 					    AjxImg.getImageHtml("FastRevArrowSmall", null, ["id='b:py:img:", this._uuid, "'"].join(""));
	html[idx++] = 					"</td>"
	html[idx++] = 	             	"<td class='";
	html[idx++] = 	             		DwtCalendar._BUTTON_CLASS;
	html[idx++] = 	             		"' id='b:pm:";
	html[idx++] = 						this._uuid;
	html[idx++] = 						"'>";
	html[idx++] = 					    AjxImg.getImageHtml("RevArrowSmall", null, ["id='b:pm:img:", this._uuid, "'"].join(""));
	html[idx++] =					"</td>";
	html[idx++] = 					"<td align='center' class='DwtCalendarTitleCell' nowrap'><span class='"
	html[idx++] =                       DwtCalendar._TITLE_CLASS;
	html[idx++] = 					    "' id='";
	html[idx++] =						this._monthCell;
	html[idx++] =					"'>&nbsp;</span></td>";	              
	html[idx++] = 	             	"<td class='";
	html[idx++] = 	             		DwtCalendar._BUTTON_CLASS;
	html[idx++] = 	             		"' id='b:nm:";
	html[idx++] =						this._uuid;
	html[idx++] =						"'>";
	html[idx++] = 					    AjxImg.getImageHtml("FwdArrowSmall", null, ["id='b:nm:img:", this._uuid, "'"].join(""));
	html[idx++] =					"</td>";
	html[idx++] = 	             	"<td class='";
	html[idx++] = 	             		DwtCalendar._BUTTON_CLASS;
	html[idx++] = 	             		"' id='b:ny:";
	html[idx++] =						this._uuid;
	html[idx++] =						"'>";
	html[idx++] = 					    AjxImg.getImageHtml("FastFwdArrowSmall", null, ["id='b:ny:img:", this._uuid, "'"].join(""));
	html[idx++] =					"</td>";
 	html[idx++] = 				"</tr>";
	html[idx++] = 			"</table>";
	html[idx++] = 		"</td></tr>";

	html[idx++] = "<tr><td>";
	
	html[idx++] = "<table cellspacing='0' cellpadding='1' width='100%'>";
	
	html[idx++] = "<tr><td width='2%'></td>";
	for (var i = 0; i < 7; i++) {
		html[idx++] = "<td align='right' class='DwtCalendarDow' width='14%' id='";
		html[idx++] = this._getDOWCellId(i);
		html[idx++] = "'>&nbsp;</td>";
	}
    html[idx++] = "</tr>";

	// bug fix #3355
	var style = AjxEnv.isLinux ? " style='line-height: 12px'" : "";
    for (var i = 0; i < 6; i++) {
 		html[idx++] = "<tr" + style + "><td width='2%' id='w:";
 		html[idx++] = i;
 		html[idx++] = ":"; 
 		html[idx++] = this._uuid; 
 		html[idx++] = "'</td>";
    	for (var j = 0; j < 7; j++) {
    		html[idx++] = "<td align='right' width='14%' id='";
    		html[idx++] = this._getDayCellId(i * 7 + j);
    		html[idx++] = "'>&nbsp;</td>";
     	}
    	html[idx++] ="</tr>";
    }

    html[idx++] = "</td></tr></table></table>";
    
    this.getHtmlElement().innerHTML = html.join("");
    if (!this._readOnly) {
    	document.getElementById("b:py:img:" + this._uuid)._origClassName = AjxImg.getClassForImage("FastRevArrowSmall");
	    document.getElementById("b:pm:img:" + this._uuid)._origClassName = AjxImg.getClassForImage("RevArrowSmall");
	    document.getElementById("b:nm:img:" + this._uuid)._origClassName = AjxImg.getClassForImage("FwdArrowSmall");
	    document.getElementById("b:ny:img:" + this._uuid)._origClassName = AjxImg.getClassForImage("FastFwdArrowSmall");
    }

    this._calWidgetInited = true;
}

DwtCalendar.prototype.setMouseOverDayCallback =
function(callback) {
	this._mouseOverDayCB = callback;
}

/**
 * This method will return the date value for the last cell that the most recent Dnd operation occured over.
 * Typically it will be called by a DwtDropTarget listener when an item is dropped onto the mini calendar
 */
DwtCalendar.prototype.getDndDate =
function() {
	var dayCell = this._lastDndCell;
	if (dayCell) {
		return new Date(dayCell._year, dayCell._month, dayCell._day);
	} else {
		return null;
	}
}

// Temp date used for callback in mouseOverListener
DwtCalendar._tmpDate = new Date();
DwtCalendar._tmpDate.setHours(0, 0, 0, 0);

DwtCalendar.prototype._mouseOverListener = 
function(ev) {
	var target = ev.target;
	if (target.id.charAt(0) == 'c') {
		this._setClassName(target, DwtCalendar._ACTIVATED);
		/* If a mouse over callback has been registered, then call it to give it chance
		 * do work like setting the tooltip content */
		if (this._mouseOverDayCB) {
			DwtCalendar._tmpDate.setFullYear(target._year, target._month, target._day);
			this._mouseOverDayCB.run(this, DwtCalendar._tmpDate);
		}
	} else if (target.id.charAt(0) == 't') {
		// Dont activate title for now
		return;
		target.className = DwtCssStyle.ACTIVATED;
	} else if (target.id.charAt(0) == 'b') {
		var img;
		if (target.firstChild == null) {
			img = target;
			AjxImg.getParentElement(target).className = DwtCalendar._BUTTON_ACTIVATED_CLASS;
		} else {
			target.className = DwtCalendar._BUTTON_ACTIVATED_CLASS;
			img = AjxImg.getImageElement(target);
		}
		img.className = img._origClassName;
	} else if (target.id.charAt(0) == 'w') {
	}

	ev._stopPropagation = true;
}


DwtCalendar.prototype._mouseOutListener = 
function(ev) {
	this.setToolTipContent(null);
	var target = ev.target;
	if (target.id.charAt(0) == 'c') {
		this._setClassName(target, DwtCalendar._NORMAL);
	} else if (target.id.charAt(0) == 't') {
		// Dont deactivate title for now
		return;
		target.className = DwtCalendar._TITLE_CLASS;
	} else if (target.id.charAt(0) == 'b') {
		var img;
		target.className = DwtCalendar._BUTTON_CLASS;
		if (target.firstChild == null) {
			img = target;
			AjxImg.getParentElement(target).className = DwtCalendar._BUTTON_CLASS;
		} else {
			target.className = DwtCalendar._BUTTON_CLASS;
			img = AjxImg.getImageElement(target);
		}
		img.className = 	img._origClassName;
	} else if (target.id.charAt(0) == 'w') {
	}
}


DwtCalendar.prototype._mouseDownListener = 
function(ev) {	
	if (ev.button == DwtMouseEvent.LEFT) {
		var target = ev.target;
		if (target.id.charAt(0) == 'c') {
			this._setClassName(target, DwtCalendar._TRIGGERED);
		} else if (target.id.charAt(0) == 't') {
			target.className = DwtCalendar._TITLE_TRIGGERED_CLASS;
		} else if (target.id.charAt(0) == 'b') {
			var img;
			if (target.firstChild == null) {
				img = target;
				AjxImg.getParentElement(target).className = DwtCalendar._BUTTON_TRIGGERED_CLASS;
			} else {
				target.className = DwtCalendar._BUTTON_TRIGGERED_CLASS;
				img = AjxImg.getImageElement(target);
			}
			img.className = img._origClassName;
		} else if (target.id.charAt(0) == 'w') {
		}
	}
}

DwtCalendar.prototype._mouseUpListener = 
function(ev) {
	var target = ev.target;
	if (ev.button == DwtMouseEvent.LEFT) {
		if (target.id.charAt(0) == 'c') {
			// If our parent is a menu then we need to have it close
			if (this.parent instanceof DwtMenu)
				DwtMenu.closeActiveMenu();
					
			if (this.setDate(new Date(target._year, target._month, target._day)))
				return;
			this._setClassName(target, DwtCalendar._ACTIVATED);
		} else if (target.id.charAt(0) == 'b') {
			var img;
			if (target.firstChild == null) {
				img = target;
				AjxImg.getParentElement(target).className = DwtCalendar._BUTTON_ACTIVATED_CLASS;
			} else {
				target.className = DwtCalendar._BUTTON_ACTIVATED_CLASS;
				img = AjxImg.getImageElement(target);
			}
			img.className = img._origClassName;
			
			if (img.id.indexOf("py") != -1)
				this._prevYear();
			else if (img.id.indexOf("pm") != -1) 
				this._prevMonth();
			else if (img.id.indexOf("nm") != -1)
				this._nextMonth();
			else 
				this._nextYear();		
		} else if (target.id.charAt(0) == 't') {
			// TODO POPUP MENU
			target.className = DwtCalendar._TITLE_ACTIVATED_CLASS;
			this.setDate(new Date(), this._skipNotifyOnPage);
			// If our parent is a menu then we need to have it close
			if (this.parent instanceof DwtMenu)
				DwtMenu.closeActiveMenu();		
		}
	} else if (ev.button == DwtMouseEvent.RIGHT && target.id.charAt(0) == 'c') {					
		this._notifyListeners(DwtEvent.ACTION, 0, new Date(target._year, target._month, target._day), ev);
	}
}


DwtCalendar.prototype._doubleClickListener =
function(ev) {
	var target = ev.target;
	if (this._selectionEvent)
		this._selectionEvent.type = DwtCalendar.DATE_DBL_CLICKED;
	if (target.id.charAt(0) == 'c') {
		// If our parent is a menu then we need to have it close
		if (this.parent instanceof DwtMenu)
			DwtMenu.closeActiveMenu();
				
		this.setDate(new Date(target._year, target._month, target._day), false, false, true)
	}
}

DwtCalendar.prototype._prevMonth = 
function(ev) {
	var d = new Date(this._date.getTime());
	this.setDate(AjxDateUtil.roll(d, AjxDateUtil.MONTH, -1), this._skipNotifyOnPage);
}

DwtCalendar.prototype._nextMonth = 
function(ev) {
	var d = new Date(this._date.getTime());
	this.setDate(AjxDateUtil.roll(d, AjxDateUtil.MONTH, 1), this._skipNotifyOnPage);
}

DwtCalendar.prototype._prevYear = 
function(ev) {
	var d = new Date(this._date.getTime());
	this.setDate(AjxDateUtil.roll(d, AjxDateUtil.YEAR, -1), this._skipNotifyOnPage);
}

DwtCalendar.prototype._nextYear = 
function(ev) {
	var d = new Date(this._date.getTime());
	this.setDate(AjxDateUtil.roll(d, AjxDateUtil.YEAR, 1), this._skipNotifyOnPage);
}

DwtCalendar.getDateFormatter = function() {
	if (!DwtCalendar._dateFormatter) {
		DwtCalendar._dateFormatter = new AjxDateFormat(AjxMsg.formatCalDate);
	}
	return DwtCalendar._dateFormatter;
};
DwtCalendar.getDateLongFormatter = function() {
	if (!DwtCalendar._dateLongFormatter) {
		DwtCalendar._dateLongFormatter = new AjxDateFormat(AjxMsg.formatCalDateLong);
	}
	return DwtCalendar._dateLongFormatter;
};
DwtCalendar.getDateFullFormatter = function() {
	if (!DwtCalendar._dateFullFormatter) {
		DwtCalendar._dateFullFormatter = new AjxDateFormat(AjxMsg.formatCalDateFull);
	}
	return DwtCalendar._dateFullFormatter;
};
DwtCalendar.getDayFormatter = function() {
	if (!DwtCalendar._dayFormatter) {
		DwtCalendar._dayFormatter = new AjxDateFormat(AjxMsg.formatCalDay);
	}
	return DwtCalendar._dayFormatter;
};
DwtCalendar.getMonthFormatter = function() {
	if (!DwtCalendar._monthFormatter) {
		DwtCalendar._monthFormatter = new AjxDateFormat(AjxMsg.formatCalMonth);
	}
	return DwtCalendar._monthFormatter;
};

DwtCalendar.prototype._dragEnter =
function(ev) {
}

DwtCalendar.prototype._dragHover =
function(ev) {
}

DwtCalendar.prototype._dragOver =
function(ev) {
	var target = ev.target;
	if (target.id.charAt(0) == 'c') {
		this._setClassName(target, DwtCalendar._ACTIVATED);
		this._lastDndCell = target;
	} else {
		this._lastDndCell = null;
	}
}

DwtCalendar.prototype._dragLeave =
function(ev) {
}

/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* @class
* @constructor
* DwtPropertyPage abstract class for a property page (view)
* It provides ability to keep track of any changes in the form fields on the page
* @author Greg Solovyev
**/

function DwtPropertyPage(parent, className, positionType) {
	if (arguments.length == 0) return;
	var clsName = className || "DwtPropertyPage";
	DwtComposite.call(this, parent, className, positionType);
	this._fieldIds = new Object();
	this._fildDivIds = new Object();
	this._isDirty = false;
}

DwtPropertyPage.prototype = new DwtComposite;
DwtPropertyPage.prototype.constructor = DwtPropertyPage;

DwtPropertyPage.prototype.toString = 
function() {
	return "DwtPropertyPage";
}

/**
* @param boolean
* sets the value of _isDirty flag
**/
DwtPropertyPage.prototype.setDirty = 
function (isD) {
	this._isDirty = isD;
}

/**
* @ return boolean _isDirty flag
* isDirty indicates whether the user changed any data on the page after the page was initialized
**/
DwtPropertyPage.prototype.isDirty = 
function () {
	return this._isDirty;
}

/**
* @param field either key to the field ID in the _fieldIds or reference to the field
**/
DwtPropertyPage.prototype._installOnKeyUpHandler = 
function(field, func) {
	if (!field)	return;
	
	var e = null;
	e = document.getElementById(this._fieldIds[field]);
	if (e) {
		Dwt.setHandler(e, DwtEvent.ONKEYUP, func ? func : this._onKeyUp);
		e._view = this;
		e._field = field;
	}
}

/**
* @param field either key to the field ID in the _fieldIds or reference to the field
**/
DwtPropertyPage.prototype._installOnClickHandler = 
function(field, func) {
	if (!field) return;
	
	var e = document.getElementById(this._fieldIds[field]);
	if (e) {
		Dwt.setHandler(e, DwtEvent.ONCLICK, func ? func : this._onClick);
		e._view = this;
		e._field = field;
	}
}

DwtPropertyPage.prototype._onClick =
function(ev) {
	this._view.setDirty(true);
	return true;
}

DwtPropertyPage.prototype._onKeyUp =
function(ev) {
	this._view.setDirty(true);
	return true;
}

/**
* @param field either key to the field ID in the _fieldIds or reference to the field
**/
DwtPropertyPage.prototype._installOnChangeHandler = 
function(field, func) {
	if (!field) return;
	
	var e = null;
	e = document.getElementById(this._fieldIds[field]);
	if(e) {
		Dwt.setHandler(e, DwtEvent.ONCHANGE, func ? func : this._onChange);
		e._view = this;
		e._field = field;
	}
}

DwtPropertyPage._onChange =
function(ev) {
	this._view.setDirty(true);
	return true;
}

DwtPropertyPage.prototype._onChange2 =
function(ev) {
	this.setDirty(true);
	return true;
}

DwtPropertyPage.prototype._addDwtSelectEntryRow =
function(field, title, html, idx, titleSize) {
	var tSize = "30ex";
	if(titleSize)
		tSize = titleSize;
		
	html[idx++] = "<tr valign='center'>";
	idx = this._addDwtSelectEntryCell(field, title, html, idx, tSize);
	html[idx++] = "</tr>";
	return idx;
}

DwtPropertyPage.prototype._addDwtSelectEntryCell =
function(field, title, html, idx, titleWidth) {
	var id = Dwt.getNextId();
	this._fieldIds[field] = id;
	if(title) {
		html[idx++] = "<td align='left' style='width:" + titleWidth + "'>";
		html[idx++] = AjxStringUtil.htmlEncode(title) + ":";
		html[idx++] = "</td>";
	}
	html[idx++] = "<td align='left'>";
	html[idx++] = "<div id='" + id + "'></div></td>";
	return idx;
}

DwtPropertyPage.prototype._addBoolEntryRow =
function(field, title, html, idx, titleWidth) {
	html[idx++] = "<tr valign='center'>";
	idx = this._addBoolEntryCell(field, title, html, idx, titleWidth);
	html[idx++] = "</tr>";
	return idx;
}

DwtPropertyPage.prototype._addBoolEntryCell =
function(field, title, html, idx, titleWidth) {
	var id = Dwt.getNextId();
	this._fieldIds[field] = id;
	var tWidth = "20ex";
	if(titleWidth)
		tWidth = titleWidth;	
		
	if(title) {
		html[idx++] = "<td style='width:" + tWidth + ";' align='left'>";
		html[idx++] = AjxStringUtil.htmlEncode(title) + ":";
		html[idx++] = "</td>";
	}
	html[idx++] = "<td align='left'>";
	html[idx++] = "<input type='checkbox' id='"+id+"'>";
	html[idx++] = "</td>";
	return idx;
}

DwtPropertyPage.prototype._addTextAreaEntryRow =
function(field, title, html, idx, noWrap) {
	var myWrap = "on";
	if(noWrap)
		myWrap = "off";
		
	var id = Dwt.getNextId();
	this._fieldIds[field] = id;
	html[idx++] = "<tr valign='center'>";
	html[idx++] = "<td align='left' style='width:60ex;'>";
	html[idx++] = AjxStringUtil.htmlEncode(title) + ":";
	html[idx++] = "</td></tr>";
	html[idx++] = "<tr valign='center'><td align='left' style='width:60ex;'><textarea wrap='" + myWrap + "' rows='8' cols ='60' id='";	
	html[idx++] = id;
	html[idx++] = "'/></textarea></td></tr>";
	return idx;
}

/**
* _addEntryRow
*	@param field - key of the field id in this._fieldIds
*	@param title - title string. If title is specified a separate cell will be appended before the form field
* title will be rendered within that cell
*	@param html - reference to html array
*	@param idx - current counter inside the html array
*	@param type - type of the form field to create (<input type= )
*	@param fldsize - size of the input field (this value will be assigned to the size property
*	@param tailTitle - string that will be placed behind the form field
*	@param titleWidth - width of the title cell
**/
DwtPropertyPage.prototype._addEntryRow =
function(field, title, html, idx, type, fldsize, tailTitle, titleWidth, withAsteric) {
	html[idx++] = "<tr valign='center'>";
	idx = this._addEntryCell(field, title, html, idx, type, fldsize, tailTitle, titleWidth, withAsteric);
	html[idx++] = "</tr>";
	return idx;
}

/**
* _addEntryCell
*	@param field - key of the field id in this._fieldIds
*	@param title - title string. If title is specified a separate cell will be appended before the form field
* title will be rendered within that cell
*	@param html - reference to html array
*	@param idx - current counter inside the html array
*	@param type - type of the form field to create (<input type= )
*	@param fldsize - size of the input field (this value will be assigned to the size property
*	@param tailTitle - string that will be placed behind the form field
*	@param titleWidth - width of the title cell
**/
DwtPropertyPage.prototype._addEntryCell =
function(field, title, html, idx, type, fldsize, tailTitle, titleWidth, withAsteric) {
	if (type == null) type = "text";
	if(fldsize == null) fldsize = 35;
	var tWidth = "20ex";
	if(titleWidth) 
		tWidth = titleWidth;
		
	var id = Dwt.getNextId();
	this._fieldIds[field] = id;
	if(title) {
		html[idx++] = "<td align='left' style='width:" + tWidth + ";'>";
		html[idx++] = AjxStringUtil.htmlEncode(title) + ":";
		html[idx++] = "</td>";
	}
	html[idx++] = "<td ";
	if(withAsteric) {
		html[idx++] = "class='redAsteric' ";		
	}
	html[idx++] = "	align='left'><input autocomplete='off' size='"+fldsize+"' type='"+type+"' id='";	
	html[idx++] = id;
	html[idx++] = "'";
	if(withAsteric) {
		html[idx++] = "/>*";		
	} else {
		html[idx++] = "/>&nbsp;";
	}
	if(tailTitle != null) {
		html[idx++]	= tailTitle;
	}
	html[idx++] = "</td>";
	return idx;
}
/**
* Use this method to render HTML form
* call all other rendering methods from this method.
**/
DwtPropertyPage.prototype._createHTML = 
function () {
 //abstract method
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* @class
* @constructor
* DwtTabView  - class for the tabbed view
* DwtTabView manages the z-index of the contained tabs. 
* @author Greg Solovyev
**/
function DwtTabView(parent, className, positionStyle) {
	if (arguments.length == 0) return;
	var clsName = className || "DwtTabView";
	
	var posStyle = DwtControl.ABSOLUTE_STYLE;
	if ((positionStyle !== void 0) && (positionStyle !== null)){
	    posStyle = positionStyle;
	}
	DwtComposite.call(this, parent, clsName, posStyle);
	this._stateChangeEv = new DwtEvent(true);
	this._tabs = new Array(); 
	this._tabIx = 1;
	this._pageDiv = document.createElement("div");
	this._pageDiv.className = clsName;
	this._pageDiv.style.position = DwtControl.STATIC_STYLE;
	this._tabBar = new DwtTabBar(this);
	this._createHTML();
}

DwtTabView.prototype = new DwtComposite;
DwtTabView.prototype.constructor = DwtTabView;

DwtTabView.prototype.toString = 
function() {
	return "DwtTabView";
}

//Z-index contants for the tabbed view contents are based on Dwt z-index constants
DwtTabView.Z_ACTIVE_TAB = Dwt.Z_VIEW+10;
DwtTabView.Z_HIDDEN_TAB = Dwt.Z_HIDDEN;
DwtTabView.Z_TAB_PANEL = Dwt.Z_VIEW+20;
DwtTabView.Z_CURTAIN = Dwt.Z_CURTAIN;

//public methods

DwtTabView.prototype.addStateChangeListener = function(listener) {
	this._eventMgr.addListener(DwtEvent.STATE_CHANGE, listener);
}

DwtTabView.prototype.removeStateChangeListener = function(listener) {
	this._eventMgr.removeListener(DwtEvent.STATE_CHANGE, listener);
}

/**
* @param title  -  text for the tab button
* @param tabView - instance of DwtTabViewPage 
* @return - the key for the added tab. This key can be used to retreive the tab using @link getTab
* public method addTab. Note that this method does not automatically update the tabs panel.
**/
DwtTabView.prototype.addTab =
function (title, tabView) {
	var tabKey = this._tabIx++;	
	this._tabs[tabKey] = new Object();
	this._tabs[tabKey]["title"] = title;

	//add the button to the tab bar
	this._tabs[tabKey]["button"] = this._tabBar.addButton(tabKey, title);
	//add the page 
	if(tabView) {
		this._tabs[tabKey]["view"] = tabView;
		this._pageDiv.appendChild(this._tabs[tabKey]["view"].getHtmlElement());
		tabView._tabKey = tabKey;
	} else {
		this._tabs[tabKey]["view"] = null;
	}		
	
	if(tabKey==1) { //show the first tab 
		if(this._tabs[tabKey]["view"])
			this._tabs[tabKey]["view"].showMe();
		this._currentTabKey = tabKey;		
		this.switchToTab(tabKey);
	} else {
		//hide all the other tabs
		if(this._tabs[tabKey]["view"]) {		
			this._tabs[tabKey]["view"].hideMe();
			Dwt.setVisible(this._tabs[tabKey]["view"].getHtmlElement(), false);
		}			
	}
	
	this._tabBar.addSelectionListener(tabKey, new AjxListener(this, DwtTabView.prototype._tabButtonListener));	
		
	return tabKey;
}

DwtTabView.prototype.getCurrentTab = function() {
	return this._currentTabKey;
}

/**
* @param tabKey  -  key for the tab, returned from @link addTab
* @return - the view tab (DwtTabViewpage) 
**/
DwtTabView.prototype.getTab =
function (tabKey) {
	if(this._tabs && this._tabs[tabKey])
		return this._tabs[tabKey];
	else
		return null;
}

DwtTabView.prototype.getTabTitle =
function(tabKey) {
	return this._tabs && this._tabs[tabKey] ? this._tabs[tabKey]["title"] : null;
};
DwtTabView.prototype.getTabButton =
function(tabKey) {
	return this._tabs && this._tabs[tabKey] ? this._tabs[tabKey]["button"] : null;
};
DwtTabView.prototype.getTabView =
function(tabKey) {
	return this._tabs && this._tabs[tabKey] ? this._tabs[tabKey]["view"] : null;
};

DwtTabView.prototype.switchToTab = 
function(tabKey) {
	if(this._tabs && this._tabs[tabKey]) {
		this._showTab(tabKey);
		this._tabBar.openTab(tabKey);
	}
	if (this._eventMgr.isListenerRegistered(DwtEvent.STATE_CHANGE)) {
		this._eventMgr.notifyListeners(DwtEvent.STATE_CHANGE, this._stateChangeEv);
	}
}

DwtTabView.prototype.setBounds =
function(x, y, width, height) {
	DwtComposite.prototype.setBounds.call(this, x, y, width, height);
	this._resetTabSizes(width, height);
}

DwtTabView.prototype.getActiveView =
function() {
	return this._tabs[this._currentTabKey].view;
}

//protected methods

DwtTabView.prototype._resetTabSizes = 
function (width, height) {
    var tabBarSize = this._tabBar.getSize();
	var tabBarHeight = tabBarSize.y || this._tabBar.getHtmlElement().clientHeight;

	var tabWidth = width;
	var tabHeight = height - tabBarHeight;
	
	if(this._tabs && this._tabs.length) {
		for(var curTabKey in this._tabs) {
			if(this._tabs[curTabKey]["view"]) {
				this._tabs[curTabKey]["view"].resetSize(width, height);
			}	
		}
	}		
}

/**
* method createHTML 
**/
DwtTabView.prototype._createHTML =
function () {
	this._table = document.createElement("table");
	this.getHtmlElement().appendChild(this._table);
	this._table.width = "100%";
	this._table.border = this._table.cellPadding = this._table.cellSpacing = 0;
	this._table.backgroundColor = DwtCssStyle.getProperty(this.parent.getHtmlElement(), "background-color");
	
	var row1 = this._table.insertRow(-1);
	row1.align = "left";
	row1.vAlign = "middle";
	
	var col1 = row1.insertCell(-1);
	col1.align = "left";
	col1.vAlign = "middle";
	col1.noWrap = true;	
	col1.width="100%";
	col1.className="DwtTabTable";
	col1.appendChild(this._tabBar.getHtmlElement());

	var row2 = this._table.insertRow(-1);
	row2.align = "left";
	row2.vAlign = "middle";
	
	var col2 = row2.insertCell(-1);
	col2.align = "left";
	col2.vAlign = "middle";
	col2.noWrap = true;	
	col2.appendChild(this._pageDiv);
}

/**
* Override addChild method. We need internal control over layout of the children in this class.
* Child elements are added to this control in the _createHTML method.
* @param child
**/
DwtTabView.prototype.addChild =
function(child) {
	this._children.add(child);
}

DwtTabView.prototype._showTab = 
function(tabKey) {
	if(this._tabs && this._tabs[tabKey]) {
		this._currentTabKey = tabKey;
		//hide all the tabs
		this._hideAllTabs();
		//make this tab visible
		if(this._tabs[tabKey]["view"]) {
			Dwt.setVisible(this._tabs[tabKey]["view"].getHtmlElement(), true);
			this._tabs[tabKey]["view"].showMe();
		}
	}
}

DwtTabView.prototype._hideAllTabs = 
function() {
	if(this._tabs && this._tabs.length) {
		for(var curTabKey in this._tabs) {
			if(this._tabs[curTabKey]["view"]) {
				this._tabs[curTabKey]["view"].hideMe();
				//this._tabs[curTabKey]["view"].setZIndex(DwtTabView.Z_HIDDEN_TAB);
				Dwt.setVisible(this._tabs[curTabKey]["view"].getHtmlElement(), false);
			}	
		}
	}
}

/**
 * EMC 12/2/2004
 * This method could be invoked from various different locations, 
 * one being the DwtButton object, or the table that encloses the button.
 * The events, then are either selection events, or mouse up events. We handle
 * both cases here. In the case of the mouse up over the table, we are probably
 * over one of the tab images, which means we will walk up the dom to find
 * the table, which has the tab key attribute.
 */
DwtTabView.prototype._tabButtonListener = 
function (ev) {
    if(ev.item instanceof DwtButton) {
		this.switchToTab(ev.item.getData("tabKey"));
    } else {
	if (ev && ev.target) {
	    /**
	    * Greg Solovyev 1/3/2005 
		* changed ev.target.offsetParent.offsetParent to
		* lookup for the table up the elements stack, because the mouse down event may come from the img elements 
		* as well as from the td elements.	    
		**/
	    var elem = ev.target;
	    while(elem.tagName != "TABLE" && elem.offsetParent ) {
	    	elem = elem.offsetParent;
	    }
	    var tabKey = elem.getAttribute("tabKey");
	    if ((tabKey !== void 0) && (tabKey !== null)){
			this.switchToTab(tabKey);
	    }
	}
    }
}
	    

/**
* @class
* @constructor
* DwtTabViewPage abstract class for a page in a tabbed view
* tab pages are responsible for creating there own HTML and populating/collecting 
* data to/from any form fields that they display
**/
function DwtTabViewPage(parent, className, posStyle) {
	if (arguments.length == 0) return;
	var clsName = className || "DwtTabViewPage";
	var ps = posStyle || DwtControl.ABSOLUTE_STYLE;
	this._rendered = true; //by default UI creation is not lazy
	DwtPropertyPage.call(this, parent, clsName, ps);
}

DwtTabViewPage.prototype = new DwtPropertyPage;
DwtTabViewPage.prototype.constructor = DwtTabViewPage;

DwtTabViewPage.prototype.toString = 
function() {
	return "DwtTabViewPage";
}

DwtTabViewPage.prototype.showMe = 
function() {
	this.setZIndex(DwtTabView.Z_ACTIVE_TAB);
	if(this.parent.getHtmlElement().offsetHeight > 80) { //if the parent is visible use offsetHeight
		this.getHtmlElement().style.height=this.parent.getHtmlElement().offsetHeight-80;
	} else {
		//if the parent is not visible yet, then resize the page to fit the parent
		var parentHeight = parseInt(this.parent.getHtmlElement().style.height);
		var units = AjxStringUtil.getUnitsFromSizeString(this.parent.getHtmlElement().style.height);
		if(parentHeight > 80) {
			this.getHtmlElement().style.height = (Number(parentHeight-80).toString() + units);
		}
	}
	if(this.parent.getHtmlElement().offsetWidth > 0) //if the parent is visible use offsetWidth
		this.getHtmlElement().style.width=this.parent.getHtmlElement().offsetWidth;
	else {
		//if the parent is not visible yet, then resize the page to fit the parent
		this.getHtmlElement().style.width = this.parent.getHtmlElement().style.width;
	}
}

DwtTabViewPage.prototype.hideMe = 
function() {
	this.setZIndex(DwtTabView.Z_HIDDEN_TAB);
}


DwtTabViewPage.prototype.resetSize = 
function(newWidth, newHeight) {
	if(this._rendered) {
		this.setSize(newWidth, newHeight);
	}
}


/**
* @class
* @constructor
* @param parent
* DwtTabBar 
**/
function DwtTabBar(parent, tabCssClass, btnCssClass) {
	if (arguments.length == 0) return;
	//var _className = className || "DwtTabBar";
	this._buttons = new Array();
	this._tbuttons = new Array();
	this._btnStyle = btnCssClass ? btnCssClass : "DwtTabButton";
	this._btnImage = null;
	this._currentTabKey = 1;
	var myClass = tabCssClass ? tabCssClass : "DwtTabBar";

	DwtToolBar.call(this, parent, myClass, DwtControl.STATIC_STYLE);

	// NOTE: We explicitly pass in an index so that we can do exact
	//		 positioning of the spacer and filler elements.	
	this.addSpacer(null, 0);
	this.addFiller(null, 1);
}

DwtTabBar.prototype = new DwtToolBar;
DwtTabBar.prototype.constructor = DwtTabBar;

//public members
DwtTabBar.prototype.toString = 
function() {
	return "DwtTabBar";
}

DwtTabBar.prototype.getCurrentTab = 
function() {
	return this._currentTabKey;
}

DwtTabBar.prototype.addSpacer = 
function(size, index) {
	var el = DwtToolBar.prototype.addSpacer.apply(this, arguments);
	el.parentNode.style.verticalAlign = "bottom";
	return el;
}

DwtTabBar.prototype.addFiller = 
function(className, index) {
	var el = DwtToolBar.prototype.addFiller.apply(this, arguments);
	el.parentNode.style.verticalAlign = "bottom";
	return el;
}

DwtTabBar.prototype.addStateChangeListener = 
function(listener) {
	this._eventMgr.addListener(DwtEvent.STATE_CHANGE, listener);
}

DwtTabBar.prototype.removeStateChangeListener = 
function(listener) {
	this._eventMgr.removeListener(DwtEvent.STATE_CHANGE, listener);
}

/**
* @param tabId - the id used to create tab button in @link DwtTabBar.addButton method
* @param listener - AjxListener
**/
DwtTabBar.prototype.addSelectionListener =
function(tabKey, listener) {
	this._buttons[tabKey].addSelectionListener(listener);
	// This is for later retrieval in the listener method.
	this._tbuttons[tabKey].table.setAttribute("tabKey", tabKey);
	this._tbuttons[tabKey].leftImg.setAttribute("tabKey", tabKey);
	this._tbuttons[tabKey].rightImg.setAttribute("tabKey", tabKey);
	this._tbuttons[tabKey].leftTopImg.setAttribute("tabKey", tabKey);
	this._tbuttons[tabKey].rightTopImg.setAttribute("tabKey", tabKey);	
	this._tbuttons[tabKey].topImg.setAttribute("tabKey", tabKey);		
	this._tbuttons[tabKey]._bottomRow.setAttribute("tabKey", tabKey);		
	this._tbuttons[tabKey].addListener(DwtEvent.ONMOUSEUP, listener);
}

/**
* @param tabId - the id used to create tab button in @link DwtTabBar.addButton method
* @param listener - AjxListener
**/
DwtTabBar.prototype.removeSelectionListener =
function(tabKey, listener) {
	this._buttons[tabKey].removeSelectionListener(listener);
}

/**
* @param tabKey
* @param tabTitle
**/
DwtTabBar.prototype.addButton =
function(tabKey, tabTitle) {
	var tb = this._tbuttons[tabKey] = new DwtTabButton(this);
	var b = this._buttons[tabKey] = new DwtButton(tb, null, this._btnStyle, DwtControl.RELATIVE_STYLE);	
	
	// HACK: This is to get around resetting of button className during hover.
	var be = b.getHtmlElement();
	be.style.position = "relative";
	be.style.top = "-3px";
	
	this._buttons[tabKey].addSelectionListener(new AjxListener(this, DwtTabBar._setActiveTab));
	this._tbuttons[tabKey].addListener(DwtEvent.ONMOUSEUP, (new AjxListener(this,DwtTabBar._setActiveTab)));
	
	if (this._btnImage != null)
		b.setImage(this._btnImage);

	if (tabTitle != null)
		b.setText(tabTitle);

	b.setEnabled(true);
	b.setData("tabKey", tabKey);

	if(parseInt(tabKey) == 1)
		tb.setOpen();

	return b;
}

/**
* @param tabKey
* @return {DwtButton}
**/
DwtTabBar.prototype.getButton = 
function (tabKey) {
	if(this._buttons[tabKey])
		return this._buttons[tabKey];
	else 
		return null;
}

DwtTabBar.prototype.openTab = 
function(tabK) {
	this._currentTabKey = tabK;
    var cnt = this._tbuttons.length;

    for(var ix = 0; ix < cnt; ix ++) {
		if(ix==tabK) continue;

		if(this._tbuttons[ix])
	    	this._tbuttons[ix].setClosed();
    }

    if(this._tbuttons[tabK])
		this._tbuttons[tabK].setOpen();

    var nextK = parseInt(tabK) + 1;
	if (this._eventMgr.isListenerRegistered(DwtEvent.STATE_CHANGE))
		this._eventMgr.notifyListeners(DwtEvent.STATE_CHANGE, this._stateChangeEv);
}

//private members
// NOTE: The IE box model fix isn't needed.
DwtTabBar.prototype.__itemPaddingRight = "0px";

/**
 * This method overrides DwtToolBar#_addItem to handle adding elements at
 * a specific index. If an index is specified, it is passed directly to
 * the superclass's _addItem method. If no index is specified, however,
 * then the index is set to the number of cells in the toolbar minus one.
 * This is done in order to place the item <em>before</em> the trailing
 * filler element.
 * <p>
 * <strong>Note:</strong>
 * The implementation of this method assumes that the first child of
 * the tab bar's div element is a table.
 */
DwtTabBar.prototype._addItem = 
function(type, element, index) {
	if (!AjxUtil.isNumber(index)) {
		var el = this.getHtmlElement().firstChild;
		index = this._style == DwtToolBar.HORIZ_STYLE 
			  ? (el.rows[0].cells.length - 1)
			  : (el.rows.length - 1);
	}

	DwtToolBar.prototype._addItem.call(this, type, element, index);
}

DwtTabBar.prototype._createSpacerElement = 
function() {
	var table = document.createElement("table");
	table.width = "100%";
	table.cellSpacing = table.cellPadding = 0;
	
	var row1 = table.insertRow(table.rows.length);
	var row2 = table.insertRow(table.rows.length);
	var row3 = table.insertRow(table.rows.length);
	
	var row3cell1 = row3.insertCell(row3.cells.length);
	AjxImg.setImage(row3cell1, "TabSpacer__H", null, true);
	
	return table;
}

DwtTabBar.prototype._createFillerElement = DwtTabBar.prototype._createSpacerElement;

/**
* Greg Solovyev 1/4/2005 
* changed ev.target.offsetParent.offsetParent to
* lookup for the table up the elements stack, because the mouse down event may come from the img elements 
* as well as from the td elements.
**/
DwtTabBar._setActiveTab =
function(ev) {
    var tabK = null;
    if(ev && ev.item) {
		tabK=ev.item.getData("tabKey");
    } else if (ev && ev.target) {
		var elem = ev.target;
	    while(elem.tagName != "TABLE" && elem.offsetParent )
	    	elem = elem.offsetParent;

		tabK = elem.getAttribute("tabKey");
		if (tabK == null)
			return false;
    } else {
		return false;
    }
    this.openTab(tabK);
};

/**
* @class
* @constructor
* DwtTabButton encapsulates DwtButton to create a button that looks like a tab switch
* This class creates a div with a table. The table hosts graphics DwtButton div and surrounding graphics.
**/
function DwtTabButton(parent) {
	if (arguments.length == 0) return;
	this._isClosed = true;
	DwtComposite.call(this, parent, "DwtTabButton");
	this._inactiveClassName = "DwtTabButton-inactive";
	this._activeClassName = "DwtTabButton-active";
	
	this._createHtml();

	this._setMouseEventHdlrs();
	this._mouseOverListener = new AjxListener(this, DwtTabButton.prototype._mouseOverListener);
	this._mouseOutListener = new AjxListener(this, DwtTabButton.prototype._mouseOutListener);

	this.addListener(DwtEvent.ONMOUSEOVER, this._mouseOverListener);
	this.addListener(DwtEvent.ONMOUSEOUT, this._mouseOutListener);
	this._mouseOutAction = new AjxTimedAction(this, this._handleMouseOut);
	this._mouseOutActionId = -1;
}

DwtTabButton.prototype = new DwtComposite;
DwtTabButton.prototype.constructor = DwtTabButton;

DwtTabButton.prototype.toString = 
function() {
	return "DwtTabButton";
}

DwtTabButton.prototype._createHtml = 
function() {
	this.table = document.createElement("table");
	this.table.border = this.table.cellPadding = this.table.cellSpacing = 0;
	this.table.align = "center";
	this.table.width = "100%";

	this._topRow = this.table.insertRow(-1);
	this._middleRow = this.table.insertRow(-1);
	this._bottomRow = this.table.insertRow(-1);	

	this._leftTopCell = this._topRow.insertCell(-1);
	this._centerTopCell = this._topRow.insertCell(-1);
	this._rightTopCell = this._topRow.insertCell(-1);

	this._leftMiddleCell = this._middleRow.insertCell(-1);
	this._centerMiddleCell = this._middleRow.insertCell(-1);
	this._rightMiddleCell = this._middleRow.insertCell(-1);

	this._leftBottomCell = this._bottomRow.insertCell(-1);
	this._centerBottomCell = this._bottomRow.insertCell(-1);
	this._rightBottomCell = this._bottomRow.insertCell(-1);

	this._leftTopCell.className = "DwtTabButtonTL";
	this._centerTopCell.className = "DwtTabButtonTM";
	this._rightTopCell.className = "DwtTabButtonTR";

	this._leftBottomCell.className = "DwtTabButtonBL";
	this._centerBottomCell.className = "DwtTabButtonBM";
	this._rightBottomCell.className = "DwtTabButtonBR";

	this.leftTopImg = document.createElement("div");
	this.topImg = document.createElement("div");
	this.rightTopImg = document.createElement("div");
	AjxImg.setImage(this.leftTopImg, "Tab_TL", null, true);
	AjxImg.setImage(this.topImg, "Tab_T__H", AjxImg.HORIZ_BORDER, true);
	AjxImg.setImage(this.rightTopImg, "Tab_TR", null, true);
	this._leftTopCell.appendChild(this.leftTopImg);
	this._centerTopCell.appendChild(this.topImg);
	this._rightTopCell.appendChild(this.rightTopImg);

	this.leftImg = this._leftMiddleCell;
	this.centerImg = this._centerMiddleCell;
	this.rightImg = this._rightMiddleCell;
	AjxImg.setImage(this.leftImg, "Tab_L__V", AjxImg.VERT_BORDER, true);
	AjxImg.setImage(this.centerImg, "Tab__BG", AjxImg.BACKGROUND, true);
	AjxImg.setImage(this.rightImg, "Tab_R__V", AjxImg.VERT_BORDER, true);

	this.leftBottomImg = document.createElement("div");
	this.bottomImg = document.createElement("div");
	this.rightBottomImg = document.createElement("div");
	AjxImg.setImage(this.leftBottomImg, "Tab_BL", null, true);
	AjxImg.setImage(this.bottomImg, "Tab_B__H", AjxImg.HORIZ_BORDER, true);
	AjxImg.setImage(this.rightBottomImg, "Tab_BR", null, true);
	this._leftBottomCell.appendChild(this.leftBottomImg);
	this._centerBottomCell.appendChild(this.bottomImg);
	this._rightBottomCell.appendChild(this.rightBottomImg);

	this.getHtmlElement().appendChild(this.table);
	this.table.className = this._inactiveClassName;
};

/**
* Changes the visual appearance to active tab and sets _isClosed to false
**/
DwtTabButton.prototype.setOpen = 
function() {
	this.table.className=this._activeClassName;	
	this.setTabImageState("TabSel");
	this._isClosed = false;
};

/**
* Changes the visual appearance to inactive tab and sets _isClosed to true
**/
DwtTabButton.prototype.setClosed = 
function() {
	this.table.className = this._inactiveClassName;	
	this.setTabImageState("Tab");
	this._isClosed = true;
};

/**
* @param child
* DwtComposite.addChild method is overriden to to create tab switch graphics
**/
DwtTabButton.prototype.addChild = 
function(child) {
	this._centerMiddleCell.appendChild(child.getHtmlElement());
	child.addListener(DwtEvent.ONMOUSEOVER, this._mouseOverListener);
	child.addListener(DwtEvent.ONMOUSEOUT, this._mouseOutListener);
};

DwtTabButton.prototype._mouseOverListener = 
function(ev) {
	if (this._mouseOutActionId != -1) {
		AjxTimedAction.cancelAction(this._mouseOutActionId);
		this._mouseOutActionId = -1;
	}
	if (this._isClosed)
		this.setTabImageState("TabHover");
};

DwtTabButton.prototype._mouseOutListener = 
function(ev) {
	if (AjxEnv.isIE) {
		this._mouseOutActionId = AjxTimedAction.scheduleAction(this._mouseOutAction, 1);
	} else {
		this._handleMouseOut();
	}
};

DwtTabButton.prototype._handleMouseOut = 
function() {
	this._mouseOutActionId = -1;
	if (this._isClosed)
		this.setTabImageState("Tab");
};

DwtTabButton.prototype.setTabImageState = 
function(imagePrefix) {
	AjxImg.setImage(this.leftTopImg, imagePrefix + "_TL", null, true);
	AjxImg.setImage(this.topImg, imagePrefix + "_T__H", AjxImg.HORIZ_BORDER, true);
	AjxImg.setImage(this.rightTopImg, imagePrefix + "_TR", null, true);

	AjxImg.setImage(this.leftImg, imagePrefix + "_L__V", AjxImg.VERT_BORDER, true);
	AjxImg.setImage(this._centerMiddleCell, imagePrefix + "__BG", AjxImg.BACKGROUND, true);
	AjxImg.setImage(this.rightImg, imagePrefix + "_R__V", AjxImg.VERT_BORDER, true);

	AjxImg.setImage(this.leftBottomImg, imagePrefix + "_BL", null, true);
	AjxImg.setImage(this.bottomImg, imagePrefix + "_B__H", AjxImg.HORIZ_BORDER, true);
	AjxImg.setImage(this.rightBottomImg, imagePrefix + "_BR", null, true);
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* Creates a new wizard dialog.
* @constructor
* @class
* @param parent - parent control (shell)
* @param className - CSS class name
* @param title - dialog title
* @param w - content area width
* @param h - content area height
* This class represents a reusable wizard dialog. 
*/
function DwtWizardDialog (parent, className, title, w, h) {
	if (arguments.length == 0) return;
	var clsName = className || "DwtDialog";
	
	var nextButton = new DwtDialog_ButtonDescriptor(DwtWizardDialog.NEXT_BUTTON, AjxMsg._next, DwtDialog.ALIGN_RIGHT, new AjxCallback(this, this.goNext));
	var prevButton = new DwtDialog_ButtonDescriptor(DwtWizardDialog.PREV_BUTTON, AjxMsg._prev, DwtDialog.ALIGN_RIGHT, new AjxCallback(this, this.goPrev));
	var finishButton = new DwtDialog_ButtonDescriptor(DwtWizardDialog.FINISH_BUTTON, AjxMsg._finish, DwtDialog.ALIGN_RIGHT, new AjxCallback(this, this.finishWizard));
	DwtDialog.call(this, parent, clsName, null, [DwtDialog.CANCEL_BUTTON], [prevButton,nextButton,finishButton]);

	if (!w) {
		this._contentW = "80ex";
	} else {
		this._contentW = w;
	}
	
	if(!h) {
		this._contentH = "100ex";
	} else {
		this._contentH = h;
	}
	
	this._pages = new Array(); 
	this._pageIx = 1;
	this._currentPage = 1;
	this._progressDiv = document.createElement("div");
	this._progressDiv.style.position = DwtControl.STATIC_STYLE;
	this._pageDiv = document.createElement("div");
	this._pageDiv.className = "DwtWizardDialogPageDiv";
	this._pageDiv.style.width = this._contentW;
	this._pageDiv.style.height = this._contentH;
	this._progressBar = new DwtWizProgressBar(this);
	this._createContentHtml();
	this.setTitle(title);
}

DwtWizardDialog.prototype = new DwtDialog;
DwtWizardDialog.prototype.constructor = DwtWizardDialog;

//Z-index contants for the tabbed view contents are based on Dwt z-index constants
DwtWizardDialog.Z_ACTIVE_PAGE = Dwt.Z_VIEW+10;
DwtWizardDialog.Z_HIDDEN_PAGE = Dwt.Z_HIDDEN;
DwtWizardDialog.Z_TAB_PANEL = Dwt.Z_VIEW+20;
DwtWizardDialog.Z_CURTAIN = Dwt.Z_CURTAIN;

DwtWizardDialog.NEXT_BUTTON = 12;
DwtWizardDialog.PREV_BUTTON = 11;
DwtWizardDialog.FINISH_BUTTON = 13;

//public methods
DwtWizardDialog.prototype.toString = 
function () {
	return "DwtWizardDialog";
}

DwtWizardDialog.prototype.popdown = 
function () {
	DwtDialog.prototype.popdown.call(this);
	this._hideAllPages();
}

/**
* Makes the dialog visible, and places it. Everything under the dialog will become veiled
* if we are modal.
*
* @param loc	the desired location
*//*
DwtWizardDialog.prototype.popup =
function(loc) {

	var thisZ = this._zIndex;
	if (this._mode == DwtDialog.MODAL) {
		// place veil under this dialog
		var dialogZ = this._shell._veilOverlay.dialogZ;
		var currentDialogZ = null;
		var veilZ;
		if (dialogZ.length)
			currentDialogZ = dialogZ[dialogZ.length - 1];
		if (currentDialogZ) {
			thisZ = currentDialogZ + 2;
			veilZ = currentDialogZ + 1;
		} else {
			thisZ = this._zIndex;
			veilZ = Dwt.Z_VEIL;
		}
		this._shell._veilOverlay.veilZ.push(veilZ);
		this._shell._veilOverlay.dialogZ.push(thisZ);
		Dwt.setZIndex(this._shell._veilOverlay, veilZ);
	}
	Dwt._ffOverflowHack(this._htmlElId, thisZ, false);
	loc = this._loc = loc || this._loc; // use whichever has a value, local has precedence
	var sizeShell = this._shell.getSize();
	var sizeThis = this.getSize();
	var x, y;
	if (loc == null) {
		// if no location, go for the middle
		x = Math.round((sizeShell.x - sizeThis.x) / 2);
		y = Math.round((sizeShell.y - sizeThis.y) / 2);
	} else {
		x = loc.x;
		y = loc.y;
	}
	// try to stay within shell boundaries
	if ((x + sizeThis.x) > sizeShell.x)
		x = sizeShell.x - sizeThis.x;
	if ((y + sizeThis.y) > sizeShell.y)
		y = sizeShell.y - sizeThis.y;
	this.setLocation(x, y);
	
	this.setZIndex(thisZ);
}
*/
/*
* @param pageKey - key to the page to be shown. 
* pageKey is the value returned from @link DwtWizardDialog.prototype.addPage method
* This method is called by 
*	@link DwtWizardPage.prototype.switchToNextPage 
*	and 
*	@link DwtWizardPage.prototype.switchToPrevPage
*/
DwtWizardDialog.prototype.goPage = 
function(pageKey) {
	if(this._pages && this._pages[pageKey]) {
		this._currentPage = pageKey;
		this._showPage(pageKey);
		this._progressBar.showStep(pageKey);
		this._pages[pageKey].setActive();
	}
}

DwtWizardDialog.prototype.goNext = 
function() {
	var nextPageKey = this._currentPage + 1;
	if(this._pages && this._pages[this._currentPage]) {
		this._pages[this._currentPage].switchToNextPage(nextPageKey);
	}

}

DwtWizardDialog.prototype.goPrev = 
function() {
	var prevPageKey = this._currentPage - 1;
	if(this._pages && this._pages[this._currentPage]) {
		this._pages[this._currentPage].switchToPrevPage(prevPageKey);
	}
}

DwtWizardDialog.prototype.finishWizard = 
function() {
	this.popdown();	
}

/**
* public method getPage
* @param pageKey  -  key for the page, returned from @link addPage
* @return - the view tab (DwtPropertyPage) 
**/
DwtWizardDialog.prototype.getPage =
function (pageKey) {
	if(this._pages && this._pages[pageKey])
		return this._pages[pageKey];
	else
		return null;
}

/**
* public method addPage
* @param wizPage - instance of DwtPropertyPage 
* @return - the key for the added page. This key can be used to retreive the tab using @link getPage.
**/
DwtWizardDialog.prototype.addPage =
function (wizPage, stepTitle) {
	var pageKey = this._pageIx++;	
	this._pages[pageKey] = wizPage;
	//add a step to the progress bar
/*	if(stepTitle == null)
 		stepTitle = pageKey;*/
	this._progressBar.addStep(pageKey, stepTitle);
	//add the page 
	this._pageDiv.appendChild(this._pages[pageKey].getHtmlElement());
	
	if(pageKey==1) //show the first tab 
		this._pages[pageKey].setZIndex(DwtWizardDialog.Z_ACTIVE_PAGE); 
	else {
		//hide all the other tabs
		this._pages[pageKey].setZIndex(DwtWizardDialog.Z_HIDDEN_PAGE); 
		Dwt.setVisible(this._pages[pageKey].getHtmlElement(), false);
	}
	return pageKey;
}

//private and protected methods

/**
* method _createHtml 
**/

DwtWizardDialog.prototype._createContentHtml =
function () {

	this._table = document.createElement("table");
	this._table.border = 0;
	this._table.width = this._contentW;
	this._table.cellPadding = this._table.cellSpacing = 0;

	Dwt.associateElementWithObject(this._table, this);
	this._table.backgroundColor = DwtCssStyle.getProperty(this.parent.getHtmlElement(), "background-color");
	
	var row1; //_progressBar
	var col1;
	row1 = this._table.insertRow(0);
	row1.align = "left";
	row1.vAlign = "middle";
	
	col1 = row1.insertCell(row1.cells.length);
	col1.align = "left";
	col1.vAlign = "middle";
	col1.noWrap = true;	
	col1.width="100%";
	col1.className="DwtTabTable";
	col1.appendChild(this._progressBar.getHtmlElement());

	var rowSep;//separator
	var colSep;
	rowSep = this._table.insertRow(1);
	rowSep.align = "center";
	rowSep.vAlign = "middle";
	
	colSep = rowSep.insertCell(rowSep.cells.length);
	colSep.align = "left";
	colSep.vAlign = "middle";
	colSep.noWrap = true;	
	colSep.style.width = this._contentW;
	var sepDiv = document.createElement("div");
	sepDiv.className = "horizSep";
	sepDiv.style.width = this._contentW;
	sepDiv.style.height = "5px";
	colSep.appendChild(sepDiv);
	
	var row2; //page
	var col2;
	row2 = this._table.insertRow(2);
	row2.align = "left";
	row2.vAlign = "middle";
	
	col2 = row2.insertCell(row2.cells.length);
	col2.align = "left";
	col2.vAlign = "middle";
	col2.noWrap = true;	
	col2.width = this._contentW;
	col2.appendChild(this._pageDiv);

	this._contentDiv.appendChild(this._table);
}

/**
* Override addChild method. We need internal control over layout of the children in this class.
* Child elements are added to this control in the _createHTML method.
* @param child
**/
DwtWizardDialog.prototype.addChild =
function(child) {
	this._children.add(child);
}

DwtWizardDialog.prototype._showPage = 
function(pageKey) {
	if(this._pages && this._pages[pageKey]) {
		//hide all the tabs
		this._hideAllPages();
		//make this tab visible
		this._pages[pageKey].showMe();
		//this._pages[pageKey].setZIndex(DwtWizardDialog.Z_ACTIVE_PAGE);
		Dwt.setVisible(this._pages[pageKey].getHtmlElement(), true);
	}
}

DwtWizardDialog.prototype._hideAllPages = 
function() {
	if(this._pages && this._pages.length) {
		for(var curPageKey in this._pages) {
			if(this._pages[curPageKey]) {
				this._pages[curPageKey].hideMe();
				//this._pages[curPageKey].setZIndex(DwtWizardDialog.Z_HIDDEN_PAGE);
				Dwt.setVisible(this._pages[curPageKey].getHtmlElement(), false);
			}	
		}
	}
}


/**
* @class
* @constructor
* DwtWizardpage abstract class for a page in a wizard dialog
* tab pages are responsible for creating there own HTML and populating/collecting 
* data to/from any form fields that they display
**/
function DwtWizardPage(parent, className) {
	if (arguments.length == 0) return;
	var clsName = className || "DwtDialog";
	DwtPropertyPage.call(this, parent, className, DwtControl.ABSOLUTE_STYLE);
}

DwtWizardPage.prototype = new DwtTabViewPage;
DwtWizardPage.prototype.constructor = DwtWizardPage;

DwtWizardPage.prototype.toString = 
function() {
	return "DwtWizardPage";
}

/**
* setActive is called when the page is activated. 
**/
DwtWizardPage.prototype.setActive =
function () {

}

/**
* @param pageKey - key for the next page
* Checks if it is ok to leave go to the next page. 
* Default implementation does not check anything.
**/
DwtWizardPage.prototype.switchToNextPage = 
function (pageKey) {
	this.parent.goPage(pageKey);
}

/**
* @param pageKey - key for the previous page
* Checks if it is ok to leave go to the previous page. 
* Default implementation does not check anything.
**/
DwtWizardPage.prototype.switchToPrevPage = 
function (pageKey) {
	this.parent.goPage(pageKey);
}

DwtWizardPage.prototype.showMe = 
function() {
	this.setZIndex(DwtTabView.Z_ACTIVE_TAB);
	/*
	DBG.println(AjxDebug.DBG3, "DwtWizardPage.prototype.showMe");
	DBG.println(AjxDebug.DBG3, "this.parent.getHtmlElement().offsetHeight: " + this.parent.getHtmlElement().offsetHeight);		
	DBG.println(AjxDebug.DBG3, "this.parent.getHtmlElement().clientHeight: " + this.parent.getHtmlElement().clientHeight);				
	DBG.println(AjxDebug.DBG3, "this.parent.getHtmlElement().offsetWidth: " + this.parent.getHtmlElement().offsetWidth);		
	DBG.println(AjxDebug.DBG3, "this.parent.getHtmlElement().clientWidth: " + this.parent.getHtmlElement().clientWidth);				
	DBG.println(AjxDebug.DBG3, "this.parent._contentH: " + this.parent._contentH);					
	DBG.println(AjxDebug.DBG3, "this.parent._contentW: " + this.parent._contentW);		
	*/
	this.getHtmlElement().style.height = this.parent._contentH;
	this.getHtmlElement().style.width = this.parent._contentW;
	
}
/**
* @class DwtWizProgressBar
* @constructor
* @param parent
**/
function DwtWizProgressBar(parent) {
	if (arguments.length == 0) return;
	DwtComposite.call(this, parent, "DwtWizProgressBar", DwtControl.STATIC_STYLE);
	this._table = document.createElement("table");
	this._table.border = 0;
	this._table.cellPadding = 0;
	this._table.cellSpacing = 0;
	this.getHtmlElement().appendChild(this._table);
	this._table.backgroundColor = DwtCssStyle.getProperty(this.parent.getHtmlElement(), "background-color");
	this._stepsNumber = 0; //number of steps
	this._steps = new Array();
	this._lblHeader = new DwtStepLabel(this);
	this._lblHeader.setText("Step 0 of 0");
	this._lblHeader.setActive(true);
}


DwtWizProgressBar.prototype = new DwtComposite;
DwtWizProgressBar.prototype.constructor = DwtWizProgressBar;

DwtWizProgressBar.prototype.toString = 
function() {
	return "DwtWizProgressBar";
}

/**
* @param stepKey
**/
DwtWizProgressBar.prototype.showStep = 
function(stepKey) {
	var szLabelTxt = "Step " + stepKey + " of " + this._stepsNumber;
	if(this._steps[stepKey]) {
		szLabelTxt = szLabelTxt + ": " + this._steps[stepKey];
	}
	this._lblHeader.setText(szLabelTxt);
}

/**
* @param stepKey
* @param stepNumber
**/
DwtWizProgressBar.prototype.addStep =
function (stepKey, stepTitle) {
	this._steps[stepKey] = stepTitle;
	return (++this._stepsNumber);
}

DwtWizProgressBar.prototype.addChild =
function(child) {
	this._children.add(child);
	var row;
	var col;
	this._table.width = "100%";
	row = (this._table.rows.length != 0) ? this._table.rows[0]: this._table.insertRow(0);
	row.align = "center";
	row.vAlign = "middle";
		
	col = row.insertCell(row.cells.length);
	col.align = "center";
	col.vAlign = "middle";
	col.noWrap = true;
	col.appendChild(child.getHtmlElement());
}


/**
* @class DwtStepLabel
* @constructor
* @param parent
**/
function DwtStepLabel (parent) {
	DwtLabel.call(this, parent, DwtLabel.ALIGN_CENTER, "DwtStepLabel");
}

DwtStepLabel.prototype = new DwtLabel;
DwtStepLabel.prototype.constructor = DwtStepLabel;

DwtStepLabel.prototype.toString = 
function() {
	return "DwtStepLabel";
}

DwtStepLabel.prototype.setActive = 
function(isActive) {
	if (isActive) {
 		this._textCell.className="DwtStepLabelActive";
 	} else {
	 	this._textCell.className="DwtStepLabelInactive";
 	}
}

/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
 * @class DwtSelect
 * @constructor
 * Widget to replace the native select element.
 *
 * Note: Currently this does not support multiple selection.
 * @param options (Array) optional array of options. This can be either
 *                        an array of DwtSelectOptions or an array of strings.
 */
function DwtSelect(parent, options, className, posStyle, width, height) {
	 if (arguments.length==0) return;
    var clsName = className || "DwtSelect";
    var positionStyle = posStyle || Dwt.STATIC_STYLE;
    DwtButton.call(this, parent, null, clsName, positionStyle, DwtButton.ACTION_MOUSEDOWN);
	this._origClassName = this._className;
	this._activatedClassName = this._className + "-" + DwtCssStyle.ACTIVATED;
	this._triggeredClassName = this._className + "-" + DwtCssStyle.TRIGGERED;
	this._width = -1;

    // initialize some variables
    this._currentSelectionId = -1;
    this._options = new AjxVector();
    this._optionValuesToIndices = new Object();
    this._selectedValue = this._selectedOption = null;
    this._renderSelectBoxHtml(options);
	this.disabled = false;
	this._shouldToggleMenu = true;
}

DwtSelect.prototype = new DwtButton;
DwtSelect.prototype.constructor = DwtSelect;

DwtSelect.prototype.toString = 
function() {
    return "DwtSelect";
};

/**
 * This overrides the _createTable method in DwtLabel. 
 */
DwtSelect.prototype._createTable =
function() {
	this._table = document.createElement("table");
	this._table.id = Dwt.getNextId();
	this._row = this._table.insertRow(-1);
	this.getHtmlElement().appendChild(this._table);
	
	// Left is the default alignment. Note that if we do an explicit align left, Firefox freaks out
	if (this._style & DwtLabel.ALIGN_RIGHT) {
		this._table.align = "right";
	} else if (!(this._style & DwtLabel.ALIGN_LEFT)) {
		this._table.align = "center";
		this._table.width = "100%";
	}
};

// -----------------------------------------------------------
// static attributes
// -----------------------------------------------------------
/** This keeps track of all instances out there **/
DwtSelect._objectIds = [null];

// -----------------------------------------------------------
// instance tracking methods
// -----------------------------------------------------------
DwtSelect._assignId = 
function(anObject) {
    var myId = DwtSelect._objectIds.length;
    DwtSelect._objectIds[myId]= anObject;
    return myId;
};

DwtSelect._getObjectWithId = 
function(anId) {
    return DwtSelect._objectIds[anId];
};

DwtSelect._unassignId = 
function(anId) {
    DwtSelect._objectIds[anId] = null;
};

DwtSelect.getObjectFromElement = 
function(element) {
	return element && element.dwtObj 
		? AjxCore.objectWithId(element.dwtObj) : null
};

DwtSelect.prototype.dispose = 
function() {
	DwtControl.prototype.dispose.call(this);
	if (this._internalObjectId)
		DwtSelect._unassignId(this._internalObjectId);
};

// -----------------------------------------------------------
// overridden base class methods
// -----------------------------------------------------------
/**
 * Wanted to be able to calculate position relative to a containing
 * element, since the option display div is positioned relative to 
 * the this.getHtmlElement() div.
 */
DwtSelect.prototype.getBounds = 
function(anElement, containerElement) {
	anElement = anElement || this.getHtmlElement();
    var myBounds = new Object();
    myBounds.x = 0;
    myBounds.y = 0;
    myBounds.width = anElement.offsetWidth;
    myBounds.height = anElement.offsetHeight;
    
    if(containerElement == null) {
        containerElement = AjxEnv.isIE ? anElement.document.body : anElement.ownerDocument.body;
    }
    
    // account for the scrollbars if necessary
    var hasScroll = (anElement.scrollLeft !== void 0);
    var trace = anElement;

    while(trace != containerElement) {
        myBounds.x += trace.offsetLeft;
        myBounds.y += trace.offsetTop;
        
        var nextEl = trace.offsetParent;
        while (hasScroll && (trace != nextEl)) {
            myBounds.x -= trace.scrollLeft;
            myBounds.y -= trace.scrollTop;
            trace = AjxEnv.isIE ? nextEl : trace.parentNode;
        }
        trace = nextEl;
    }
    return myBounds;
};

// -----------------------------------------------------------
// rendering methods
// -----------------------------------------------------------
DwtSelect.prototype._renderSelectBoxHtml = 
function (options) {
    // setup our arrow button
	this.setDropDownImages(	"SelectPullDownArrow",				// normal
							"SelectPullDownArrowDis",			// disabled
							"SelectPullDownArrowHover",		// hover
						   	"SelectPullDownArrowSel"			// down
	);
	var menu = new DwtMenu(this, null, "DwtSelectMenu", null, true);
	this.setMenu(menu);
	menu.setAssociatedObj(this);
    // Add options, if present
    if (options) {
        for (var i = 0; i < options.length; ++i)
            this.addOption(options[i]);
    }
	var el = this.getHtmlElement();
	// Call down to DwtControl to setup the mouse handlers
	el._selectObjId = this.getUniqueIdentifier();
	this.setWidth();
};

// -----------------------------------------------------------
// public api methods
// -----------------------------------------------------------
/**
 * @param option (String or DwtSelectOption ) -- string for the option value
 *                                               or the option object.
 * @param selected (boolen) -- optional argument indicating whether
 *                             the newly added option should be
 *                             set as the selected option.
 * @param value (var) -- if the option parameter is a DwtSelectOption, this 
 *                       will override the value already set in the option.
 * @return integer -- A handle to the option added. The handle
 *                    can be used in other api methods.
 */
DwtSelect.prototype.addOption = 
function(option, selected, value) {
	var opt = null;
	var val = null;
	if (typeof(option) == 'string') {
		val = value != null ? value : option;
		opt = new DwtSelectOption(val, selected, option, this);
	} else {
		if (option instanceof DwtSelectOption) {
			opt = option;
			if (value)
				opt.setValue(value);
			selected = opt.isSelected();
		} else if(option instanceof DwtSelectOptionData) {
			val = value != null ? value : option.value;
			opt = new DwtSelectOption(val, option.isSelected, option.displayValue, this);
			selected = option.isSelected;
		} else {
			return -1;
		}
	}
	
	if (opt._optionWidth > this._width)
		this._width = opt._optionWidth;

	this._options.add(opt);

	if (this._options.size() == 1 || selected)
		this._setSelectedOption(opt);

	this._menu.__isDirty = true;

    // return the index of the option.
    this._optionValuesToIndices[opt.getValue()] = this._options.size() - 1;
	this.setWidth();

    return (this._options.size() - 1);
};

DwtSelect.prototype.clearOptions = 
function() {
	var opts = this._options.getArray();
	for (var i = 0; i < opts.length; ++i) {
		opts[i] = null;
	}
	this._options.removeAll();
	this._optionValuesToIndices = null;
	this._optionValuesToIndices = new Array();
	this._menu.removeChildren();
	this._menu.__isDirty = true;
	this._selectedValue = null;
	this._selectedOption = null;
	this._currentSelectionId = -1;
};

DwtSelect.prototype.setName = 
function(name) {
	this._name = name;
};

DwtSelect.prototype.getName = 
function() {
	return this._name;
};

DwtSelect.prototype.disable = 
function() {
	if (!this.disabled) {
		this.setEnabled(false);
		this._setDisabledStyle();
		this.setHandler(DwtEvent.ONSELECTSTART, this._disableSelectionIE);
		this.disabled = true;
	}
};

DwtSelect.prototype.enable = 
function() {
	if (this.disabled) {
		this.setEnabled(true);
		this._setEnabledStyle();
		this.clearHandler(DwtEvent.ONSELECTSTART);
		this.disabled = false;
	}
};

DwtSelect.prototype._disableSelectionIE = 
function() {
	return false;
};

DwtSelect.prototype._disableSelection = 
function() {
	var func = function() {
		window.getSelection().removeAllRanges();
	};
	window.setTimeout(func, 5);
};

DwtSelect.prototype.setSelectedValue = 
function(optionValue) {
    var index = this._optionValuesToIndices[optionValue];
    if ((index !== void 0) && (index !== null)) {
        this.setSelected(index);
    }
};

/**
 * Sets the option as the selected option.
 * @param optionHandle (integer) -- handle returned from addOption
 */
DwtSelect.prototype.setSelected = 
function(optionHandle) {
    var optionObj = this.getOptionWithHandle(optionHandle);
	this.setSelectedOption(optionObj);
};

DwtSelect.prototype.getOptionWithHandle = 
function(optionHandle) {
	return this._options.get(optionHandle);
};

DwtSelect.prototype.getIndexForValue = 
function(value) {
	return this._optionValuesToIndices[value];
};

DwtSelect.prototype.getOptionWithValue = 
function(optionValue) {
	var index = this._optionValuesToIndices[optionValue];
	var option = null;
    if ((index !== void 0) && ( index !== null)) {
        option = this.getOptionWithHandle(index);
    }
	return option;
};

DwtSelect.prototype.setSelectedOption = 
function(optionObj) {
	if (optionObj)
		this._setSelectedOption(optionObj);
};

DwtSelect.prototype.getValue = 
function() {
    return this._selectedValue;
};

DwtSelect.prototype.getSelectedOption = 
function() {
	return this._selectedOption;
};

DwtSelect.prototype.getSelectedIndex =
function() {
	return this.getIndexForValue(this.getValue());
};

DwtSelect.prototype.getWidth = 
function() {
	return DwtControl.prototype.getSize.call(this).x;
};

DwtSelect.prototype.setWidth = 
function() {
	if (this._lastSetWidth >= this._width) {
		this._width = this._lastSetWidth;
		return;
	}
	var el = this.getHtmlElement();
	// not sure why 29 was added; 18 = 16 (width of dropdown icon) + 2 (padding)
//	el.style.width = this._width + 29 + "px";
	el.style.width = this._width + 18 + "px";
	this._lastSetWidth = this._width;
};

DwtSelect.prototype.addChangeListener = 
function(listener) {
    this.addListener(DwtEvent.ONCHANGE, listener);
};


// -----------------------------------------------------------
// public interface for DwtSelectOption
// -----------------------------------------------------------

DwtSelect.prototype.getUniqueIdentifier = 
function() {
	return this._selectObjId;
};

DwtSelect.prototype.size = 
function() {
	return this._options.size();
}

// --------------------------------------------------------------------
// private methods
// --------------------------------------------------------------------

DwtSelect.prototype._toggleMenu = 
function(show) {
    // if an argument was not specified, do the opposite
	if (this._menu.__isDirty) {
		var optArr = this._options.getArray();
		for (var i = 0 ; i < optArr.length; ++i){
			var mi = new DwtMenuItem(this._menu, DwtMenuItem.SELECT_STYLE);
			var text = optArr[i].getDisplayValue();
			if (text) {
				mi.setText(text);
			}
			var image = optArr[i].getImage();
			if (image) {
				mi.setImage(image);
				// HACK to get image width
				optArr[i]._imageWidth = Dwt.getSize(AjxImg.getImageElement(mi._iconCell)).x;
			}
			mi.addSelectionListener(new AjxListener(this, this._handleOptionSelection));
			mi._optionIndex = i;
			optArr[i].setItem(mi);
		}
		this._menu.getHtmlElement().style.width = this.getHtmlElement().style.width;
		this._menu.__isDirty = false;
	}

	DwtButton.prototype._toggleMenu.call(this);
	if (this._selectedOption) {
		var selectedMenuItem = this._selectedOption.getItem();
		this._menu.setSelectedItem(selectedMenuItem._optionIndex);
	}

    return show;
};

DwtSelect.prototype._handleOptionSelection = 
function(ev) {
	var menuItem = ev.item;
	var optionIndex = menuItem._optionIndex;
	var opt = this._options.get(optionIndex);
	var oldValue = this.getValue();
	this._setSelectedOption(opt);

	// notify our listeners
    var args = new Object();
    args.selectObj = this;
    args.newValue = opt.getValue();
    args.oldValue = oldValue;
    var event = DwtUiEvent.getEvent(ev);
    event._args = args;
    this.notifyListeners(DwtEvent.ONCHANGE, event);
};

DwtSelect.prototype._clearOptionSelection = 
function() {
    if (this._currentSelectionId != -1) {
        var currOption = DwtSelect._getObjectWithId(this._currentSelectionId);
        currOption.deSelect();
    }
};

DwtSelect.prototype._setSelectedOption = 
function(option) {
	var displayValue = option.getDisplayValue();
	var image = option.getImage();
	if (this._selectedOption != option) {
		if (displayValue) {
			this.setText(displayValue);
		}
		if (image) {
			this.setImage(image);
		}
		this._selectedValue = option._value;
		this._selectedOption = option;
		this._menu._selectedOptionId = option.getIdentifier();
	}
    this._updateSelection(option);
};

DwtSelect.prototype._updateSelection = 
function(newOption) {
    var currOption = null;
    if (this._currentSelectionId != -1)
        currOption = DwtSelect._getObjectWithId(this._currentSelectionId);

    if (currOption)
        currOption.deSelect();

    if (newOption) {
		newOption.select();
		this._currentSelectionId = newOption.getIdentifier();
    }
};

DwtSelect.prototype._setDisabledStyle = 
function() {
	this.setClassName(this._className + " disabled");
};

DwtSelect.prototype._setEnabledStyle = 
function() {
	this.setClassName(this._origClassName);
};

/**
* Greg Solovyev 2/2/2004 added this class to be able to create a list of options 
* before creating the DwtSelect control. This is a workaround an IE bug, that 
* causes IE to crash with error R6025 when DwtSelectOption object are added to empty DwtSelect
* @class DwtSelectOptionData
* @constructor
*/
function DwtSelectOptionData (value, displayValue, isSelected) {
	if(value == null || displayValue==null) 
		return null;

	this.value = value;
	this.displayValue = displayValue;
	this.isSelected = isSelected;
}

/**
 * @class DwtSelectOption
 * @constructor
 *
 * DwtSelectOption encapsulates the option object that the DwtSelect widget
 * uses. 
 * The owner object that is passed into the constructor must implement the
 * following methods:
 *   getUniqueIdentifier()
 *   calcAndSetWidth(optionObject);
 *
 * @param value (string) -- this is the value for the object, it will be 
 *                          returned in any onchange event.
 * @param selected (Boolean) -- whether or not the option should be selected
 *                              to start with.
 * @param displayValue (string) -- The value that the user will see 
 *                                 ( html encoding will be done on this 
 *                                 value internally ).
 * @param owner (DwtSelect) -- implements the methods metioned above.
 * @param optionalDOMId (string) -- an optional id you want assigned to 
 *                                  the outer most underlying element.
 */
function DwtSelectOption(value, selected, displayValue, owner, optionalDOMId, image) {
	this._value = value;
	this._selected = selected;
	this._displayValue = displayValue;
	this._image = image;
	
	this._internalObjectId = DwtSelect._assignId(this);
	this._optionWidth = this._calculateWidth();
}

DwtSelectOption.prototype._calculateWidth = 
function() {
	var textWidth = 0;
	if (this._displayValue) {
		var size = Dwt.getHtmlExtent(AjxStringUtil.htmlEncode(this._displayValue));
		textWidth = size.x;
	}
	// HACK - assume it's a 16 x 16 icon if we don't have width yet
	var imageWidth = this._imageWidth ? this._imageWidth : 16;
	
	return textWidth + imageWidth;
};

DwtSelectOption.prototype.setItem = 
function(menuItem) {
	this._menuItem = menuItem;
};

DwtSelectOption.prototype.getItem = 
function(menuItem) {
	return this._menuItem;
};

DwtSelectOption.prototype.getDisplayValue = 
function() {
	return this._displayValue;
};

DwtSelectOption.prototype.getImage = 
function() {
	return this._image;
};

DwtSelectOption.prototype.getValue = 
function() {
	return this._value;
};

DwtSelectOption.prototype.setValue = 
function(stringOrNumber) {
	this._value = stringOrNumber;
};

DwtSelectOption.prototype.select = 
function() {
	this._selected = true;
};

DwtSelectOption.prototype.deSelect = 
function() {
	this._selected = false;
};

DwtSelectOption.prototype.isSelected = 
function() {
	return this._selected;
};

DwtSelectOption.prototype.getIdentifier = 
function() {
	return this._internalObjectId;
};

DwtSelect.prototype._popupMenu =
function() {
	var menu = this.getMenu();
	var p = menu.parent;
	var pb = p.getBounds();
	var ws = menu.shell.getSize();
	var s = menu.getSize();
	var x;
	var y;
	var vBorder;
	var hBorder;
	var pHtmlElement = p.getHtmlElement();
	// since buttons are often absolutely positioned, and menus aren't, we need x,y relative to window
	var ptw = Dwt.toWindow(pHtmlElement, 0, 0);
	vBorder = (pHtmlElement.style.borderLeftWidth == "") ? 0 : parseInt(pHtmlElement.style.borderLeftWidth);
	x = pb.x + vBorder;
	hBorder = (pHtmlElement.style.borderTopWidth == "") ? 0 : parseInt(pHtmlElement.style.borderTopWidth);
	hBorder += (pHtmlElement.style.borderBottomWidth == "") ? 0 : parseInt(pHtmlElement.style.borderBottonWidth);
	y = pb.y + pb.height + hBorder;
	x = ((x + s.x) >= (ws.x - 5 )) ? x - (x + s.x - ws.x): x;
	if ( (y + s.y) >= (ws.y - 5 )) {
		var myEl = menu.getHtmlElement();
		myEl.style.height = ws.y - y - 30;
		myEl.style.overflow = "auto";
	}
	//y = ((y + s.y) >= (ws.y - 30 )) ? y - (y + s.y - ws.y) : y;

	//this.setLocation(x, y);
	menu.popup(0, x, y);
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


//
// Constructor
//

/**
 * Constructs a control that shows two lists of items and allows the user
 * to move items between the two lists.
 *
 * @param parent               The parent container for this control.
 * @param className            (optional) The CSS class for this control. Default
 *					           value is "DwtAddRemove".
 * @param posStyle  (optional) The position style of this control.
 * @param sourceListClassName  The css class name for the source list.
 * @param targetListClassName  The css class name for the target list.
 */
function DwtAddRemove(parent, className, posStyle, sourceListClassName, targetListClassName) {
	if (arguments.length == 0) return;
	className = className || "DwtAddRemove";
	posStyle = posStyle || DwtControl.STATIC_STYLE;
	DwtComposite.call(this, parent, className, posStyle);
	this._createHTML(sourceListClassName, targetListClassName);
	this.isUpdating = false;
}

DwtAddRemove.prototype = new DwtComposite;
DwtAddRemove.prototype.constructor = DwtAddRemove;

DwtAddRemove.prototype.toString = function() {
	return "DwtAddRemove";
}

//
// Constants
//

/***
DwtAddRemove.ORIENTATION_HORIZONTAL = 0;
DwtAddRemove.ORIENTATION_VERTICAL = 1;

DwtAddRemove.SELECTION_SINGLE = 0;
DwtAddRemove.SELECTION_MULTIPLE = 1;
/***/

//
// Data
//

/***
DwtAddRemove.prototype._orientation = DwtAddRemove.ORIENTATION_HORIZONTAL;
DwtAddRemove.prototype._selection = DwtAddRemove.SELECTION_SINGLE;
/***/

// visual controls
DwtAddRemove.prototype._sourceList;
DwtAddRemove.prototype._addAllButton;
DwtAddRemove.prototype._addButton;
DwtAddRemove.prototype._removeButton;
DwtAddRemove.prototype._removeAllButton;
DwtAddRemove.prototype._targetList;

//
// Public methods
//

// listeners

DwtAddRemove.prototype.addStateChangeListener = function(listener) {
	this._targetList.addStateChangeListener(listener);
}

DwtAddRemove.prototype.removeStateChangeListener = function(listener) {
	this._targetList.removeStateChangeListener(listener);
}

// properties

/***
DwtAddRemove.prototype.setOrientation = function(orientation) {
	this._orientation = orientation;
}
DwtAddRemove.prototype.getOrientation = function() {
	return this._orientation;
}
DwtAddRemove.prototype.isHorizontal = function() {
	return this._orientation === DwtAddRemove.ORIENTATION_HORIZONTAL;
}
DwtAddRemove.prototype.isVertical = function() {
	return this._orientation === DwtAddRemove.ORIENTATION_VERTICAL;
}

DwtAddRemove.prototype.setSelection = function(selection) {
	this._selection = selection;
}
DwtAddRemove.prototype.getSelection = function() {
	return this._selection;
}
DwtAddRemove.prototype.isSingleSelect = function() {
	return this._selection === DwtAddRemove.SELECTION_SINGLE;
}
DwtAddRemove.prototype.isMultiSelect = function() {
	return this._selection === DwtAddRemove.SELECTION_MULTIPLE;
}
/***/

// public methods

DwtAddRemove.prototype.getSourceItems = function() {
	var list = this._sourceList.getList();
	var items = list ? list.clone().getArray() : [];
	return items ? items : [];
}
DwtAddRemove.prototype.setSourceItems = function(items) {
	this.removeAllSourceItems();
	this.addSourceItems(items);
}
DwtAddRemove.prototype.removeAllSourceItems = function() {
	// DwtListView#set calls removeAll and setUI
	//this._sourceList.removeAll();
	var list = new AjxVector();
	this._sourceList.set(list);
		
	this._addAllButton.setEnabled(false);
	this._addButton.setEnabled(false);
}
DwtAddRemove.prototype.removeSourceItem = function(item) {
	if (Array_contains(this.getSourceItems(), item)) {
		this._sourceList.removeItem(item);
		this._addAllButton.setEnabled(this.getSourceItems().length > 0);
		this._addButton.setEnabled(this._sourceList.getSelectionCount() > 0);
	}
}

DwtAddRemove.prototype.removeSourceItems = function(items) {
	for (var i = 0; i < items.length; i++) {
		this.removeSourceItem(items[i]);
	}
}

DwtAddRemove.prototype.addSourceItems = function(items) {
	for (var i = 0; i < items.length; i++) {
		this.addSourceItem(items[i]);
	}
}
DwtAddRemove.prototype.addSourceItem = function(item) {
	if (!Array_contains(this.getSourceItems(), item)) {
		this._sourceList.addItem(item);
		this._addAllButton.setEnabled(true);
	}
}

DwtAddRemove.prototype.getTargetItems = function() {
	var list = this._targetList.getList();
	var items = list ? list.clone().getArray() : [];
	return items ? items : [];
}
DwtAddRemove.prototype.setTargetItems = function(items) {
	this.removeAllTargetItems(false);
	this.addTargetItems(items);
}
DwtAddRemove.prototype.removeAllTargetItems = function(skipNotify) {
	// DwtListView#set calls removeAll and setUI
	//this._targetList.removeAll(skipNotify);
	var list = new AjxVector();
	this._targetList.set(list);
		
	this._removeButton.setEnabled(false);
	this._removeAllButton.setEnabled(false);
}
DwtAddRemove.prototype.removeTargetItem = function(item, skipNotify) {
	if (Array_contains(this.getTargetItems(), item)) {
		this._targetList.removeItem(item, skipNotify);
		this._removeButton.setEnabled(this._targetList.getSelectionCount() > 0);
		this._removeAllButton.setEnabled(this.getTargetItems().length > 0);
	}
}
DwtAddRemove.prototype.addTargetItems = function(items, skipNotify) {
	for (var i = 0; i < items.length; i++) {
		skipNotify = skipNotify || i < items.length - 1;
		this.addTargetItem(items[i], skipNotify);
	}
}
DwtAddRemove.prototype.addTargetItem = function(item, skipNotify) {
	if (!Array_contains(this.getTargetItems(), item)) {
		this._targetList.addItem(item, null, skipNotify);
		this._removeAllButton.setEnabled(true);
	}
}

// util methods

Array_contains = function(array, object) {
	for (var i = 0; i < array.length; i++) {
		if((array[i] instanceof String) && (object instanceof String) && (array[i].toString() == object.toString())) {
			return true;
		} else if (array[i] === object) {
			return true;
		}
	}
	return false;
}

// DwtComponent methods

DwtAddRemove.prototype.setEnabled = function(enabled) {
	// NOTE: DwtComposite doesn't propagate enabled to its children!
	//DwtComposite.prototype.setEnabled.call(this, enabled);
	this._sourceList.setEnabled(enabled);
	this._addAllButton.setEnabled(enabled ? this.getSourceItems().length > 0 : false);
	this._addButton.setEnabled(enabled ? this._sourceList.getSelectionCount() > 0 : false);
	this._removeButton.setEnabled(enabled ? this._targetList.getSelectionCount() > 0 : false);
	this._removeAllButton.setEnabled(enabled ? this.getTargetItems().length > 0 : false);
	this._targetList.setEnabled(enabled);
}

//
// Protected methods
//

/** @protected */
DwtAddRemove.prototype._sourceListListener = function(event) {
	var count = this._sourceList.getSelectionCount();
	this._addButton.setEnabled(count > 0);
}
/** @protected */
DwtAddRemove.prototype._addAllButtonListener = function(event) {
	this.isUpdating = true;
	var items = this.getSourceItems();
	//this.addTargetItems(items);
	for (var i = 0; i < items.length; i++) {
		var skipNotify = i < items.length - 1;
		this.addTargetItem(items[i], skipNotify);
	}
	this.removeAllSourceItems();
}
/** @protected */
DwtAddRemove.prototype._addButtonListener = function(event) {
	this.isUpdating = true;
	var itemDivs = this._sourceList.getSelectedItems().clone().getArray();
	for (var i = 0; i < itemDivs.length; i++) {
		var item = this._sourceList.getItemFromElement(itemDivs[i]);
		this.removeSourceItem(item);
		var skipNotify = i < itemDivs.length - 1;
		this.addTargetItem(item, skipNotify);
	}
}
/** @protected */
DwtAddRemove.prototype._removeButtonListener = function(event) {
	this.isUpdating = true;
	var itemDivs = this._targetList.getSelectedItems().clone().getArray();
	for (var i = 0; i < itemDivs.length; i++) {
		var item = this._targetList.getItemFromElement(itemDivs[i]);
		var skipNotify = i < itemDivs.length - 1;
		this.removeTargetItem(item, skipNotify);
		this.addSourceItem(item);
	}
}
/** @protected */
DwtAddRemove.prototype._removeAllButtonListener = function(event) {
	this.isUpdating = true;
	var items = this.getTargetItems();
	for (var i = 0; i < items.length; i++) {
		this.addSourceItem(items[i]);
	}
	this.removeAllTargetItems();
}
/** @protected */
DwtAddRemove.prototype._targetListListener = function(event) {
	var count = this._targetList.getSelectionCount();
	this._removeButton.setEnabled(count > 0);
}

/** @protected */
DwtAddRemove.prototype._createHTML = function(sourceListClassName, targetListClassName) {
	// if only one class name has been given, assume, both lists get the same class name.
	if (targetListClassName == null) targetListClassName = sourceListClassName;

	// create unique identifiers
	var thisId = this.getHtmlElement().id;
	var sourceDivId = thisId+"_source";
	var controlsDivId = thisId+"_controls";
	var targetDivId = thisId+"_target";

	// create html content
	var div = this.getHtmlElement();
	var width = 100; // REVISIT

	var table = document.createElement("TABLE");
	table.className = AjxBuffer.concat(this._className, "-", "outerTable");
	
	var row = table.insertRow(table.rows.length);

	var sourceDiv = row.insertCell(row.cells.length);
	sourceDiv.className = "DwtAddRemove-sourceContainer";
	sourceDiv.id = sourceDivId;
	sourceDiv.width = width; // REVISIT
	
	var controlsDiv = row.insertCell(row.cells.length);
	controlsDiv.className = "DwtAddRemove-controlsContainer";
	controlsDiv.id = controlsDivId;
	controlsDiv.align = "center";
	if (AjxEnv.isIE) {
		controlsDiv.style.paddingRight = "4px";
	}
	
	var targetDiv = row.insertCell(row.cells.length);
	targetDiv.className = "DwtAddRemove-targetContainer";
	targetDiv.id = targetDivId;
	targetDiv.width = width; // REVISIT

	div.appendChild(table);
		
	// create controls
	// REVISIT: replace with light-weight list boxes?
	this._sourceList = new DwtAddRemoveListView(this, sourceListClassName);
	this._addAllButton = new DwtButton(this);
	this._addButton = new DwtButton(this);
	this._removeButton = new DwtButton(this);
	this._removeAllButton = new DwtButton(this);
	this._targetList = new DwtAddRemoveListView(this, targetListClassName);

	// initialize controls
	this._sourceList._setNoResultsHtml = new Function();
	this._sourceList.addSelectionListener(new AjxListener(this, this._sourceListListener));

	this._addAllButton.setText(AjxMsg.addAll);
	this._addAllButton.setEnabled(false);
	this._addAllButton.addSelectionListener(new AjxListener(this, this._addAllButtonListener));

	this._addButton.setText(AjxMsg.add);
	this._addButton.setEnabled(false);
	this._addButton.addSelectionListener(new AjxListener(this, this._addButtonListener));
	
	this._removeButton.setText(AjxMsg.remove);
	this._removeButton.setEnabled(false);
	this._removeButton.addSelectionListener(new AjxListener(this, this._removeButtonListener));

	this._removeAllButton.setText(AjxMsg.removeAll);
	this._removeAllButton.setEnabled(false);
	this._removeAllButton.addSelectionListener(new AjxListener(this, this._removeAllButtonListener));

	this._targetList._setNoResultsHtml = new Function();
	this._targetList.addSelectionListener(new AjxListener(this, this._targetListListener));

	// insert controls into html
	sourceDiv.appendChild(this._sourceList.getHtmlElement());
	
	controlsDiv.appendChild(this._addAllButton.getHtmlElement());
	controlsDiv.appendChild(document.createElement("BR"));
	controlsDiv.appendChild(this._addButton.getHtmlElement());
	controlsDiv.appendChild(document.createElement("BR"));
	controlsDiv.appendChild(this._removeButton.getHtmlElement());
	controlsDiv.appendChild(document.createElement("BR"));
	controlsDiv.appendChild(this._removeAllButton.getHtmlElement());
	
	targetDiv.appendChild(this._targetList.getHtmlElement());
	
} // DwtAddRemove#_createHTML

function DwtAddRemoveListView(parent, className, type) {
	className = className || "DwtAddRemoveListView";
	DwtListView.call(this, parent, className);
	this._type = type;
}
DwtAddRemoveListView.prototype = new DwtListView;
DwtAddRemoveListView.prototype.constructor = DwtAddRemoveListView;

DwtAddRemoveListView.prototype._createItemHtml = function(item, now, isDnDIcon) {
	var div = document.createElement("DIV");
	div.id = Dwt.getNextId();
	var rowClassName = "DwtAddRemoveListViewRow";
	div._styleClass = AjxBuffer.concat("Row ",rowClassName);
	div._selectedStyleClass = AjxBuffer.concat("Row-", DwtCssStyle.SELECTED, " ", rowClassName);
	div._selectedDisabledStyleClass = AjxBuffer.concat("Row-", DwtCssStyle.SELECTED, "-" , DwtCssStyle.DISABLED, " ", rowClassName);
	div.className = div._styleClass;
	if( typeof (item) == "object") {
		div.innerHTML = AjxStringUtil.htmlEncode(item.toString());
	} else {
		div.innerHTML = AjxStringUtil.htmlEncode(String(item));
	}
	this.associateItemWithElement(item, div, DwtListView.TYPE_LIST_ITEM);
	return div;
}

DwtAddRemoveListView.prototype._mouseUpAction =
function(ev, div) {
	if (ev.button == DwtMouseEvent.LEFT) {
		if (this._evtMgr.isListenerRegistered(DwtEvent.SELECTION)) {
			this._selEv.field = ev.target.id.substring(0, 3);
			this._evtMgr.notifyListeners(DwtEvent.SELECTION, this._selEv);
		}
	}
	return true;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


//
// Constructor
//

/**
 * Constructs a control that alerts the user to important information.
 *
 * @param parent    The parent container for this control.
 * @param className (optional) The CSS class for this control. Default
 *					value is "DwtAlert".
 * @param posStyle  (optional) The position style of this control.
 */
function DwtAlert(parent, className, posStyle) {
	if (arguments.length == 0) return;
	posStyle = posStyle || DwtControl.STATIC_STYLE;
	DwtComposite.call(this, parent, null, posStyle);

	this._alertClass = className;
	this._alertStyle = DwtAlert.INFORMATION;
	this._createHTML();
}

DwtAlert.prototype = new DwtControl;
DwtAlert.prototype.constructor = DwtAlert;

//
// Constants
//

DwtAlert.INFORMATION = 0;
DwtAlert.WARNING = 1;
DwtAlert.CRITICAL = 2;

DwtAlert._ICONS = [ AjxImg.getClassForImage("Information_32"), AjxImg.getClassForImage("Warning_32"), AjxImg.getClassForImage("Critical_32") ];
DwtAlert._CLASSES = [ "DwtAlertInfo", "DwtAlertWarn", "DwtAlertCrit" ];

//
// Data
//

DwtAlert.prototype._alertClass;
DwtAlert.prototype._alertStyle;
DwtAlert.prototype._alertTitle;
DwtAlert.prototype._alertContent;

DwtAlert.prototype._alertDiv;
DwtAlert.prototype._iconDiv;
DwtAlert.prototype._titleDiv;
DwtAlert.prototype._contentDiv;

//
// Public methods
//

DwtAlert.prototype.setStyle = function(style) {
	this._alertStyle = style || DwtAlert.INFORMATION;
	this._iconDiv.className = "DwtAlertIcon "+DwtAlert._ICONS[this._alertStyle];
	this._alertDiv.className = "DwtAlert "+ (this._alertClass || DwtAlert._CLASSES[this._alertStyle]);
}
DwtAlert.prototype.getStyle = function() {
	return this._alertStyle;
}

DwtAlert.prototype.setIconVisible = function(visible) {
	var display = visible ? "block" : "none";
	// NOTE: This makes the parent <td> not visible
	this._iconDiv.parentNode.style.display = display;
}
DwtAlert.prototype.getIconVisible = function() {
	return this._iconDiv.style.display == "block";
}

DwtAlert.prototype.setTitle = function(title) {
	this._alertTitle = title;
	this._titleDiv.innerHTML = title || "";
}
DwtAlert.prototype.getTitle = function() {
	return this._alertTitle;
}

DwtAlert.prototype.setContent = function(content) {
	this._alertContent = content;
	this._contentDiv.innerHTML = content || "";
}
DwtAlert.prototype.getContent = function() {
	return this._alertContent;
}

//
// Protected methods
//

DwtAlert.prototype._createHTML = function() {

	// create unique identifiers
	var thisId = this.getHtmlElement().id;
	var iconDivId = thisId+"_icon";
	var titleDivId = thisId+"_title";
	var contentDivId = thisId+"_content";

	// NOTE: The alert HTML is created using TWO nested <table> elements
	//		 because 1) IE had problems with the alert icon floated to the
	//		 left within our application; and 2) Mozilla had problems with
	//		 obeying a table cell's rowSpan when creating the table
	//		 programmatically.
	
	// create html content
	this._alertDiv = document.createElement("TABLE");
	this._alertDiv.width = "90%";
	this._alertDiv.cellPadding = 0;
	this._alertDiv.cellSpacing = 0;
	this._alertDiv.className = "DwtAlert "+ (this._alertClass || DwtAlert._CLASSES[this._alertStyle]);
	
	this._iconDiv = document.createElement("DIV");
	this._iconDiv.id = iconDivId;
	this._iconDiv.className = "DwtAlertIcon "+DwtAlert._ICONS[this._alertStyle];

	// NOTE: The icon needs to be in a <div> inside the table cell so
	//		 that IE will use the CSS margin property.
	var row1 = this._alertDiv.insertRow(0);
	var cell1 = row1.insertCell(0);
	cell1.width = "1%";
	cell1.appendChild(this._iconDiv);

	var table2 = document.createElement("TABLE");
	table2.cellPadding = 0;
	table2.cellSpacing = 0;
	
	this._titleDiv = table2.insertRow(0).insertCell(0);
	this._titleDiv.id = titleDivId;
	this._titleDiv.className = "DwtAlertTitle";
	
	this._contentDiv = table2.insertRow(1).insertCell(0);
	this._contentDiv.id = contentDivId;
	this._contentDiv.className = "DwtAlertContent";
	
	var cell2 = row1.insertCell(1);
	cell2.width = "99%";
	cell2.appendChild(table2);

	// attach elements
	var parent = this.getHtmlElement();
	parent.style.align = "center";
	parent.appendChild(this._alertDiv);
}/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtText(parent, className, posStyle) {

	if (arguments.length == 0) return;
	className = className || "DwtText";
	DwtControl.call(this, parent, className, posStyle);
}

DwtText.prototype = new DwtControl;
DwtText.prototype.constructor = DwtText;

DwtText.prototype.toString = 
function() {
	return "DwtText";
}

DwtText.prototype.setText =
function(text) {
	if (!this._textNode) {
		 this._textNode = document.createTextNode(text);
		 this.getHtmlElement().appendChild(this._textNode);
	} else {
		this._textNode.data = text;
	}
}

DwtText.prototype.getText =
function() {
	return this._textNode.data;
}

DwtText.prototype.getTextNode =
function() {
	return this._textNode;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
 * @class DwtIframe
 * @author Mihai Bazon
 *
 * Simple event proxy.  Creates an IFRAME, inserts the given html into it and
 * forwards any events to the parent widget, translating mouse coordinates in
 * between.
 *
 * @param parent - The parent DwtComposite
 * @param html - the HTML code to be inserted in the IFRAME.  There will be
 *   slight modifications to it (i.e. the margins and paddings of the HTML
 *   element will be set to 0, also any margins for BODY).  @param
 * @param noscroll - (optional, default false) hide the scroll bars?
 * @param posStyle - (optional, default "static") passed over to DwtControl
 * @param processHtmlCallback - (optional) AjxCallback that will be called
 *   immediately after the HTML code was inserted.  A ref. to the document object
 *   will be passed.
 */
function DwtIframe(parent, className, hidden, html, styles, noscroll, posStyle, processHtmlCallback) {
	if (!posStyle)
		posStyle = DwtControl.STATIC_STYLE;
	DwtControl.call(this, parent, className || "DwtIframe", posStyle, false);
	this._styles = styles;
	this._noscroll = noscroll;
	this._iframeID = Dwt.getNextId();
	this._processHtmlCallback = processHtmlCallback;
	this._hidden = hidden;
	this._createFrame(html);
};

DwtIframe.prototype = new DwtControl;
DwtIframe.prototype.constructor = DwtIframe;

DwtIframe.prototype.getIframe = function() {
	return document.getElementById(this._iframeID);
};

DwtIframe.prototype.getDocument = function() {
	return this.getIframe().contentWindow.document;
};

/// Forwards events to the parent widget
DwtIframe.prototype._rawEventHandler = function(ev) {
	var iframe = this.getIframe();
	var win = iframe.contentWindow;
	if (AjxEnv.isIE)
		ev = win.event;

	var dw;
	// This probably sucks.
	if (/mouse|context|click|select/i.test(ev.type))
		dw = new DwtMouseEvent(true);
	else
		dw = new DwtUiEvent(true);
	dw.setFromDhtmlEvent(ev);

	// HACK! who would have know.. :-(
	// perhaps we need a proper mapping
	var type = dw.type.toLowerCase();
	if (!/^on/.test(type))
		type = "on" + type;
	// translate event coordinates
	var pos = this.getLocation();

	// What I can tell for sure is that we don't want the code below for IE
	// and we want it for Gecko, but I can't be sure of other browsers..
	// Let's assume they follow Gecko.  Seems mostly a trial and error
	// process :(
	if (!AjxEnv.isIE) {
		var doc = win.document;
		var sl = doc.documentElement.scrollLeft || doc.body.scrollLeft;
		var st = doc.documentElement.scrollTop || doc.body.scrollTop;
		pos.x -= sl;
		pos.y -= st;
	}

	dw.docX += pos.x;
	dw.docY += pos.y;
	dw.elementX += pos.x;
	dw.elementY += pos.y;

//   	window.status = dw.type + " doc(" + dw.docX + ", " + dw.docY + ") " +
//   		" element(" + dw.elementX + ", " + dw.elementY + ") " +
//  		" stopPropagation: " + dw._stopPropagation + ", " +
//  		" returnValue: " + dw._returnValue;

	var capture = DwtMouseEventCapture.getCaptureObj();
	if (AjxEnv.isIE || AjxEnv.isSafari || !capture) {
		// go for Dwt events
		DwtEventManager.notifyListeners(type, dw);
		this.parent.notifyListeners(type, dw);
	} else {
		// Satisfy object that holds the mouse capture.  IE seems not
		// to get here, which is Good.  But let's check, should we ever
		// have problems at least we know where to debug:
		if (AjxEnv.isIE)
			throw "IE is not supported by DwtIframe to dispatch real DOM events.";

		// the following is DOM2
		var fake = document.createEvent("MouseEvents");
		fake.initMouseEvent(ev.type,
				    true, // can bubble
				    true, // cancellable
				    document.defaultView, // the view
				    0, // event detail ("click count")
				    ev.screenX, // screen X
				    ev.screenY, // screen Y
				    dw.docX, // clientX, but translated to page
				    dw.docY, // clientY, translated
				    ev.ctrlKey, // key status...
				    ev.altKey,
				    ev.shiftKey,
				    ev.metaKey,
				    ev.button,
				    ev.relatedTarget);
		document.body.dispatchEvent(fake);
		// capture[DwtIframe._captureEvents[dw.type]](fake);
	}

	dw.setToDhtmlEvent(ev);
	return dw._returnValue;
};

// map event names to the handler name in a DwtMouseEventCapture object
// DwtIframe._captureEvents = { mousedown : "_mouseDownHdlr",
// 			     mousemove : "_mouseMoveHdlr",
// 			     mouseout  : "_mouseOutHdlr",
// 			     mouseover : "_mouseOverHdlr",
// 			     mouseup   : "_mouseUpHdlr" };

DwtIframe._forwardEvents = [ DwtEvent.ONCHANGE,
			     DwtEvent.ONCLICK,
			     DwtEvent.ONDBLCLICK,
			     DwtEvent.ONFOCUS,
			     DwtEvent.ONKEYDOWN,
			     DwtEvent.ONKEYPRESS,
			     DwtEvent.ONKEYUP,
			     DwtEvent.ONMOUSEDOWN,
			     DwtEvent.ONMOUSEENTER,
			     DwtEvent.ONMOUSELEAVE,
			     DwtEvent.ONMOUSEMOVE,
			     DwtEvent.ONMOUSEOUT,
			     DwtEvent.ONMOUSEOVER,
			     DwtEvent.ONMOUSEUP,
			     DwtEvent.ONSELECTSTART ];

DwtIframe.prototype._createFrame = function(html) {
	var self = this;

	// this is an inner function so that we can access the object (self).
	// it shouldn't create a memory leak since it doesn't directly "see"
	// the iframe variable (it's protected below)
	function rawHandlerProxy(ev) { 
		var rv = null;
		try {
			rv = self._rawEventHandler(ev); 
		} catch(ex) {
			// do nothing?
		}
		return rv;
	};

	// closure: protect the reference to the iframe node here.
	(function() {
		var iframe, tmp = [], i = 0, idoc;

		tmp[i++] = "<iframe";
		if (self._noscroll)
			tmp[i++] = " scrolling='no'";
		if (self._hidden)
			tmp[i++] = " style='visibility:hidden'";
		tmp[i++] = " frameborder='0' width='100%' id='";
		tmp[i++] = self._iframeID;
		tmp[i++] = "' src='javascript:\"\";'></iframe>";
		self.setContent(tmp.join(''));

		iframe = self.getIframe();
		idoc = Dwt.getIframeDoc(iframe);
		idoc.open();
		// make sure to explicitly add head tag for safari otherwise it cannot
		// be implicitly referenced (i.e. getElementsByTagName('head'))
		if (AjxEnv.isSafari)
			idoc.write("<html><head></head>");
		if (self._styles)
			idoc.write([ "<style type='text/css'>", self._styles, "</style>" ].join(""));
		idoc.write(html);
		idoc.close();
		// if we're not giving a break, we can safely do any postprocessing
		// here.  I.e. if we want to drop backgroundImage-s, it's safe to do it
		// here because the browser won't have a chance to load them.
		if (self._processHtmlCallback)
			self._processHtmlCallback.run(idoc);

		// if we have margins, the translated coordinates won't be OK.
		// it's best to remove them.  THE way to have some spacing is
		// to set padding on the body element.
		tmp = idoc.documentElement.style;
		tmp.margin = tmp.padding = idoc.body.style.margin = "0";

		// not sure this is needed, but it seems technically OK.
		Dwt.associateElementWithObject(idoc, self);

		// assign event handlers
		tmp = DwtIframe._forwardEvents;
		if (!AjxEnv.isIE)
			idoc = iframe.contentWindow;
		for (i = tmp.length; --i >= 0;)
			idoc[tmp[i]] = rawHandlerProxy;

		// catch browser context menus
		// idoc[DwtEvent.ONCONTEXTMENU] = DwtShell._preventDefaultPrt;
	})();
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtPropertySheet(parent, className, positionType) {
	if (arguments.length == 0) return;
	className = className || "DwtPropertySheet";
	DwtComposite.call(this, parent, className, positionType);

	this._propertyIdCount = 0;
	this._propertyList = [];
	this._propertyMap = {};
	
	this._tableEl = document.createElement("TABLE");
	this._tableEl.border = 0;
	this._tableEl.cellSpacing = 3;
	this._tableEl.cellPadding = 0;
	
	var element = this.getHtmlElement();
	element.appendChild(this._tableEl);
}

DwtPropertySheet.prototype = new DwtComposite;
DwtPropertySheet.prototype.constructor = DwtPropertySheet;

DwtPropertySheet.prototype.toString = 
function() {
	return "DwtPropertySheet";
}

// Data

DwtPropertySheet.prototype._labelCssClass = "Label";
DwtPropertySheet.prototype._valueCssClass = "Field";

DwtPropertySheet.prototype._tableEl;

DwtPropertySheet.prototype._propertyIdCount;
DwtPropertySheet.prototype._propertyList;
DwtPropertySheet.prototype._propertyMap;

// Public methods

/**
 * Adds a property.
 *
 * @param label [string] The property label. The value is used to set the
 *				inner HTML of the property label cell.
 * @param value The property value. If the value is an instance of DwtControl
 *				the element returned by <code>getHtmlElement</code> is used;
 *				if the value is an instance of Element, it is added directly;
 * 				anything else is set as the inner HTML of the property value
 *				cell.
 * @param required [boolean] Determines if the property should be marked as
 *				   required. This is denoted by an asterisk next to the label.
 */
DwtPropertySheet.prototype.addProperty = function(label, value, required) {
	var index = this._tableEl.rows.length;

	var row = this._tableEl.insertRow(index);
	row.vAlign = "top";
	
	var labelCell = row.insertCell(row.cells.length);
	labelCell.className = this._labelCssClass;
	labelCell.innerHTML = label;
	if (required) {
		var asterisk = this._tableEl.ownerDocument.createElement("SUP");
		asterisk.innerHTML = "*";
		labelCell.insertBefore(asterisk, labelCell.firstChild);
	}
	
	var valueCell = row.insertCell(row.cells.length);
	valueCell.className = this._valueCssClass;
	if (value instanceof DwtControl) {
		valueCell.appendChild(value.getHtmlElement());
	}
	/**** NOTE: IE says Element is undefined
	else if (value instanceof Element) {
	/***/
	else if (value.nodeType == AjxUtil.ELEMENT_NODE) {
	/***/
		valueCell.appendChild(value);
	}
	else {
		valueCell.innerHTML = String(value);
	}
	
	var id = this._propertyIdCount++;
	var property = { id: id, index: index, row: row, visible: true };
	this._propertyList.push(property);
	this._propertyMap[id] = property;
	return id;
};

DwtPropertySheet.prototype.removeProperty = function(id) {
	var prop = this._propertyMap[id];
	if (prop.visible) {
		var propIndex = prop.index;
		var tableIndex = this.__getTableIndex(propIndex);
		var row = this._tableEl.rows[tableIndex];
		row.parentNode.removeChild(row);
	}

	prop.row = null;
	for (var i = index + 1; i < this._propertyList.length; i++) {
		var prop = this._propertyList[i];
		prop.index--;
	}
	this._propertyList.splice(index, 1);
	delete this._propertyMap[id];
};

DwtPropertySheet.prototype.setPropertyVisible = function(id, visible) {
	var prop = this._propertyMap[id];
	if (prop.visible != visible) {
		prop.visible = visible;
		var propIndex = prop.index;
		if (visible) {
			var tableIndex = this.__getTableIndex(propIndex);
			var row = this._tableEl.insertRow(tableIndex);
			DwtPropertySheet.__moveChildNodes(prop.row, row);
			prop.row = row;
		}
		else {
			var row = prop.row;
			row.parentNode.removeChild(row);
		}
	}
};

DwtPropertySheet.prototype.__getTableIndex = function(propIndex) {
	var tableIndex = 0;
	for (var i = 0; i < propIndex; i++) {
		var prop = this._propertyList[i];
		if (prop.visible) {
			tableIndex++;
		}
	}
	return tableIndex;
};

DwtPropertySheet.__moveChildNodes = function(srcParent, destParent) {
	if (srcParent === destParent) return;
	var srcChild = srcParent.firstChild;
	while (srcChild != null) {
		destParent.appendChild(srcChild);
		srcChild = srcParent.firstChild;
	}
};
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtGrouper(parent, className, posStyle) {
	if (arguments.length == 0) return;
	className = className || "DwtBorder";
	posStyle = posStyle || DwtControl.STATIC_STYLE;
	DwtComposite.call(this, parent, null, posStyle);
	
	this._labelEl = document.createElement("SPAN");
	this._insetEl = document.createElement("DIV");
	this._borderEl = document.createElement("DIV");
	this._borderEl.appendChild(this._labelEl);
	this._borderEl.appendChild(this._insetEl);
	
	this.setStyle(DwtGrouper.SOLID);
	
	var element = this.getHtmlElement();
	element.appendChild(this._borderEl);
}

DwtGrouper.prototype = new DwtComposite;
DwtGrouper.prototype.constructor = DwtGrouper;

// Constants

DwtGrouper.SOLID = "solid";

DwtGrouper._STYLES = {};
DwtGrouper._STYLES[DwtGrouper.SOLID] = [ "GrouperBorder", "GrouperLabel", "GrouperInset" ];

// Data

DwtGrouper.prototype._borderEl;
DwtGrouper.prototype._labelEl;
DwtBorder.prototype._insetEl;

// Public methods

DwtGrouper.prototype.setStyle = function(style) {
	var cssClasses = DwtGrouper._STYLES[style];
	this._borderEl.className = cssClasses[0];
	this._labelEl.className = cssClasses[1];
	this._insetEl.className = cssClasses[2];
};

DwtGrouper.prototype.setLabel = function(htmlContent) {
	Dwt.setVisible(this._labelEl, Boolean(htmlContent));
	// HACK: undo block display set by Dwt.setVisible
	this._labelEl.style.display = "";
	this._labelEl.innerHTML = htmlContent ? htmlContent : "";
};

DwtGrouper.prototype.setContent = function(htmlContent) {
	var element = this._insetEl;
	element.innerHTML = htmlContent;
};

DwtGrouper.prototype.setElement = function(htmlElement) {
	var element = this._insetEl;
	Dwt.removeChildren(element);
	element.appendChild(htmlElement);
};

DwtGrouper.prototype.setView = function(control) {
	this.setElement(control.getHtmlElement());
};/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


//
// Constructor
//

/**
 *
 * @param parent    The parent container for this control.
 * @param className (optional) 
 * @param posStyle  (optional) The position style of this control.
 * @author Greg Solovyev
 */
function DwtProgressBar(parent, className, posStyle) {
	if (arguments.length == 0) return;
	posStyle = posStyle || DwtControl.STATIC_STYLE;
	DwtComposite.call(this, parent, null, posStyle);
	this._maxValue = 100;
	this._value = 0;
	this._quotabarDiv = null;
	this._quotausedDiv = null;	
	this._progressBgColor = "#66cc33";
	this._progressCssClass = "quotaused";	
	
	this._wholeBgColor = null;
	this._wholeCssClass = "quotabar";	
	this._createHTML();
}

DwtProgressBar.prototype = new DwtComposite;
DwtProgressBar.prototype.constructor = DwtProgressBar;


//
// Public methods
//
DwtProgressBar.prototype.setProgressBgColor = 
function(val) {
	this._progressBgColor = val;
}

DwtProgressBar.prototype.setWholeBgColor = 
function(val) {
	this._wholeBgColor = val;
}

DwtProgressBar.prototype.setProgressCssClass = 
function(val) {
	this._progressCssClass = val;
}

DwtProgressBar.prototype.setWholeCssClass = 
function(val) {
	this._wholeCssClass = val;
}

DwtProgressBar.prototype.setProgressCssStyle = 
function(val) {
	this._progressCssStyle = val;
}

DwtProgressBar.prototype.setWholeCssStyle  = 
function(val) {
	this._wholeCssStyle = val;
}

DwtProgressBar.prototype.setValue = 
function(val) {
	this._value = parseInt(val);
	var percent;

	if(this._value == this._maxValue)
		percent = 100;
	else 
		percent = Math.min(Math.round((this._value / this._maxValue) * 100), 100);	

	if(isNaN(percent))
		percent = "0";
			
	if(!this._quotabarDiv) {
		this._quotabarDiv = document.createElement("div")
		if(this._wholeCssClass)
			this._quotabarDiv.className = this._wholeCssClass;

		if(this._wholeBgColor)
			this._quotabarDiv.backgroundColor = this._wholeBgColor;
		
		this._cell.appendChild(this._quotabarDiv);
	}
	if(!this._quotausedDiv) {
		this._quotausedDiv = document.createElement("div")
		if(this._progressCssClass)
			this._quotausedDiv.className = this._progressCssClass;
			
		if(this._progressBgColor)
			this._quotausedDiv.style.backgroundColor = this._progressBgColor;
			
		this._quotabarDiv.appendChild(this._quotausedDiv);			
	}	

	this._quotausedDiv.style.width = percent + "%";
}

DwtProgressBar.prototype.getValue = 
function() {
	return this._value;
}

DwtProgressBar.prototype.getMaxValue = 
function() {
	return this._maxValue;
}

DwtProgressBar.prototype.setMaxValue = 
function(val) {
	this._maxValue = parseInt(val);
}

//
// Protected methods
//

DwtProgressBar.prototype._createHTML = 
function() {
	this._table = document.createElement("table");
	this._table.border = this._table.cellpadding = this._table.cellspacing = 0;	

	this._row = this._table.insertRow(-1);

	if(AjxEnv.isLinux)
		this._row.style.lineHeight = 13;
	
	this._cell = this._row.insertCell(-1);
	
	this.getHtmlElement().appendChild(this._table);
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function DwtXFormsEvent(form, formItem, details) {
	if (arguments.length == 0) return;
	this.form = form;
	this.formItem = formItem;
	this.details = details;
}

DwtEvent.prototype.toString = function() {
	return "DwtXFormsEvent";
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function XFG () {} // XFormGlobal

XFG.prefixList = {};
XFG.objectCache = {};
XFG.getUniqueId = function (namePrefix) {
	if (namePrefix == null) namePrefix = "__id__";
	var list = XFG.prefixList;

	// if we've never seen one of these before, call it the name they passed in
	//	(without a number) and set the counter to 1 (so the next one is #2)
	if (list[namePrefix] == null) {
		list[namePrefix] = 1;
		return namePrefix;
	} else {
		list[namePrefix]++;
		return namePrefix + "_" + list[namePrefix];
	}
};

XFG.assignUniqueId = function (object, namePrefix) {
	var id = XFG.getUniqueId(namePrefix);
	object.__id = id;
	XFG.objectCache[id] = object;
};

XFG.cacheGet = function (id){
	return XFG.objectCache[id];
}

XFG.createEl = function (id, parentEl, tagName, contents) {
	// create the element
	if (tagName == null) tagName = "div";
	var el = window.document.createElement(tagName);

	// set its id and contents (if supplied)
	el.id = id;
	if (contents != null) el.innerHTML = contents;

	// root it under the parent
	if (parentEl == null) {
		parentEl = document.body;
	}
	parentEl.appendChild(el);
	
	return el;
}

XFG.getEl = function (id, frame) {
	// if they passed something other than a string, assume its the element itself
	if (typeof id != "string") return id;
	
	var doc = (doc == null ? document : frame.document);
	var it = doc.getElementById(id);
	if (it == null) it = null;
	return it;
};

XFG.hideEl = function (id,isBlock) {
	var el = (typeof id == "string" ? XFG.getEl(id) : id);
	if (el) {
		if(!isBlock)
			el.style.display = "none";
			
		el.style.visibility = "hidden";
	} else {
		DBG.println("hideEl(", id, "): element not found");
	}
};

XFG.showEl = function (id) {
	var el = (typeof id == "string" ? XFG.getEl(id) : id);
	if (el) {
		if (el.tagName == "TD") {
			if (AjxEnv.isIE) {
				el.style.display = "block";
			} else {
				el.style.display = "table-cell";			
			}
		} else {
			el.style.display = "block";
		}
		el.style.visibility = "visible";
	} else {
		DBG.println("showEl(", id, "): element not found");
	}
};

XFG.getClassName = function(element) {
	if (typeof element == "string") element = XFG.getEl(element);
	if (element) return element.className;
	return "";
};

XFG.showSelected = function (element) {
	XFG.setClassName(element, XFG.addSuffix(XFG.getClassName(element), "_selected"));
};

XFG.hideSelected = function (element) {
	XFG.setClassName(element, XFG.removeSuffix(XFG.getClassName(element), "_selected"));
};

XFG.setClassName = function (element, className) {
	if (typeof element == "string") element = XFG.getEl(element);
	if (element) element.className = className;
};

XFG.addSuffix = function (text, suffix) {
	if (text.indexOf(suffix) > -1) return text;
	return text + suffix;
};

XFG.removeSuffix = function (text, suffix) {
	if (text.indexOf(suffix) < 0) return text;
	return text.substring(0, text.indexOf(suffix));	
};

XFG.showOver = function (element) {
	XFG.setClassName(element, XFG.addSuffix(XFG.getClassName(element), "_over"));
};

XFG.hideOver = function (element) {
	XFG.setClassName(element, XFG.removeSuffix(XFG.getClassName(element), "_over"));
}


XFG.showDisabled = function (element) {
	XFG.setClassName(element, XFG.addSuffix(XFG.getClassName(element), "_disabled"));
};

XFG.hideDisabled = function (element) {
	XFG.setClassName(element, XFG.removeSuffix(XFG.getClassName(element), "_disabled"));
}



/* StringBuffer class  changed to AjxBuffer and moved into Ajax/js/util/  */



XFG.getCookie = function (name) {
	var value = new RegExp(name + "=([^;]+)").exec(document.cookie);
	return (value != null) ? unescape(value[1]) : null;
}


XFG.setCookie = function (name, value) { // use: setCookie("name", value);
	document.cookie = name + "=" + escape(value);
}




XFG.valueToString = function (value, indent, skipDerivedProperties, skipMethods, skipPrototypeProperties) {
	if (value == null) return "null";
	if (indent == null) indent = "";

	// strings get quotes
	if (typeof value == "string") return '"' + value + '"';

	// for arrays, list all the objects in it
	if (value instanceof Array) {
		var buffer = new AjxBuffer();
		for (var i = 0; i < value.length; i++) {
			buffer.append(indent, "        ", XFG.valueToString(value[i], indent+"    ", skipDerivedProperties, skipMethods, skipPrototypeProperties));
		}
		return "[\n" + buffer.join(",\n") + "\n" + indent + "    ]";
	}

	// for dates, return the syntax to create a new date (might as well)
	if (value instanceof Date) {
		return " new Date("+ [value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds()].join(",") + ")";
	}
	
	if (typeof value == "function") {
		return "(function)";
	}

	// for objects, call
	if (typeof value == "object") return XFG.objectToString(value, indent+"    ", skipDerivedProperties, skipMethods, skipPrototypeProperties);
	
	return value;	
}

XFG.objectToString = function (object, indent, skipDerivedProperties, skipMethods, skipPrototypeProperties) {
	if (indent == null) indent = "";

	var indentSpacer = "    ";
	var buffer = [];
	var hasObject = false;
	var propCount = 0;
	var proto = object.constructor.prototype;

	if (proto == null) proto = {};
	for (var prop in object) {
		var value = object[prop];
		if (skipPrototypeProperties && (object[prop] == proto[prop])) continue;
		if (skipMethods && value instanceof Function) continue;
		
		// if we have a derived property, write its id or [object] so we don't recurse too much
		if ((prop.indexOf("__") == 0 || prop.indexOf("$") == 0) && value instanceof Object) {
			buffer.push(AjxBuffer.concat(prop, ": ", value.toString()));
		} else {
			hasObject = hasObject || (typeof value == "object");
			buffer.push(AjxBuffer.concat(prop, ": ", XFG.valueToString(value, indent, skipDerivedProperties, skipMethods, skipPrototypeProperties)));
		}
		propCount++;
	}
	buffer.sort(XFG.sortSpecialLast);
	if (hasObject || propCount > 5) {
		return "{\n" + indent + indentSpacer + buffer.join(",\n"+indent + indentSpacer) + "\n" + indent + "}"
	} else {
		return "{" + indentSpacer + buffer.join(", ") + indentSpacer + "}";
	}
}

XFG.sortSpecialLast = function (a,b) {
	var a1 = a.charAt(0);
	var b1 = b.charAt(0);
	var aIsSpecial = a1 == "_" || a1 == "$";
	var bIsSpecial = b1 == "_" || b1 == "$";
	if ( !aIsSpecial && !bIsSpecial) {
		return (a > b ? 1 : -1)
	} else if (aIsSpecial && bIsSpecial) {
		return (a > b ? 1 : -1)
	} else if (aIsSpecial) {
		return 1;
	} else {
		return -1;
	}
	
}



/* DEPRECATED:  Use AjxBuffer() instead */
function StringBuffer() {
	this.clear();
	if (arguments.length > 0) {
		arguments.join = this.buffer.join;
		this.buffer[this.buffer.length] = arguments.join("");
	}
}
StringBuffer.prototype.toString = function () {
	return this.buffer.join("");
}
StringBuffer.prototype.join = function (delim) {
	if (delim == null) delim = "";
	return this.buffer.join(delim);
}
StringBuffer.prototype.append = function () {
	arguments.join = this.buffer.join;
	this.buffer[this.buffer.length] = arguments.join("");
}
StringBuffer.prototype.join = function (str) {
	return this.buffer.join(str);
}
StringBuffer.prototype.set = function(str) {
	this.buffer = [str];
}
StringBuffer.prototype.clear = function() {
	this.buffer = [];
}
StringBuffer.concat = function() {
	arguments.join = Array.prototype.join;
	return arguments.join("");
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


var _MODEL_ = "model";
var _INSTANCE_ = "instance";
var _INHERIT_ = "inherit";
var _MODELITEM_ = "modelitem";


function XModel(attributes) {
	// get a unique id for this form
	XFG.assignUniqueId(this, "_Model_");

	// copy any attributes passed in directly into this object
	if (attributes) {
		for (var prop in attributes) {
			this[prop] = attributes[prop];	
		}
	}
	
	if (this.items == null) this.items = [];
	
	this._pathIndex = {};
	this._pathGetters = {};
	this._parentGetters = {};
	this._itemsAreInitialized = false;
	this._errorMessages = {};

	if (this.getDeferInit() == false) {
		this.initializeItems();
	}
}
XModel.toString = function() {	return "[Class XModel]";	}
XModel.prototype.toString = function() {	return "[XModel " + this.__id + "]";	}

XModel.prototype.pathDelimiter = "/";
XModel.prototype.getterScope = _INSTANCE_;
XModel.prototype.setterScope = _INSTANCE_;

// set deferInit to false to initialize all modelItems when the model is created
//	NOTE: this is generally a bad idea, and all XForms are smart enough
//			to tell their models to init before they need them...
XModel.prototype.deferInit = true;
XModel.prototype.getDeferInit = function () {	return this.deferInit	}


XModel.prototype.initializeItems = function() {
	if (this._itemsAreInitialized) return;
	
	var t0 = new Date().getTime();

	this.__nestedItemCount = 0;	//DEBUG

	// initialize the items for the form
	this.items = this.initItemList(this.items, null);

	this._itemsAreInitialized = true;

	var t1 = new Date().getTime();
	//DBG.println(this,".initializeItems(): w/ ", this.__nestedItemCount," items took ", (t1 - t0), " msec");
}



XModel.prototype.initItemList = function(itemAttrs, parentItem) {
	var items = [];
	for (var i = 0; i < itemAttrs.length; i++) {
		items[i] = this.initItem(itemAttrs[i], parentItem);
	}
	this.__nestedItemCount += itemAttrs.length;		//DEBUG
	return items;
}


XModel.prototype.initItem = function(itemAttr, parentItem) {
	// if we already have a form item, assume it's been initialized already!
	if (itemAttr.__isXModelItem) return itemAttr;

	// create the XFormItem subclass from the item attributes passed in
	//	(also links to the model)
	var item = XModelItemFactory.createItem(itemAttr, parentItem, this);
	
	
	
	// have the item initialize it's sub-items, if necessary (may be recursive)
	item.initializeItems();

	return item;
}

XModel.prototype.addItem = function(item, parentItem) {
	if (!item.__isXModelItem) item = this.initItem(item, parentItem);
	if (parentItem == null) {
		this.items.push(item);
	} else {
		parentItem.addItem(item);
	}
}

// add an item to our index, so we can find it easily later
XModel.prototype.indexItem = function(item, path) {
	this._pathIndex[path] = item;
}






//
// getting modelItems, parent items, their paths, etc
//

XModel.prototype.getItem = function(path, createIfNecessary) {
	// try to find the item by the path, return if we found it
	var item = this._pathIndex[path];
	if (item != null) return this._pathIndex[path];

	// if we didn't find it, try normalizing the path
	var normalizedPath = this.normalizePath(path);
	//	convert any "#1", etc to just "#"
	for (var i = 0; i < normalizedPath.length; i++) {
		if (normalizedPath[i].charAt(0) == "#") normalizedPath[i] = "#";
	}
	// and if we find it, save that item under the original path and return it
	item = this._pathIndex[normalizedPath.join(this.pathDelimiter)];
	if (item != null) {
		this._pathIndex[path] = item;
		return item;
	}

	if (createIfNecessary != true) return null;

	// get each parent item (creating if necessary) until we get to the end
	var parentItem = null;
	for (var p = 0; p < normalizedPath.length; p++) {
		var itemPath = normalizedPath.slice(0, p+1).join(this.pathDelimiter);
		var item = this.getItem(itemPath, false);
		if (item == null) {
			//DBG.println("making modelItem for ", itemPath);
			item = XModelItemFactory.createItem({id:normalizedPath[p]}, parentItem, this);
		}
		parentItem = item;
	}
	return item;
}



// "normalize" a path and return it split on the itemDelimiter for this model
XModel.prototype.normalizePath = function (path) {
	if (path.indexOf("[") > -1) {
		path = path.split("[").join("/#");
		path = path.split("]").join("");
	}
	if (path.indexOf(".") > -1) {
		path = path.split(this.pathDelimiter);
		var outputPath = [];
		for (var i = 0; i < path.length; i++) {
			var step = path[i];
			if (step == "..") {
				outputPath.pop();
			} else if (step != ".") {
				outputPath.push(step);
			}
		}
		return outputPath;
	}
	return path.split(this.pathDelimiter);
}


XModel.prototype.getParentPath = function (path) {
	path = this.normalizePath(path);
	return path.slice(0, path.length - 1);
}

XModel.prototype.getLeafPath = function (path) {
	path = this.normalizePath(path);
	return path[path.length - 1];
}






XModel.prototype.getInstanceValue = function (instance, path) {
	var getter = this._getPathGetter(path);
//DBG.println("getInstanceValue(",path,"):" + (typeof path) + ":" + (typeof getter));
	return getter.call(this, instance);
}

XModel.prototype.getParentInstanceValue = function (instance, path) {
	var getter = this._getParentPathGetter(path);
//DBG.println("getParentInstanceValue(",path,"):" + (typeof path) + ":" + (typeof getter));
	return getter.call(this, instance);
}


XModel.prototype.setInstanceValue = function (instance, path, value) {
//DBG.println("setInstanceValue(",path,"): ", value, " (",typeof value,")");
	var parentValue = this.getParentInstanceValue(instance, path);
	if (parentValue == null) {
		parentValue = this.setParentInstanceValues(instance, path);
	}
	var modelItem = this.getItem(path, true);
	var leafPath = this.getLeafPath(path);
	var ref = modelItem.ref;
	if (leafPath.charAt(0) == "#") ref = parseInt(leafPath.substr(1));
	
	if (modelItem.setter) {
		// convert "/" to "." in the ref
		if (ref.indexOf(this.pathDelimiter) > -1) ref = ref.split(this.pathDelimiter).join(".");

		var setter = modelItem.setter;
		var scope = modelItem.setterScope;
		if (scope == _INHERIT_) scope = this.setterScope;
		if (scope == _INSTANCE_) {
			instance[setter](value, parentValue, ref);
		} else if (scope == _MODEL_) {
			this[setter](value, instance, parentValue, ref);		
		} else {
			modelItem[setter](value, instance, parentValue, ref);
		}
	} else {
		if (typeof ref == "string" && ref.indexOf(this.pathDelimiter) > -1) {
			ref = ref.split(this.pathDelimiter);
			for (var i = 0; i < ref.length - 1; i++) {
				parentValue = parentValue[ref[i]];
			}
			ref = ref.pop();
		}
		parentValue[ref] = value;
	}
	return value;
}


XModel.prototype.setParentInstanceValues = function (instance, path) {
	var pathList = this.getParentPath(path);
	for (var i = 0; i < pathList.length; i++) {
		var itemPath = pathList.slice(0, i+1).join(this.pathDelimiter);
		var itemValue = this.getInstanceValue(instance, itemPath);
		if (itemValue == null) {
			var modelItem = this.getItem(itemPath, true);
			var defaultValue = modelItem.getDefaultValue();
			itemValue = this.setInstanceValue(instance, itemPath, defaultValue);
		}
	}
	return itemValue;
}







//NOTE: model.getInstance() gets count of PARENT
// "modelItem" is a pointer to a modelItem, or an path as a string
XModel.prototype.getInstanceCount = function (instance, path) {
	var list = this.getParentInstanceValue(instance, path);
	if (list != null && list.length) return list.length;
	return 0;
}


// "path" is a path of id's
XModel.prototype.addRowAfter = function (instance, path, afterRow) {
	var newInstance = null;	
	
	var modelItem = this.getItem(path);
	if (modelItem) {
		newInstance = this.getNewListItemInstance(modelItem);
	} else {
		newInstance = "";
	}
	var list = this.getInstanceValue(instance, path);
	if (list == null) {
		// create a list and install it!
		list = [];
		this.setInstanceValue(instance, path, list);
	}

	list.splice(afterRow+1, 0, newInstance);
}


XModel.prototype.getNewListItemInstance = function (modelItem) {
	var listItem = modelItem.listItem;
	if (listItem == null) return "";
	return this.getNewInstance(listItem);
}

XModel.prototype.getNewInstance = function (modelItem) {
	if (modelItem.defaultValue != null) return modelItem.defaultValue;
	
	var type = modelItem.type;
	switch (type) {
		case _STRING_:
			return "";

		case _NUMBER_:
			return 0;
			
		case _OBJECT_:
			var output = {};
			if (modelItem.items) {
				for (var i = 0; i < modelItem.items.length; i++) {
					var subItem = modelItem.items[i];
					if (subItem.ref) {
						output[subItem.ref] = this.getNewInstance(subItem);
					} else if (subItem.id) {
						output[subItem.id] = this.getNewInstance(subItem);
					}
				}
			
			}
			return output;
			
		case _LIST_:
			return [];

		case _DATE_:
		case _TIME_:
		case _DATETIME_:
			return new Date();
			
		default:
			return "";
	}
}



// "modelItem" is a pointer to a modelItem, or an path as a string
XModel.prototype.removeRow = function (instance, path, instanceNum) {
	var list = this.getInstanceValue(instance, path);
	if (list == null) return;

	// WHAT IF LIST IS A STRING?
	list.splice(instanceNum, 1);
}






// for speed, we create optimized functions to traverse paths in the instance
//	to actually return values for an instance.  Make them here.
//
XModel.prototype._getPathGetter = function (path) {
//DBG.println("_getPathGetter(",path,")");
	var getter = this._pathGetters[path];
	if (getter != null) return getter;

	getter = this._makePathGetter(path);
//DBG.println("assigning path getter for ", path, " to ", getter);
	this._pathGetters[path] = getter;
	return getter;
}

XModel.prototype._getParentPathGetter = function (path) {
//DBG.println("_getParentPathGetter(",path,")");
	var getter = this._parentGetters[path];
	if (getter != null) return getter;
	
	var parentPath = this.getParentPath(path).join(this.pathDelimiter);
	getter = this._getPathGetter(parentPath);
	this._parentGetters[path] = getter;
	this._pathGetters[parentPath] = getter;
	return getter;
}


XModel.prototype._makePathGetter = function (path) {
	if (path == null) return new Function("return null");
	
	// normalizePath() converts to an array, fixes all "." and ".." items, and changes [x]  to #x
	var pathList = this.normalizePath(path);

	// forget any leading slashes
	if (pathList[0] == "") pathList = pathList.slice(1);
	
//	DBG.println("_makePathGetter(", path, "): ", pathList);
	var methodSteps = [];
	var pathToStep = "";
	
	for (var i = 0; i < pathList.length; i++) {
		var	pathStep = pathList[0, i];
		
		if (pathStep.charAt(0) == "#") {
			pathStep = pathStep.substr(1);
			pathToStep = pathToStep + "#";
		} else {
			pathToStep = pathToStep + pathStep;

		}
		var	modelItem = this.getItem(pathToStep, true);
		var ref = modelItem.ref;

		// convert "/" to "." in the ref
		if (ref.indexOf(this.pathDelimiter) > -1) ref = ref.split(this.pathDelimiter).join(".");

		if (modelItem.getter) {
			var getter = modelItem.getter;
			var scope = modelItem.getterScope;
			if (scope == _INHERIT_) {
				scope = this.getterScope;
			}
			
			if (scope == _INSTANCE_) {
				methodSteps.push("if(instance) {");	
				methodSteps.push("	current = instance."+ getter+ "(current, '"+ref+"');");
				methodSteps.push("}");							
			} else if (scope == _MODEL_) {
				methodSteps.push("current = this."+ getter+ "(instance, current, '"+ref+"');");
			} else {
				methodSteps.push("current = this.getItem(\""+ pathToStep+ "\")."+ getter+ "(instance, current, '"+ref+"');");			
			}
			
		} else if (ref == "#") {
			methodSteps.push("if(current) {");	
			methodSteps.push("	current = current[" + pathStep + "];");
			methodSteps.push("}");					
		} else {
			methodSteps.push("if(current) {");		
			methodSteps.push("	current = current." + ref + ";");
			methodSteps.push("}");					
		}
		pathToStep += this.pathDelimiter;
	}

	var methodBody = AjxBuffer.concat(
			"try {\r",
			"var current = instance;\r",
			"\t", methodSteps.join("\r\t"), "\r",
			"} catch (e) {\r ",
			"	DBG.println('Error in getting path for \"", path, "\": ' + e);\r",
			"	current = null;\r",
			"}\r",
			"return current;\r"
		);
	//DBG.println(path,"\r\t", methodSteps.join("\r\t"), "\r");
	var method = new Function("instance", methodBody);

	return method;
}








// error messages
//	NOTE: every call to XModel.prototype.registerError() should be translated!

XModel._errorMessages = {};
XModel.registerErrorMessage = XModel.prototype.registerErrorMessage = function (id, message) {
	this._errorMessages[id] = message;
}
XModel.registerErrorMessage("unknownError", "Unknown error.");
XModel.prototype.defaultErrorMessage = "unknownError";


// set the default error message for the model (it's not a bad idea to override this in your models!)
XModel.prototype.getDefaultErrorMessage = function (modelItem) {
	if (modelItem && modelItem.errorMessage) {
		return modelItem.getDefaultErrorMessage();
	}

	return this.defaultErrorMessage;
}

XModel.prototype.getErrorMessage = function (id, arg0, arg1, arg2, arg3, arg4) {
	var msg = this._errorMessages[id];
	if (msg == null) msg = XModel._errorMessages[id];
	
	if (msg == null) {
		DBG.println("getErrorMessage('", id, "'): message not found.  If this is an actual error message, add it to the XModel error messages so it can be translated.");
		return id;
	}
	if (arg0 !== null) msg = msg.split("{0}").join(arg0);
	if (arg1 !== null) msg = msg.split("{1}").join(arg1);
	if (arg2 !== null) msg = msg.split("{2}").join(arg2);
	if (arg3 !== null) msg = msg.split("{3}").join(arg3);
	if (arg4 !== null) msg = msg.split("{4}").join(arg4);
	return msg;
}
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/



//
//	Factory to create XModelItems from simple attributes (eg: from JS object literals or XML)
//

/** This class is never instantiated. 
 */
function XModelItemFactory() {}

XModelItemFactory.createItem = function (attributes, parentItem, xmodel) {
	// assign a modelItem to the item
	var type = attributes.type;
	constructor = this.getItemTypeConstructor(type || _UNTYPED_);

	var item = new constructor();
	item._setAttributes(attributes);
	if (item.id != null && item.ref == null) item.ref = item.id;

	// idPath is mostly used for debugging...
	var idPath = this.getIdPath(attributes, parentItem);
	item.__idPath = idPath;

	item.__xmodel = xmodel;
	item.__parentItem = parentItem;

//DBG.println("XModelItemFactory.createItem(", attributes.id, ") idPath='", idPath, "' type='", item.type,"'");
	item.initModelItem();

	// add the item to its model's index
	xmodel.indexItem(item, idPath);

	return item;
}

XModelItemFactory.getIdPath = function (attributes, parentItem) {
	if (attributes.path) return attributes.path;
	return this.getFullPath(attributes.id, (parentItem ? parentItem.getIdPath() : ""));
}

XModelItemFactory.getFullPath = function (itemPath, parentPath) {
	if (itemPath == null) return null;
	if (parentPath == null) parentPath = "";
	
	var path = itemPath;
	if (itemPath == ".") {
		path = parentPath;

	} else if (itemPath == "..") {
		parentPath = parentPath.split("/");
		path = parentPath.slice(0, parentPath.length - 1).join("/");

	} else if (parentPath == "") {
		path = itemPath;

	} else {
		path = parentPath + "/" + itemPath;
	}
	return path;
}



XModelItemFactory.typeConstructorMap = {};

XModelItemFactory.createItemType = function (typeConstant, typeName, constructor, superClassConstructor) {
	if (constructor == null) constructor = new Function();
	if (typeof superClassConstructor == "string") superClassConstructor = this.getItemTypeConstructor(superClassConstructor);
	if (superClassConstructor == null) superClassConstructor = XModelItem;

	// initialize the constructor
	constructor.prototype = new superClassConstructor();	

	constructor.prototype.type = typeName;
	constructor.prototype.constructor = constructor;
	constructor.prototype.toString = new Function("return '[XModelItem:" + typeName + " path=\"' + this.getIdPath() + '\"]'");
	constructor.toString = new Function("return '[Class XModelItem:" + typeName + "]'");
	
	// put the item type into the typemap
	this.registerItemType(typeConstant, typeName, constructor);

	// return the prototype
	return constructor;
}

XModelItemFactory.registerItemType = function(typeConstant, typeName, constructor) {
	// assign the type constant to the window so everyone else can use it
	window[typeConstant] = typeName;
	this.typeConstructorMap[typeName] = constructor;	
}


XModelItemFactory.getItemTypeConstructor = function (typeName) {
	var typeConstructor = this.typeConstructorMap[typeName];
	if (typeConstructor == null) typeConstructor = this.typeConstructorMap["string"];
	return typeConstructor;
}







function XModelItem() {}
XModelItemFactory.createItemType("_UNTYPED_", "untyped", XModelItem, Object);

// define the base class as the "object" class -- it works, but no type logic is applied
XModelItemFactory.registerItemType("_OBJECT_", "object", XModelItem);


// set base class defaults

XModelItem.prototype.__isXModelItem = true;
XModelItem.prototype.getterScope = _INHERIT_;
XModelItem.prototype.setterScope = _INHERIT_;

// methods
XModelItem.prototype._setAttributes = function (attributes) {
	this._attributes = attributes;
	for (var prop in attributes) {
		this[prop] = attributes[prop];
	}
}


XModelItem.prototype.initModelItem = function() {
	window.status = '';
}



// initialize sub-items for this item
XModelItem.prototype.initializeItems = function () {
	var items = this.getItems();
	if (items != null) {
		this.items = this.getModel().initItemList(items, this);
	}
}



//
//	accessors
//
XModelItem.prototype.getModel = function() 		{		return this.__xmodel;		}
XModelItem.prototype.getParentItem = function() 	{		return this.__parentItem;	}
XModelItem.prototype.getIdPath = function()	 	{		return this.__idPath;		}


XModelItem.prototype.getItems = function () 		{		return this.items;			}
XModelItem.prototype.addItem = function (item) {
	if (!item.__isXModelItem) item = this.xmodel.initItem(item, this);
	if (this.items == null) this.items = [];
	this.items.push(item);
}


XModelItem.prototype.getConstraints = function()	{		return this.constraints;	}
XModelItem.prototype.getRequired = function()		{		return this.required;		}
XModelItem.prototype.getReadonly = function()		{		return this.readonly;		}
XModelItem.prototype.getReadOnly = XModelItem.prototype.getReadonly;


XModelItem.prototype.getDefaultValue = function () {return new Object() };


//
//	validate this value (i.e. when a formitem that refers to it has changed)
//

XModel.registerErrorMessage("valueIsRequired", AjxMsg.valueIsRequired);
XModelItem.prototype.validate = function (value, form, formItem, instance) {

	// see if it's required
	if (value == null || value === "") {
		if (this.getRequired()) {
			throw this.getModel().getErrorMessage("valueIsRequired", value);
		}
    }
    
	// next validate the type
	//	this will throw an exception if something went wrong
	//	also, value may be coerced to a particular type by the validator
	else {
		value = this.validateType(value);
	}
	
	// if they defined any constraints, 
	var constraints = this.getConstraints();
	if (constraints == null) return value;

	if (! (AjxUtil.isInstance(constraints, Array))) constraints = [constraints];
	for (var i = 0; i < constraints.length; i++) {
		var constraint = constraints[i];
		if (constraint.type == "method") {
			// The constraint method should either return a value, or throw an
			// exception.
			value = constraint.value.call(this, value, form, formItem, instance);
		}
// 		if (isValid == false) {
// 			throw this.getModel().getErrorMessage(constraint.errorMessageId, value);
// 		}
	}
	return value;
}

XModelItem.prototype.getDefaultErrorMessage = function () {
	return this.errorMessage;
}


// generic validators for different data types
//	we have them here so we can use them in the _LIST_ data type


XModelItem.prototype.validateType = function(value) {	return value;		}




//
//	for validating strings
//

/**
 * Datatype facet: length. If not null, the length of the data
 * value must be equal to this value. Specifying this attribute
 * ignores the values for {@link XModelItem.prototype.minLength}
 * and {@link XModelItem.prototype.maxLength}.
 */
XModelItem.prototype.length = null;

/**
 * Datatype facet: minimum length. If not null, the length of
 * the data value must not be less than this value.
 */
XModelItem.prototype.minLength = null;

/**
 * Datatype facet: maximum length. If not null, the length of
 * the data value must not exceed this value.
 */
XModelItem.prototype.maxLength = null;

/**
 * Datatype facet: pattern. If not null, specifies an array of
 * <code>RegExp</code> objects. The data value must match one of
 * the patterns or an error is signaled during validation.
 */
XModelItem.prototype.pattern = null;

/**
 * Datatype facet: enumeration. If not null, specifies an array of
 * literal string values. The data value must match one of the
 * literals or an error is signaled during validation.
 */
XModelItem.prototype.enumeration = null;

/**
 * Datatype facet: white space. If not null, specifies how white
 * space in the value should be processed before returning the
 * final value. Valid values are:
 * <ul>
 * <li>"preserve": leaves whitespace as-is (default)
 * <li>"replace": replaces tabs, newlines, and carriage-returns with a space
 * <li>"collapse": same as "replace"  but also trims leading and trailing whitespace and replaces sequences of spaces with a single space
 * </ul>
 */
XModelItem.prototype.whiteSpace = null;

XModelItem.prototype.getLength = function() 		{ return this.length; }
XModelItem.prototype.getMinLength = function () 	{	return this.minLength;				}
XModelItem.prototype.getMaxLength = function () 	{	return this.maxLength;				}
XModelItem.prototype.getPattern = function() {
	if (this.pattern != null && this.pattern.checked == null) {
		if (AjxUtil.isString(this.pattern)) {
			this.pattern = [ new RegExp(this.pattern) ];
		}
		else if (AjxUtil.isInstance(this.pattern, RegExp)) {
			this.pattern = [ this.pattern ];
		}
		else if (AjxUtil.isArray(this.pattern)) {
			for (var i = 0; i < this.pattern.length; i++) {
				var pattern = this.pattern[i];
				if (AjxUtil.isString(pattern)) {
					this.pattern[i] = new RegExp(this.pattern[i]);
				}
			}
		}
		else {
			// REVISIT: What to do in this case? Do we just
			//          assume that it was specified correctly?
		}
		this.pattern.checked = true;
	}
	return this.pattern;
}
XModelItem.prototype.getEnumeration = function() { return this.enumeration; }
XModelItem.prototype.getWhiteSpace = function() { return this.whiteSpace; }

XModel.registerErrorMessage("notAString",		AjxMsg.notAString);
XModel.registerErrorMessage("stringLenWrong",   AjxMsg.stringLenWrong);
XModel.registerErrorMessage("stringTooShort", 	AjxMsg.stringTooShort);
XModel.registerErrorMessage("stringTooLong",	AjxMsg.stringTooLong);
XModel.registerErrorMessage("stringMismatch",   AjxMsg.stringMismatch);

XModelItem.prototype.validateString = function(value) {
	if (value == null) return;
	
	if (!AjxUtil.isString(value)) {
		throw this.getModel().getErrorMessage("notAString", value);
	}

	value = this._normalizeAndValidate(value);

    var length = this.getLength();
    if (length !== null) {
        if (value.length !== length) {
            throw this.getModel().getErrorMessage("stringLenWrong", length);
        }
    }
    else {
		var maxLength = this.getMaxLength();
		if (maxLength !== null && value.length > maxLength) {
			throw this.getModel().getErrorMessage("stringTooLong", maxLength);
		}
	
		var minLength = this.getMinLength();
		if (minLength !== null && value.length < minLength) {
			throw this.getModel().getErrorMessage("stringTooShort", minLength);
		}
    }
    
    return value;
}

/**
 * Normalizes value against whiteSpace facet and then validates 
 * against pattern and enumeration facets.
 * @private
 */
XModelItem.prototype._normalizeAndValidate = function(value) {

    var whiteSpace = this.getWhiteSpace();
    if (whiteSpace !== null) {
    	if (whiteSpace === "replace" || whiteSpace === "collapse") {
    		value = value.replace(/[\t\r\n]/g, " ");
    	}
    	if (whiteSpace === "collapse") {
    		value = value.replace(/^\s+/,"").replace(/\s+$/,"").replace(/[ ]+/, " ");
    	}
    }
	
    var pattern = this.getPattern();
    if (pattern != null) {
    	var matched = false;
    	for (var i = 0; i < pattern.length; i++) {
    		if (pattern[i].test(value)) {
    			matched = true;
    			break;
    		}
    	}
		if (!matched) {
			throw this.getModel().getErrorMessage("stringMismatch", value);
		}    	
    }
    
    var enumeration = this.getEnumeration();
    if (enumeration !== null) {
    	var matched = false;
    	for (var i = 0; i < enumeration.length; i++) {
    		if (enumeration[i] === value) {
    			matched = true;
    			break;
    		}
    	}
    	if (!matched) {
			throw this.getModel().getErrorMessage("stringMismatch", value);
    	}
    }
    
	return value;
}


//
//	for validating numbers
//

/**
 * Datatype facet: total digits. If not null, the number of
 * digits before the decimal point in the data value must not
 * be greater than this value.
 */
XModelItem.prototype.totalDigits = null;
 
/** 
 * Datatype facet: fraction digits. If not null, the number of
 * digits after the decimal point in the data value must not be
 * greater than this value.
 */
XModelItem.prototype.fractionDigits = null;

/** 
 * Datatype facet: maximum value (inclusive). If not null, the
 * data value must be less than or equal to this value.
 */
XModelItem.prototype.maxInclusive = null;

/** 
 * Datatype facet: maximum value (exclusive). If not null, the
 * data value must be less than this value.
 */
XModelItem.prototype.maxExclusive = null;

/** 
 * Datatype facet: minimum value (inclusive). If not null, the
 * data value must be greater than or equal to this value.
 */
XModelItem.prototype.minInclusive = null;

/** 
 * Datatype facet: minimum value (exclusive). If not null, the
 * data value must be greater than or equal to this value.
 */
XModelItem.prototype.minExclusive = null;


XModelItem.prototype.getTotalDigits = function() { return this.totalDigits; }
XModelItem.prototype.getFractionDigits = function () 	{	return this.fractionDigits;			}
XModelItem.prototype.getMinInclusive = function () 			{	return this.minInclusive;				}
XModelItem.prototype.getMinExclusive = function() { return this.minExclusive; }
XModelItem.prototype.getMaxInclusive = function () 			{	return this.maxInclusive;				}
XModelItem.prototype.getMaxExclusive = function() { return this.maxExclusive; }

XModel.registerErrorMessage("notANumber",		 AjxMsg.notANumber);
XModel.registerErrorMessage("numberTotalExceeded", AjxMsg.numberTotalExceeded);
XModel.registerErrorMessage("numberFractionExceeded", AjxMsg.numberFractionExceeded);
XModel.registerErrorMessage("numberMoreThanMax", AjxMsg.numberMoreThanMax);
XModel.registerErrorMessage("numberMoreThanEqualMax", AjxMsg.numberMoreThanEqualMax);
XModel.registerErrorMessage("numberLessThanMin", AjxMsg.numberLessThanMin);
XModel.registerErrorMessage("numberLessThanEqualMin", AjxMsg.numberLessThanEqualMin);

XModelItem.prototype.validateNumber = function(value) {
	value = this._normalizeAndValidate(value);

	var nvalue = parseFloat(value);

	if (isNaN(nvalue) || !AjxUtil.FLOAT_RE.test(value)) {
		throw this.getModel().getErrorMessage("notANumber", value);
	}

	var totalDigits = this.getTotalDigits();
	if (this.totalDigits !== null) {
		var wholePart = Math.floor(nvalue);
		if (wholePart.toString().length > totalDigits) {
			throw this.getModel().getErrorMessage("numberTotalExceeded", value, totalDigits);
		}
	}

	var fractionDigits = this.getFractionDigits();
	if (this.fractionDigits !== null) {
		var fractionPart = String(nvalue - Math.floor(nvalue));
		if (fractionPart.indexOf('.') != -1 && fractionPart.replace(/^\d*\./,"").length > fractionDigits) {
			throw this.getModel().getErrorMessage("numberFractionExceeded", value, fractionDigits);
		}
	}

	var maxInclusive = this.getMaxInclusive();
	if (maxInclusive !== null && nvalue > maxInclusive) {
		throw this.getModel().getErrorMessage("numberMoreThanMax", maxInclusive);
	}
	
	var maxExclusive = this.getMaxExclusive();
	if (maxExclusive !== null && nvalue >= maxExclusive) {
		throw this.getModel().getErrorMessage("numberMoreThanEqualMax", maxExclusive);
	}

	var minInclusive = this.getMinInclusive();
	if (minInclusive !== null && nvalue < minInclusive) {
		throw this.getModel().getErrorMessage("numberLessThanMin",  minInclusive);
	}
	
	var minExclusive = this.getMinExclusive();
	if (minExclusive !== null && nvalue <= minExclusive) {
		throw this.getModel().getErrorMessage("numberLessThanEqualMin", minExclusive);
	}

	return value;
}




//
//	for validating dates and times
//

XModelItem.prototype.msecInOneDay = (1000 * 60 * 60 * 24);
XModel.registerErrorMessage("invalidDateString", AjxMsg.invalidDateString);

// methods
XModelItem.prototype.validateDate = function(value) {
	
	if (AjxUtil.isInstance(value, Date)) return value;
	if (AjxUtil.isString(value)) {
		value = value.toLowerCase();
		var date = new Date();

		if (value.indexOf("/") > -1) {
			value = value.split("/");
			if (value.length == 3) {
				var month = parseInt(value[0]);
				var day = parseInt(value[1]);
				var year = parseInt(value[2]);
				if (!isNaN(month) && !isNaN(day) && !isNaN(year)) {
					month -= 1;
					if (year < 1900) {
						if (year < 50) year += 2000;
						year += 1900;
					}
					date.setFullYear(year, month, day);
					date.setHours(0,0,0,0);
					return date;
				}
			}
		} else {
			// set to midnight today according to local time
			date.setHours(0,0,0,0);
			
			if (value == AjxMsg.today) {
				return date;
			} else if (value == AjxMsg.yesterday) {
				date.setTime(date.getTime() - this.msecInOneDay);
				return date;
			} else if (value == AjxMsg.tomorrow) {
				date.setTiem(date.getTime() + this.msecInOneDay);
				return date;
			}
		}
	}
	throw this.getModel().getErrorMessage("invalidDateString", value);
	return value;
}


XModel.registerErrorMessage("invalidTimeString",		 AjxMsg.invalidTimeString);
// time is returned as a number of milliseconds since
XModelItem.prototype.validateTime = function (value) {

	if (AjxUtil.isNumber(value)) return value;
	
	if (AjxUtil.isInstance(value, Date)) {
		return ((value.getHours() * 360) + (value.getMinutes() * 60) + value.getSeconds()) * 1000;
	}
	
	if (AjxUtil.isString(value)) {
		value = value.toLowerCase();
		if (value.indexOf(":") > -1) {
			value = value.split(":");

			var isPM = false;
			var lastPiece = value[value.length - 1];
			isPM = (lastPiece.indexOf(I18nMsg.periodPm.toLowerCase()) > -1);

			var hour = parseInt(value[0]);
			var min = parseInt(value[1]);
			var sec = (value.length == 3 ? parseInt(value[2]) : 0);
			if (!isNaN(hour) && !isNaN(min) && !isNaN(sec)) {
				hour -= 1;
				if (isPM && hour > 11) hour += 12;
				
				return ((hour * 360) + (min * 60) + sec) * 1000;
			}
		}
	}
	throw this.getModel().getErrorMessage("invalidTimeString", value);
}


XModel.registerErrorMessage("invalidDatetimeString",		 AjxMsg.invalidDatetimeString);
XModelItem.prototype.validateDateTime = function (value) {

	if (AjxUtil.isInstance(value, Date)) return value;
	if (AjxUtil.isNumber(value)) return value;
	if (AjxUtil.isString(value)) {
		// try to get the value as a date
		//  (this will ignore time fields, and will throw an exeception if we couldn't parse a date)
		var date = this.validateDate(value);
		
		// if it has a time component
		if (value.indexOf(":") > -1) {
			var time = value.split(" ")[1];
			// this will validate the time string and will throw an exception if it doesn't match
			time = this.validateTimeString(time);
			
			date.setTime(date.getTime() + time);
		}
		return date;
	}
	// probably should never get here...
	throw this.getModel().getErrorMessage("invalidDatetimeString", value);
}






//
//	XModelItem class: "string"
//
function String_XModelItem(){}
XModelItemFactory.createItemType("_STRING_", "string", String_XModelItem)
String_XModelItem.prototype.validateType = XModelItem.prototype.validateString;
String_XModelItem.prototype.getDefaultValue = function () {	return ""; };


//
//	XModelItem class: "number"
//
function Number_XModelItem(){}
XModelItemFactory.createItemType("_NUMBER_", "number", Number_XModelItem);
Number_XModelItem.prototype.validateType = XModelItem.prototype.validateNumber;
Number_XModelItem.prototype.getDefaultValue = function () {	return 0; };






//
//	XModelItem class: "date"
//
function Date_XModelItem(){}
XModelItemFactory.createItemType("_DATE_", "date", Date_XModelItem);
Date_XModelItem.prototype.validateType = XModelItem.prototype.validateDate;
Date_XModelItem.prototype.getDefaultValue = function () {	return new Date(); };




//
//	XModelItem class: "time"
//
function Time_XModelItem(){}
XModelItemFactory.createItemType("_TIME_", "time", Time_XModelItem);
Time_XModelItem.prototype.validateType = XModelItem.prototype.validateTime;
Time_XModelItem.prototype.getDefaultValue = function () {	return new Date(); };





//
//	XModelItem class: "datetime"
//
function Datetime_XModelItem(){}
XModelItemFactory.createItemType("_DATETIME_", "datetime", Datetime_XModelItem);
Datetime_XModelItem.prototype.validateType = XModelItem.prototype.validateDateTime;
Datetime_XModelItem.prototype.getDefaultValue = function () {	return new Date(); };





//
//	XModelItem class: "list"
//
function List_XModelItem(){}
XModelItemFactory.createItemType("_LIST_", "list", List_XModelItem);
List_XModelItem.prototype.getDefaultValue = function () {	return new Array(); };

// type defaults and accessors
List_XModelItem.prototype.outputType = _STRING_;	// 	_STRING_ == convert to a string
													//	_LIST_ == convert to an array
List_XModelItem.prototype.itemDelimiter = ",";		//	delimiter for converting string values to arrays

List_XModelItem.prototype.listItem = {type:_UNTYPED_};

List_XModelItem.prototype.getOutputType = function () 	{	return this.outputType;			}
List_XModelItem.prototype.getItemDelimiter = function() {	return this.itemDelimiter		}
List_XModelItem.prototype.getListItem = function () 	{	return this.listItem;			}



//	methods

List_XModelItem.prototype.initializeItems = function () {
	var listItem = this.listItem;
	listItem.ref = listItem.id = "#";	
	this.listItem = XModelItemFactory.createItem(listItem, this, this.getModel());
	this.listItem.initializeItems();
}


List_XModelItem.prototype.validateType = function (value) {
	return value;
//XXX REWORK THIS TO USE THE listItem MODEL ITEM FOR EACH SUB-ITEM
}








//
//	XModelItem class: "enum"
//
function Enum_XModelItem(){}
XModelItemFactory.createItemType("_ENUM_", "enum", Enum_XModelItem);
//XXXX
Enum_XModelItem.prototype.getDefaultValue = function () {	return this.choices[0]; };

Enum_XModelItem.prototype.getChoices = function()		 {		return this.choices;		}
Enum_XModelItem.prototype.getSelection = function() 	{		return this.selection;		}
XModel.registerErrorMessage("didNotMatchChoice",	AjxMsg.didNotMatchChoice);

Enum_XModelItem.prototype.validateType = function (value) {
	// if the selection is open, they can enter any value they want
	var selectionIsOpen = this.getSelection() == _OPEN_;
	if (selectionIsOpen) return value;
	
	// selection is not open: it must be one of the supplied choices
	var choices = this.getChoices();
	for (var i = 0; i < choices.length; i++) {
		var choice = choices[i];
		if (AjxUtil.isInstance(choice, Object)) {
			if (choice.value == value) return value;
		} else {
			if (choice == value) return value;
		}
	}
	
	// if we get here, we didn't match any of the choices
	throw this.getModel().getErrorMessage("didNotMatchChoice", value);
}

FileSize_XModelItem = function (){}
XModelItemFactory.createItemType("_FILE_SIZE_", "file_size", FileSize_XModelItem);
FileSize_XModelItem.prototype.validateType = XModelItem.prototype.validateNumber;
FileSize_XModelItem.prototype.getterScope = _MODELITEM_;
FileSize_XModelItem.prototype.setterScope = _MODELITEM_;
FileSize_XModelItem.prototype.getter = "getValue";
FileSize_XModelItem.prototype.setter = "setValue";
FileSize_XModelItem.prototype.units = AjxUtil.SIZE_MEGABYTES;
FileSize_XModelItem.prototype.minInclusive = 0;

FileSize_XModelItem.prototype.getValue =  function(instance, current, ref) {
	var value = eval("instance."+ref);
	return value ? AjxUtil.formatSizeForUnits(value, AjxUtil.SIZE_KILOBYTES, false, 2) : 0;
}

FileSize_XModelItem.prototype.setValue = function(value, instance, current, ref) {
	return eval("instance."+ref+" = AjxUtil.parseSize(value, this.units)");
}

HostNameOrIp_XModelItem = function() {}
XModelItemFactory.createItemType("_HOSTNAME_OR_IP_", "hostname_or_ip", HostNameOrIp_XModelItem);
HostNameOrIp_XModelItem.prototype.validateType = XModelItem.prototype.validateString;
HostNameOrIp_XModelItem.prototype.maxLength = 256;
HostNameOrIp_XModelItem.prototype.pattern = [ AjxUtil.HOST_NAME_RE, AjxUtil.IP_ADDRESS_RE,AjxUtil.HOST_NAME_WITH_PORT_RE ];

ShortURL_XModelItem = function() {}
XModelItemFactory.createItemType("_SHORT_URL_", "short_url", ShortURL_XModelItem);
ShortURL_XModelItem.prototype.validateType = XModelItem.prototype.validateString;
ShortURL_XModelItem.prototype.maxLength = 256;
ShortURL_XModelItem.prototype.pattern = [AjxUtil.SHORT_URL_RE,AjxUtil.IP_SHORT_URL_RE];

Port_XModelItem = function() {}
XModelItemFactory.createItemType("_PORT_", "port", Port_XModelItem);
Port_XModelItem.prototype.validateType = XModelItem.prototype.validateNumber;
Port_XModelItem.prototype.minInclusive = 0;
Port_XModelItem.prototype.maxInclusive = 65535;

Percent_XModelItem = function() {}
XModelItemFactory.createItemType("_PERCENT_", "percent", Percent_XModelItem);
Percent_XModelItem.prototype.validateType = XModelItem.prototype.validateNumber;
Percent_XModelItem.prototype.minInclusive = 0;
Percent_XModelItem.prototype.maxInclusive = 100;
/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


/**
* @constructor
* @class
* @param attributes
* @param model {XModel} {@link XModel}
* @param instance {Object} data instance
* @param dwtContainer - instance of {@link DwtComposite}
**/
function XForm(attributes, model, instance, dwtContainer) {
	if (attributes) {
		for (var prop in attributes) {
			this[prop] = attributes[prop];	
		}
	}

	// get a unique id for this form
	this.assignGlobalId(this, this.id || "_XForm");
	DwtComposite.call(this, dwtContainer, "DWTXForm");
	
	if (this.itemDefaults) {
		XFormItemFactory.initItemDefaults(this, this.itemDefaults);
	}

	// if they didn't pass in a model, make an empty one now
	if (model) {
		this.setModel(model);
	} else {
		this.xmodel = new XModel();
	}
	if (instance) this.setInstance(instance);

	this.__idIndex = {};
	this.__externalIdIndex = {};
	this.__itemsAreInitialized = false;
}
XForm.prototype = new DwtComposite;
XForm.prototype.constructor = XForm;

XForm.toString = function() {	return "[Class XForm]";	}
XForm.prototype.toString = function() {	return "[XForm " + this.__id + "]";	}
XForm.prototype.getId = function () {	return this.__id;	}

/**
* A global handler for setTimeout/clearTimeout. This handler is used by onKeyPress event of all input fields.
**/
XForm.keyPressDelayHdlr = null;


/**
* FORM DEFAULTS
**/
XForm.prototype.numCols = 2;
XForm.prototype.defaultItemType = "output";
XForm.prototype._isDirty = false;
XForm._showBorder = false;		// if true, we write a border around form cells for debugging

//
//	FORM CONSTANTS
//

// generic script constants
var _IGNORE_CACHE_ = "IGNORE_CACHE";
var _UNDEFINED_;

var _UNDEFINED_;
var _ALL_ = "all";

// possible values for "labelDirection", "align" and "valign"
var _NONE_ = "none";
var _LEFT_ = "left";
var _TOP_ = "top";
var _RIGHT_ = "right";
var _BOTTOM_ = "bottom";
var _CENTER_ = "center";
var _MIDDLE_ = "middle";
var _INLINE_ = "inline";


// values for "relevantBehavior"
var _HIDE_ = "hide";
var _BLOCK_HIDE_ = "block_hide";
var _DISABLE_ = "disable";
var _SHOW_DISABLED_ = "show_disabled";
var _PARENT_ = "parent"; // used in error location as well

// values for "errorLocation"
var _SELF_ = "self";
// var _INHERIT_ = "inherit" -- this is defined in XModel.js

// values for "selection"
var _OPEN_ = "open";
var _CLOSED_ = "closed";

// possible values for "overflow"
var _HIDDEN_ = "hidden";
var _SCROLL_ = "scroll";
var _AUTO_ = "auto";
var _VISIBLE_ = "visible";

/**
* update the form with new values
*  NOTE: this will be done automatically if you do a {@link #setInstance}
**/
XForm.prototype.refresh = function () {
	// EMC 07/31/2005 -- I don't think we want to clear errors on every refresh
	// since this is called from itemChanged.
	//this.clearErrors();
	this.updateScript();
}


// NOTE: THE FOLLOWING CODE SHOULD BE CONVERTED TO DWT 

XForm.prototype.getGlobalRefString = function() {
	return "XFG.cacheGet('" + this.__id + "')";
}

XForm.prototype.assignGlobalId = function (object, prefix) {
	return XFG.assignUniqueId(object, prefix);
}
XForm.prototype.getUniqueId = function (prefix) {
	return XFG.getUniqueId(prefix);
}

XForm.prototype.getElement = function (id) {
	if (id == null) id = this.getId();
	var el = XFG.getEl(id);
	if (el == null) DBG.println(AjxDebug.DBG2, "getElement(",id,"): no element found");
	return el;
}

XForm.prototype.showElement = function (id) {
	if (id == null) id = this.getId();
	return XFG.showEl(id);
}
XForm.prototype.hideElement = function (id,isBlock) {
	if (id == null) id = this.getId();
	return XFG.hideEl(id,isBlock);
}

XForm.prototype.createElement = function (id, parentEl, tagName, contents) {
	if (id == null) id = this.getId();
	return XFG.createEl(id, parentEl, tagName, contents);
}

// NOTE: END DWT CONVERSION NEEDED 

XForm.prototype.focusElement = function (id) {
	var el = this.getElement(id);
	// if this is a div we will have problems.
	if (el != null) {
		var tagName = el.tagName;
		if (tagName != "DIV" && tagName != "TD" && tagName != "TABLE") {
			el.focus();		//MOW: el.select() ????
			this.onFocus(id);
		}
	}
};

XForm.prototype.focusNext = function(id) {
	if(this.tabIdOrder && this.tabIdOrder.length > 0) {
		var cnt = this.tabIdOrder.length;
		if (id == null) {
			this.focusElement(this.tabIdOrder[0]);
		} else {
			for (var i = 0; i < cnt; i++) {
				if(this.tabIdOrder[i] == id) {
					if(this.tabIdOrder[i+1]) {
						this.focusElement(this.tabIdOrder[i+1]);
					} else {
						this.focusElement(this.tabIdOrder[0]);
					}
					break;
				}
			}
		}		
	}
};


XForm.prototype.getModel = function () {
	return this.xmodel;
}
XForm.prototype.setModel = function (model) {
	this.xmodel = model;
}



XForm.prototype.getInstance = function () {
	return this.instance;
}
XForm.prototype.setInstance = function(instance) {
	this.setIsDirty(false);
	this.clearErrors();
	this.instance = instance;
	if (this.__drawn) {
		this.refresh();
	}
}


XForm.prototype.getController = function () {
	return this.controller;
}
XForm.prototype.setController = function(controller) {
	this.controller = controller;
}




XForm.prototype.getIsDirty = function () {
	return this._isDirty;
}
XForm.prototype.setIsDirty = function(dirty, item) {
	this._isDirty = (dirty == true);
	//pass the current dirty XFORM item, so the event object can has the information which item is changed
	if (typeof item == "undefined") item = null ; //to make it compatible with the previous version. 
	this.notifyListeners(DwtEvent.XFORMS_FORM_DIRTY_CHANGE, new DwtXFormsEvent(this, item, this._isDirty));
}






XForm.prototype.initializeItems = function() {
	// tell the model to initialize all its items first
	//	(its smart enough to only do this once)
	this.xmodel.initializeItems();

	if (this.__itemsAreInitialized) return;
	
	// create a group for the outside parameters and initialize that
	// XXX SKIP THIS IF THERE IS ONLY ONE ITEM AND IT IS ALREADY A GROUP, SWITCH OR REPEAT???
	var outerGroup = {
		id:"__outer_group__",
		type:_GROUP_,
		useParentTable:false,

		numCols:this.numCols,
		colSizes:this.colSizes,
		items:this.items,
		tableCssClass:this.tableCssClass,
		tableCssStyle:this.tableCssStyle
	}
	this.items = this.initItemList([outerGroup]);
	
	// we wait to initialize items until the form is drawn, for speed

	this.__itemsAreInitialized = false;
}


XForm.prototype.initItemList = function(itemAttrs, parentItem) {
	var items = [];
	for (var i = 0; i < itemAttrs.length; i++) {
		var attr = itemAttrs[i];
		if (attr != null) {
			items.push(this.initItem(attr, parentItem));
		}
	}
	this.__nestedItemCount += itemAttrs.length;		//DEBUG
	return items;
}


XForm.prototype.initItem = function(itemAttr, parentItem) {
	// if we already have a form item, assume it's been initialized already!
	if (itemAttr._isXFormItem) return itemAttr;
	
	// create the XFormItem subclass from the item attributes passed in
	//	(also links to the model)
	var item = XFormItemFactory.createItem(itemAttr, parentItem, this);
	
	// have the item initialize it's sub-items, if necessary (may be recursive)
	item.initializeItems();
	return item;
}


// add an item to our index, so we can find it easily later
XForm.prototype.indexItem = function(item, id) {
	//DBG.println("id: "+id);
	this.__idIndex[id] = item;
	
	// Add the item to an existing array, or
	var exId = item.getExternalId();
	if (exId == null || exId == "") return;

	var arr = this.__externalIdIndex[exId];
	if (arr != null) {
		arr.push(item);
	} else {
		arr = [item];
	}
	this.__externalIdIndex[exId] = arr;
}


// refPath is ignored
// This is probably not useful to an Xforms client --
// use getItemsById instead.
XForm.prototype.getItemById = function(id) {
	if (id._isXFormItem) return id;
	return this.__idIndex[id];
}

// This is a method that can be called by an XForms client, but
// which doesn't have much internal use.
// gets an item by the id or the ref provided in the declaration
// This method returns an array, or null;
XForm.prototype.getItemsById = function (id) {
	return this.__externalIdIndex[id];
};

XForm.prototype.get = function(path) {
	if (path == null) return null;
	if (path._isXFormItem) path = path.getRefPath();
	return this.xmodel.getInstanceValue(this.instance, path);
}


XForm.prototype.isDrawn = function () {
	return (this.__drawn == true);
}

/**
 * EMC 7/12/2005: I didn't want the extra div that DwtControl writes,
 * since the xforms engine already has an outer div that we can use as 
 * container.
 */
XForm.prototype._replaceDwtContainer = function () {
	var myDiv = document.getElementById(this.__id);
	var dwtContainer = this.getHtmlElement();
	if (dwtContainer.parentNode) dwtContainer.parentNode.replaceChild(myDiv, dwtContainer);
	this._htmlElId = this.__id;
};

/**
* actually draw the form in the parentElement
* @param parentElement
* calls outputForm to generate all the form's HTML
**/
XForm.prototype.draw = function (parentElement) {
	this.initializeItems();
	
	// get the HTML output
	var formOutput = this.outputForm();
	
	if (parentElement == null) parentElement = this.getHtmlElement();
	// if a parentElement was passed, stick the HTML in there and call the scripts
	//	if not, you'll have call put HTML somewhere and call the scripts yourself
	if (parentElement) {
		parentElement.innerHTML = formOutput;

		this._replaceDwtContainer();
		if (this.instance != null) {
			// run the updateScript
			this.refresh();
//			setTimeout(this.getGlobalRef()+ ".refresh()", 1000);
		}
	}
	
	// notify any listeners that we're "ready"
	this.notifyListeners(DwtEvent.XFORMS_READY, new DwtXFormsEvent(this));
	
	// remember that we've been drawn
	this.__drawn = true;
	// and we're done!
}


XForm.prototype.getItems = function () {
	return this.items;
}

/**
* Prints out the form HTML
* calls outputItemList
**/
XForm.prototype.outputForm = function () {
	var t0 = new Date().getTime();
	
	var html = new AjxBuffer();			// holds the HTML output
	var items = this.getItems();
	var indent = "";
	
	html.append('<div id="', this.__id,'"',
				(this.cssClass != null && this.cssClass != '' ? ' class="' + this.cssClass + '"' : ""),
				(this.cssStyle != null && this.cssStyle != '' ? ' style="' + this.cssStyle + ';"' : ""),
				'>\r'
				);
	
	this._itemsToInsert = {};
	this._itemsToCleanup = [];

	var updateScript = new AjxBuffer();		// holds the script to populate values and show/hide elements based on relevant attibute
	
	DBG.timePt("starting outputItemList");
	// in initializeItems(), we guaranteed that there was a single outer item
	//	and that it is a group that sets certain properties that can be set at
	//	the form level.  Just output that (and it will output all children)

	// output the actual items of the form
	this.outputItemList(items[0].items, items[0], html, updateScript, indent, this.numCols);
	DBG.timePt("finished outputItemList");
	this.makeUpdateScript(updateScript);
	DBG.timePt("finished makeUpdateScript");
	html.append("\r</div id=\"", this.__id,"\">");

	// save the HTML in this.__html (for debugging and such)
	this.__HTMLOutput = html.toString();

	//DBG.println("outputForm() took " + (new Date().getTime() - t0) + " msec");

	return this.__HTMLOutput;
}

XForm.prototype.getOutstandingRowSpanCols = function (parentItem) {
	if (parentItem == null) return 0;
	var outstandingRowSpanCols = 0;
	var previousRowSpans = parentItem.__rowSpanItems;
	if (previousRowSpans) {
/*
		for (var i = 0; i < previousRowSpans.length; i++) {
			var previousItem = previousRowSpans[i];
			//DBG.println("outputing ", previousItem.__numDrawnCols," rowSpan columns for ", previousItem);
			outstandingRowSpanCols += previousItem.__numDrawnCols;

			previousItem.__numOutstandingRows -= 1;
			if ( previousItem.__numOutstandingRows == 0) {
				if (previousRowSpans.length == 1) {
					delete parentItem.__rowSpanItems;
				} else {
					parentItem.__rowSpanItems = [].concat(previousRowSpans.slice(0,i), previousRowSpans.slice(i+1));
				}
			}
		}
*/
		for (var i = previousRowSpans.length-1; i >= 0; i--) {
			var previousItem = previousRowSpans[i];
			//DBG.println("outputing ", previousItem.__numDrawnCols," rowSpan columns for ", previousItem);
			previousItem.__numOutstandingRows -= 1;
			if ( previousItem.__numOutstandingRows == 0) {
				if (previousRowSpans.length == 1) {
					delete parentItem.__rowSpanItems;
				} else {
					parentItem.__rowSpanItems.pop();
				}
			} else {
				outstandingRowSpanCols += previousItem.__numDrawnCols;			
			}
		}

	}
	return outstandingRowSpanCols;
}

/**
* This method will iterate through all the items (XFormItem) in the form and call outputMethod on each of them.
* @param items
* @param parentItem
* @param html
* @param updateScript
* @param indent
* @param numCols
* @param currentCol
* @param skipTable
**/
XForm.prototype.outputItemList = function (items, parentItem, html, updateScript, indent, numCols, currentCol, skipTable) {
	if (parentItem.outputHTMLStart) {
		parentItem.outputHTMLStart(html, updateScript, indent, currentCol);
	}
	var drawTable = (parentItem.getUseParentTable() == false && skipTable != true);
	if (drawTable) {
		var colSizes = parentItem.getColSizes();
		//XXX MOW: appending an elementDiv around the container if we need to style it
		var outerStyle = parentItem.getCssString();
		if (outerStyle != null && outerStyle != "") {
			parentItem.outputElementDivStart(html, updateScript, indent);
		}
		html.append(indent, "<table cellspacing=0 cellpadding=0 ", 
				(XForm._showBorder ? "border=1" : "border=0"),
				" id=\"", parentItem.getId(),"_table\" ", parentItem.getTableCssString(),">\r");
		if (colSizes != null) {
			html.append(indent, " <colgroup>\r");
			for (var i = 0; i < colSizes.length; i++) {
				var size = colSizes[i];
				if (size < 1) size = size * 100 + "%";
				html.append(indent, "<col width=", size, ">\r");
			}
			html.append(indent, "</colgroup>\r");
		}
		html.append(indent, "<tbody>\r");
	}

	numCols = Math.max(1, numCols);
	if (currentCol == null) currentCol = 0;
	//DBG.println("outputItemList: numCols:",numCols, " currentCol:", currentCol);


	for (var itemNum = 0; itemNum < items.length; itemNum++) {
		var item = items[itemNum];
		var isNestingItem = (item.getItems() != null);
		var itemUsesParentTable = (item.getUseParentTable() != false);
		
		item.__numDrawnCols = 0;

		// write the beginning of the update script
		//	(one of the routines below may want to modify it)
		item.outputUpdateScriptStart(html, updateScript, indent);

		var label = item.getLabel();
		var labelLocation = item.getLabelLocation();
		var showLabel = (label != null && (labelLocation == _LEFT_ || labelLocation == _RIGHT_));

		var colSpan = item.getColSpan();
		if (colSpan == "*") colSpan = Math.max(1, (numCols - currentCol));
		var rowSpan = item.getRowSpan();

		var totalItemCols = item.__numDrawnCols = parseInt(colSpan) + (showLabel ? 1 : 0);
		if (rowSpan > 1 && parentItem) {
			if (parentItem.__rowSpanItems == null) parentItem.__rowSpanItems  = [];
			parentItem.__rowSpanItems.push(item);
			item.__numOutstandingRows = rowSpan;
		}
		//DBG.println("rowSpan = " + rowSpan);
		if(currentCol==0)
			html.append(indent, "<tr>\r");
		
		// write the label to the left if desired
		if (label != null && labelLocation == _LEFT_) {
			//DBG.println("writing label");
			item.outputLabelCellHTML(html, updateScript, indent, rowSpan, labelLocation);
		}

		var writeElementDiv = item.getWriteElementDiv();
		var outputMethod = item.getOutputHTMLMethod();
		if (isNestingItem && itemUsesParentTable) {
			// actually write out the item
			if (outputMethod) outputMethod.call(item, html, updateScript, indent, currentCol);

		} else {

			// write the cell that contains the item 
			//	NOTE: this is currently also the container!
			item.outputContainerTDStartHTML(html, updateScript, indent, colSpan, rowSpan);
	
			// begin the element div, if required
			if (writeElementDiv) 	item.outputElementDivStart(html, updateScript, indent);
			
			// actually write out the item
			if (outputMethod) outputMethod.call(item, html, updateScript, indent, 0);

	
			// end the element div, if required
			if (writeElementDiv) 	item.outputElementDivEnd(html, updateScript, indent);
			
	
			// end the cell that contains the item
			item.outputContainerTDEndHTML(html, updateScript, indent);

		}

		currentCol += totalItemCols;

		// write the label to the right, if desired
		if (label != null && labelLocation == _RIGHT_) {
			//DBG.println("writing label");
			item.outputLabelCellHTML(html, updateScript, indent, rowSpan);
		}
		
		// now end the update script if necessary
		item.outputUpdateScriptEnd(html, updateScript, indent);

		if ( currentCol >= numCols) {
			html.append(indent, "</tr>\r");
			currentCol = this.getOutstandingRowSpanCols(parentItem);
			//DBG.println("creating new row:  currentCol is now ", currentCol, (currentCol > 0 ? " due to outstanding rowSpans" : ""));
		}

		// if the number of outstanding rows is the same as the number of columns we're to generate
		//	output an empty row for each
		while (currentCol >= numCols) {
			//DBG.println("outputting empty row because outstandingRowSpanCols >= numCols");
			html.append("</tr id='numCols'>");//\r<tr  id='numCols'>");
			currentCol = this.getOutstandingRowSpanCols(parentItem);
		}
	}
	
	
	if (drawTable) {
		html.append("\r", indent, indent,"</tbody></table>\r");
		if (outerStyle != null) {
			parentItem.outputElementDivEnd(html, updateScript, indent);
		}
	}

	if (parentItem.outputHTMLEnd) {
		parentItem.outputHTMLEnd(html, updateScript, indent, currentCol);
	}

}






//
//	NOTE: properties of individual items moved to XForm_item_properties.js
//


// CHANGE HANDLING


XForm.prototype.onFocus = function(id) {
	this.__focusObject = id;
}

XForm.prototype.onBlur = function(id) {
	this.__focusObject = null;
}

XForm.prototype.itemChanged = function (id, value, event) {
	var item = this.getItemById(id);
	if (item == null) return alert("Couldn't get item for " + id);	// EXCEPTION
	
	// tell the item that it's display is dirty so it might have to update
	item.dirtyDisplay();

	// validate value
	var modelItem = item.getModelItem();
	if (modelItem != null) {
		try {
			value = modelItem.validate(value, this, item, this.getInstance());
			item.clearError();
		}
		catch (message) {
			item.setError(message);
			var event = new DwtXFormsEvent(this, item, value);
			this.notifyListeners(DwtEvent.XFORMS_VALUE_ERROR, event);
			return;
		}
	}

	// if there is an onChange handler, call that
	var onChangeMethod = item.getOnChangeMethod();

	if (typeof onChangeMethod == "function") {
//		DBG.println("itemChanged(", item.ref, ").onChange = ", onChangeMethod);
		value = onChangeMethod.call(item, value, event, this);
	} else {
		item.setInstanceValue(value);
	}
	
	var event = new DwtXFormsEvent(this, item, value);
	this.notifyListeners(DwtEvent.XFORMS_VALUE_CHANGED, event);

	this.setIsDirty(true, item);
	this.refresh();
}


XForm.prototype.getItemsInErrorState = function () {
	if (this.__itemsInErrorState == null) {
		this.__itemsInErrorState = new Object();
		this.__itemsInErrorState.size = 0;
	}
	return this.__itemsInErrorState;
};

XForm.prototype.addErrorItem = function ( item ) {
	var errs = this.getItemsInErrorState();
	var oldItem = 	errs[item.getId()];
	errs[item.getId()] = item;
	if (oldItem == null){
		errs.size++;
	}
};

XForm.prototype.removeErrorItem = function ( item ) {
	if (item != null) {
		var errs = this.getItemsInErrorState();
		var id = item.getId();
		var oldItem = errs[id];
		if (oldItem != null) {
			delete errs[id];
			errs.size--;
		}
	}
};

XForm.prototype.hasErrors = function () {
	var errs = this.getItemsInErrorState();
	return (errs != null && errs.size > 0);
};

XForm.prototype.clearErrors = function () {
	var errs = this.getItemsInErrorState();
	if (errs.size > 0) {
		var k;
		for (k in errs) {
			if (k == 'size') continue;
			errs[k].clearError();
			delete errs[k];
		}
		errs.size = 0;
	}
}

XForm.prototype.onCloseForm = function () {
	if (this.__focusObject != null) {
		var item = this.getItemById(this.__focusObject);
		var element = item.getElement();

//alert("onCloseForm() not implemented");
//		this.itemChanged(this.__focusObject, VALUE???)
		if (element && element.blur) {
			element.blur();
		}
		this.__focusObject = null;
	}
}




//
//	SCRIPTS:
//		* updateScript -- sets values of items in the HTML representation 
//	-- CALLED REPEATEDLY: ON INITIAL DISPLAY AND EVERY TIME AN ITEM CHANGES



XForm.prototype.makeUpdateScript = function (script) {
	if (typeof script != "string") script = script.toString();
	this.__updateScript = script;
	this.updateScript = new Function(
			(this.updateScriptStart != null ? this.updateScriptStart + ";" : '')
			+ this.getUpdateScriptStart() 
			+ script 
			+ this.getUpdateScriptEnd()
			+ (this.updateScriptEnd  != null ?  this.updateScriptEnd + ";" : '')
		);
}


XForm.prototype.appendToUpdateScript = function (script) {
	if (typeof script != "string") script = script.toString();
	this.makeUpdateScript(this.__updateScript + script);
}






//
//	Writing parts of the update script
//

XForm.prototype.getUpdateScriptStart = function () {
	return AjxBuffer.concat(	
			"var t0 = new Date().getTime();\r",
			
			"var updateScript;\r",
			"var _____________________________________________________ = 0;\r",
			"var form = this;\r",
			"var model = this.xmodel;\r",
			"var instance = this.instance;\r",
			"var item, itemId, element, relevant, value, temp;\r",
			"this.tabIdOrder = new Array();\r",
			"with (this) {"
	);
}


XForm.prototype.getUpdateScriptEnd = function () {
	return AjxBuffer.concat(	
			"_____________________________________________________++;\r",
			"}\r",	// end with (this)
			"var event = new DwtXFormsEvent(form);\r",
			"this.notifyListeners(DwtEvent.XFORMS_DISPLAY_UPDATED, event);\r",

			"var t1 = new Date().getTime();\r",
			"DBG.println('update script took ' + (t1 - t0) + ' msec.');\r"
	);
}




/** @private */
XForm.prototype._reparentDwtObject = function (dwtObj, newParent) {
	var dwtE = dwtObj.getHtmlElement();
	if (dwtE.parentNode) dwtE.parentNode.removeChild(dwtE);
	newParent.appendChild(dwtE);
}





//
//	INSERTING
//



XForm.prototype.shouldInsertItem = function (item) {
	return (this._itemsToInsert[item.getId()] != null)
}

XForm.prototype.insertExternalWidget = function (item) {
	DBG.println("insertExternalWidget(): inserting ref=", item.ref,
				 "  type=", item.type, " id=", item.getId()
	);
			 
	var insertMethod = item.getInsertMethod();

	var widget = item.getWidget();
	if (widget && widget.insertIntoXForm instanceof Function) {
		widget.insertIntoXForm(this, item, item.getElement());
		
	} else if (typeof this[insertMethod] == "function") {
		this[insertMethod](item, item.getElement());
		
	} else {
		DBG.println("insertExternalWidget(): don't know how to insert item ", item.ref,
			 "  type=", item.type);
	}

	// take the item out of the list to insert so we don't insert it more than once
	delete this._itemsToInsert[item.getId()];
}

/*
 * Copyright (C) 2006, The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


//
//	Factory to create XFormItems from simple attributes (eg: from JS object literals or XML)
//

/** This object is never instantiated. */
function XFormItemFactory() {}

/**
 * Creates a form item.
 *
 * @param attributes An object whose properties map to component attribute
 *                   name/value pairs.
 * @param parentItem The parent item of this item.
 * @param xform      The form to which this item is being created.
 */
XFormItemFactory.createItem = function (attributes, parentItem, xform) {
	// assign a modelItem to the item
	var refPath = this.getRefPath(attributes, parentItem);

	var modelItem;
	if (refPath != null) {
		// assign a modelItem to the item
		modelItem = this.getModelItem(xform.xmodel, attributes, refPath);
	}
			
	// get the class for that type and create one
	var type = this.getItemType(attributes, modelItem);
	var constructor = this.getItemTypeConstructor(type, xform);

	var item = new constructor();
	item._setAttributes(attributes);

	// get a unique id for the item
	var idPrefix = (	attributes.id ? xform.getId() + "_" + attributes.id :
							  refPath ? xform.getId() + "_" + refPath :
					item.__parentItem ? item.__parentItem.getId() :
										xform.getId() + "_" + item.type
					);
	// assign a unique id to each item
	//	(if the item specifies an id, we use a variant of that, just in case there's more than one)
	item.id = xform.getUniqueId(idPrefix);

	item.refPath = refPath;
	item.__modelItem = modelItem;
	item.__xform = xform;
	item.__parentItem = parentItem;
	
	// assign the item into our form's index so we can be found later
	xform.indexItem(item, item.id);

	// tell the item to initialize any special properties it needs to on construction
	item.initFormItem();
	
	return item;
} 

XFormItemFactory.getRefPath = function (attributes, parentItem) {
	if (attributes.refPath) return attributes.refPath;
	
	var ref = attributes.ref;
	if (ref == null) return null;
	
	if (parentItem) {
		var parentPath = parentItem.getRefPath();
		if (parentPath == null) parentPath = "";
	} else {
		var parentPath = "";
	}
	
	var path = ref;
	if (ref == ".") {
		path = parentPath;

	} else if (ref == "..") {
		parentPath = parentPath.split("/");
		path = parentPath.slice(0, parentPath.length - 1).join("/");

	} else if (parentPath == "") {
		path = ref;

	} else {
		path = parentPath + "/" + ref;
	}
	return path;
}

XFormItemFactory.getModelItem = function (xmodel, attributes, refPath) {
	if (refPath == null || refPath == "") return null;
	return xmodel.getItem(refPath, true);
}

XFormItemFactory.getItemType = function (attributes, modelItem) {
	var type = attributes.type;

	if (type == null) {
		type = attributes.type = _OUTPUT_;
	}
	
	var modelType = (modelItem && modelItem.type ? modelItem.type : _STRING_);

	if (type == _INPUT_) {
		if (attributes.value !== _UNDEFINED_) {
			type = _CHECKBOX_;
		} else {
			switch (modelType) {
				case _STRING_:
				case _NUMBER_:
					type = _INPUT_;
					break;

				case _DATE_:
				case _DATETIME_:
				case _TIME_:
					type = modelType;			
					break;

				default:
					type = _INPUT_;
			}
		}
	} else if (type == _SELECT_) {
		var appearance = attributes.appearance;
		if (appearance == _RADIO_) {
			type = _RADIO_;
		} else {
			type = _SELECT_;
		}
	}
	return type;
}

XFormItemFactory.typeConstructorMap = {};

XFormItemFactory.createItemType = 
function (typeConstant, typeName, constructor, superClassConstructor) {
	if (constructor == null) constructor = new Function();
	if (typeof superClassConstructor == "string") superClassConstructor = this.getItemTypeConstructor(superClassConstructor);
	if (superClassConstructor == null) superClassConstructor = XFormItem;

	// initialize the constructor
	constructor.prototype = new superClassConstructor();	

	constructor.prototype.type = typeName;
	constructor.prototype.constructor = constructor;
	constructor.prototype.toString = new Function("return '[XFormItem:" + typeName + " ' + this.getId() + ']'");
	constructor.toString = new Function("return '[Class XFormItem:" + typeName + "]'");
	
	// put the item type into the typemap
	this.registerItemType(typeConstant, typeName, constructor);
	
	// return the prototype
	return constructor;
}

XFormItemFactory.registerItemType = 
function(typeConstant, typeName, constructor) {
	// assign the type constant to the window so everyone else can use it
	window[typeConstant] = typeName;
	this.typeConstructorMap[typeName] = constructor;	
}

XFormItemFactory.defaultItemType = "output";
XFormItemFactory.getItemTypeConstructor = 
function (typeName, form) {
	var typeConstructorMap = (form && form.typeConstructorMap ? form.typeConstructorMap : this.typeConstructorMap);
	
	var typeConstructor = typeConstructorMap[typeName];
	if (typeConstructor == null) {
		var defaultItemType = (form ? form.defaultItemType : this.defaultItemType);
		typeConstructorMap[defaultItemType];
	}
	return typeConstructor;
}

XFormItemFactory.quickClone = 
function(object) {
	this.cloner.prototype = object;
	return new this.cloner();
}
XFormItemFactory.cloner = function(){}

XFormItemFactory.initItemDefaults = function(form, itemDefaults) {
	// create a clone of the XFormItemFactory typeConstructorMap for the form
	form.typeConstructorMap =  this.quickClone(this.typeConstructorMap);

	if (itemDefaults == null) itemDefaults = form.itemDefaults;
	if (itemDefaults != null) {
		// for each type in itemDefaults
		for (var type in itemDefaults) {
			var originalConstructor = this.typeConstructorMap[type];
			var defaults = itemDefaults[type];

			if (originalConstructor == null) {
				type = window[type];
				originalConstructor = this.typeConstructorMap[type];
			}
			if (originalConstructor == null) {
				continue;
			}
			var newConstructor = form.typeConstructorMap[type] = new Function();
			newConstructor.prototype = new originalConstructor();
			// NOTE: reassigning the constructor here is technically correct,
			//		but will result in (item.constructor == originalClass.constructor) not working...
			newConstructor.prototype.constructor = newConstructor;
			
			for (var prop in defaults) {
				newConstructor.prototype[prop] = defaults[prop];
			}
		}
	}
}




//
//	Abstract Class XFormItem
//
//	All other form item classes inherit from this.
//




function XFormItem() {}
XFormItem.prototype.constructor = XFormItem;
XFormItemFactory.registerItemType("_FORM_ITEM_", "form_item", XFormItem);

XFormItem.ERROR_STATE_ERROR = 0;
XFormItem.ERROR_STATE_VALID = 1;


//
// set base class defaults
// 

XFormItem.prototype._isXFormItem = true;

// outputting and inserting
XFormItem.prototype.writeElementDiv = false;

// appearance
XFormItem.prototype.labelLocation = _LEFT_;
XFormItem.prototype.tableCssClass = "xform_table";				// table that encloses one or more cells
XFormItem.prototype.tableCssStyle = null;						// table that encloses one or more cells
XFormItem.prototype.containerCssClass =  "xform_container";		// td that contains the element
XFormItem.prototype.containerCssStyle =  null;					// td that contains the element
XFormItem.prototype.cssClass = null;							// element itself (or element div)
XFormItem.prototype.labelCssClass =  "xform_label";				// label td
XFormItem.prototype.errorCssClass =  "xform_error";				// error DIV
XFormItem.prototype.nowrap = false; 
XFormItem.prototype.labelWrap = false; 
XFormItem.prototype.align = _UNDEFINED_;						// _UNDEFINED_ because it's a bit faster to draw
XFormItem.prototype.valign = _UNDEFINED_;						// _UNDEFINED_ because it's a bit faster to draw
XFormItem.prototype.focusable = false;

// updating
XFormItem.prototype.forceUpdate = false;			// SET TO true TO FORCE AN ITEM TO UPDATE, EVEN IF VALUE HAS NOT CHANGED
XFormItem.prototype.relevant;
XFormItem.prototype.relevantIfEmpty = true;
XFormItem.prototype.relevantBehavior = _HIDE_;		//	_HIDE_, _DISABLE_


// changing/saving
XFormItem.prototype.elementChangeHandler = "onchange";


// choices map
XFormItem.prototype.selection = _CLOSED_;
XFormItem.prototype.openSelectionLabel = "";

// error handling
XFormItem.prototype.errorLocation = _SELF_;

//
// Methods
//


// set the initializing attributes of this firm
XFormItem.prototype._setAttributes = function (attributes) {
	this.__attributes = attributes;
}

// override this to do any item initialization you need to do
//	NOTE: this is called AFTER the formItem is initiaized with its modelItem, set in its form, etc
XFormItem.prototype.initFormItem = function() {
	window.status = '';
}	

// DEFAULT IMPLEMENTATION calls this.getForm().initItemList() on our items array
//	SOME CLASSES MAY NOT WANT TO DO THIS (eg: _REPEAT_, which does this dynamically later)
XFormItem.prototype.initializeItems = function () {
	var items = this.getItems();
	if (items != null) {
		this.items = this.getForm().initItemList(items, this);
	}
}


// error handling

/**
 * Sets the error message for this form item.
 * This will set the error for this item, or 
 * useing the errorLocation, follow the chain up,
 * to set the error on the related item.
 *
 * @param message The message to display. This message should already
 *                be localized.
 */
XFormItem.prototype.setError = function(message, childError) {
	var errLoc = this.getErrorLocation();
	if (errLoc == _PARENT_ || errLoc == _INHERIT_){
		this.getParentItem().setError(message, true);
		return;
	}
	this.getForm().addErrorItem(this);
	this.__errorState = XFormItem.ERROR_STATE_ERROR;
	var container = this.getErrorContainer(true);
	if (container) container.innerHTML = message;
};

/** 
 * Clears the error message for this form item. 
 * This will clear the error for this item, or 
 * useing the errorLocation, follow the chain up,
 * to clear the error on the related item.
 */
XFormItem.prototype.clearError = function() {
	var errLoc = this.getErrorLocation();
	if (errLoc == _PARENT_ || errLoc == _INHERIT_){
		this.getParentItem().clearError();
		return;
	}

	this.getForm().removeErrorItem(this);
	this.__errorState = XFormItem.ERROR_STATE_VALID;
	this.removeErrorContainer();
};

XFormItem.prototype.hasError = function () {
	return (this.__errorState == XFormItem.ERROR_STATE_ERROR);
};

XFormItem.prototype.getErrorContainer = function(createIfNecessary) {
	var container = this.getElement(this.getId() + "___error_container");
	if (container != null) return container;
	
	if (createIfNecessary == true && this.getContainer()) {
		return this.createErrorContainer();
	}
	return null;
}

XFormItem.prototype.createErrorContainer = function () {
	// output an error container
	var errorContainer = document.createElement("div");
	errorContainer.id = this.getId() + "___error_container";
	errorContainer.className = this.getErrorCssClass();

	var container = this.getContainer();
	if (container.hasChildNodes()) {
		container.insertBefore(errorContainer, container.firstChild);
	} else {
		container.appendChild(errorContainer);
	}	
	return errorContainer;
}

XFormItem.prototype.removeErrorContainer = function () {
	var errorContainer = this.getErrorContainer();
	if (errorContainer != null) {
		errorContainer.parentNode.removeChild(errorContainer);
	}
}


//
// PROPERTIES OF INDIVIDUAL ITEMS
//


XFormItem.prototype.getType = function () {
	return this.type;
}


//XXX
XFormItem.prototype.getParentItem = function () {
	return this.__parentItem;
}

XFormItem.prototype.getForm = function () {
	return this.__xform;
}

XFormItem.prototype.getGlobalRef = function() {
	return this.getForm().getGlobalRefString() + ".getItemById('" + this.getId() + "')";
}

XFormItem.prototype.getFormGlobalRef = function() {
	return this.getForm().getGlobalRefString();
}

XFormItem.prototype.getInstance = function() {
	return this.getForm().instance;
}

XFormItem.prototype.getModel = function () {
	return this.getForm().getModel();
}


XFormItem.prototype.getFormController = function () {
	return this.getForm().getController();
}


XFormItem.prototype.getModelItem = function() {
	return this.__modelItem;
}

//XXX NON-STANDARD
XFormItem.prototype.getRef = function () {
	if (this.ref !== _UNDEFINED_) return this.ref;
	return this.__attributes.ref;
}


XFormItem.prototype.getRefPath = function () {
	return this.refPath;
}

XFormItem.prototype.getId = function () {
	return this.id;
}

XFormItem.prototype.getExternalId = function () {
	var ret = null;
	if (this.__attributes.id !== _UNDEFINED_) {
		ret = this.__attributes.id;
	} else if ( (ret = this.getRef()) !== _UNDEFINED_) {
		// nothing
	} else {
		ret = null;
	}
	return ret;
};



//
//	GENERIC HTML WRITING ROUTINES
//


XFormItem.prototype.getOnChangeMethod = function() {
	return this.cacheInheritedMethod("onChange","$onChange","value,event,form");
}

XFormItem.prototype.getOnActivateMethod = function() {
	return this.cacheInheritedMethod("onActivate","$onActivate","event");
}

XFormItem.prototype.getExternalChangeHandler = function() {
	return "var item = " + this.getGlobalRef() + "; item.$elementChanged(value, item.getInstanceValue(), event||window.event);";
}
XFormItem.prototype.getElementValueGetterHTML = function () {
	return "var value = this.value;";
}

/**
* returns the HTML part of an <input > element that is used to set "onchange" 
* (or whatever is defined by elementChangehandler)  property of the element
**/
XFormItem.prototype.getChangeHandlerHTML = function() {
	var elementChangeHandler = this.getElementChangeHandler();
	if (elementChangeHandler != "onkeypress") {
		return AjxBuffer.concat(" ", elementChangeHandler, "=\"", this.getChangehandlerJSCode() + "\"",this.getKeyPressHandlerHTML());
	} else {
		return this.getKeyPressHandlerHTML();
	}
}

/**
* returns JavaScript code that should be executed when an element is changed by a user
* @author Greg Solovyev
**/
XFormItem.prototype.getChangehandlerJSCode = function () {
	return AjxBuffer.concat(this.getElementValueGetterHTML(),this.getExternalChangeHandler());
}

XFormItem.prototype.getFocusHandlerHTML = function () {
	var formId = this.getFormGlobalRef(),
		itemId = this.getId()
	;
	return AjxBuffer.concat(
		" onfocus=\"", formId, ".onFocus('", itemId, "')\"",
		" onblur=\"", formId, ".onBlur('", itemId, "')\""
	);
}


XFormItem.prototype.getOnActivateHandlerHTML = function() {
	var method = this.getOnActivateMethod();
	if (method == null) return "";
	
	return AjxBuffer.concat(
			" ", this.getElementChangeHandler(), "=\"", 
			this.getGlobalRef(),".$onActivate(event||window.event)\""
		);
}


/**
* Schedules {@link #handleKeyPressDelay} to fire later when the user finishes typing
* @param ev - "onkeypress" event 
* @param domItem - HTML form element
* @author Greg Solovyev
**/
XFormItem.prototype.handleKeyUp = function (ev, domItem) {
	// don't fire off another if we've already set one up.
	if (this.keyPressDelayHdlr != null) {
		AjxTimedAction.cancelAction(this.keyPressDelayHdlr);
		XForm.keyPressDelayHdlr = null;
	}
	var form = this.getForm();
	var evt = new DwtKeyEvent();
	evt.setFromDhtmlEvent(ev);
//	ev = ev ? ev : window.event;
	var key = DwtKeyEvent.getCharCode(ev);
	if (key == DwtKeyEvent.KEY_TAB) {
		DwtUiEvent.setBehaviour(ev, true, false);
		return false;
	}	
	var action = new AjxTimedAction(this, this.handleKeyPressDelay, [evt, domItem]);
	//XForm.keyPressDelayHdlr = setTimeout(XForm.handleKeyPressDelay, 250, item, ev, formItem);
	this.keyPressDelayHdlr = AjxTimedAction.scheduleAction(action, 250);
};

XFormItem.prototype.handleKeyDown = function (ev, domItem) {
	ev = (ev != null)? ev: window.event;
	var key = DwtKeyEvent.getCharCode(ev);
	if (key == DwtKeyEvent.KEY_ENTER) {
		// By telling the browser just to let this do the default, and 
		// not let the event bubble, our keyup handler
		// wil see the enter key.
		DwtUiEvent.setBehaviour(ev, true, true);
		return false;
	} else if (key == DwtKeyEvent.KEY_TAB) {
		DwtUiEvent.setBehaviour(ev, true, false);
		this.getForm().focusNext(this.getId());
		return false;
	}
	return true;
};

/**
* Implements delayed handling of "keypress" event. 
* Calls change handler script on the item.
* See {@link XFormItem.#getChangehandlerJSCode} for change handler script.

**/
XFormItem.prototype.handleKeyPressDelay = function(ev, domItem) {	
	this.keyPressDelayHdlr = null;
	if (this.$changeHandlerFunc == null) {
		var JSCode = this.getChangehandlerJSCode();
		this.$changeHandlerFunc = new Function("event", JSCode);
	}
	if (this.$changeHandlerFunc) {
		this.$changeHandlerFunc.call(domItem, ev);
	}
};

XFormItem.prototype.getKeyPressHandlerHTML = function () {

	var keydownEv = "onkeydown";
	if (AjxEnv.isNav) {
		keydownEv = "onkeypress";
	}
	return AjxBuffer.concat(" ", keydownEv,"=\"",this.getGlobalRef(), ".handleKeyDown(event, this)\"",
						   " onkeyup=\"", this.getGlobalRef(), ".handleKeyUp(event, this)\"");
};


//
//	container
//


XFormItem.prototype.outputContainerTDStartHTML = function (html, updateScript, indent, colSpan, rowSpan) {
	html.append(indent, "<td id=\"",  this.getId(), "___container\"",
					(colSpan > 1 ? " colspan=" + colSpan : ""),
					(rowSpan > 1 ? " rowspan=" + rowSpan : ""),
					this.getContainerCssString(), 
					">\r"
	);
} 

XFormItem.prototype.outputContainerTDEndHTML = function (html, updateScript, indent) {
	html.append("\r", indent, "</td id=\"",  this.getId(), "___container\">\r");
} 


//
//	element div
//
// for items that are effectively elements (or are drawn by something other than this form)
// NOTE: you can pass in any random CSS properties you want in cssStyle
XFormItem.prototype.outputElementDivStart = function (html, updateScript, indent) {
	html.append(indent, "<div id=", this.getId(), this.getCssString(), " xform_type='elementDiv'>\r");
}

XFormItem.prototype.outputElementDivEnd = function (html, updateScript, indent) {
	html.append("\r", indent, "</div id=\"", this.getId(), "\">");
}

//
//	label td
//
XFormItem.prototype.outputLabelCellHTML = function (html, updateScript, indent, rowSpan, labelLocation) {
	var label = this.getLabel();
	if (label == null) return;
	
	if (label == "") label = "&nbsp;";
	
	if (labelLocation == _INLINE_) {
		var style = this.getLabelCssStyle();
		if (style == null) style = "";
		style = "position:relative;left:10;top:5;text-align:left;background-color:#eeeeee;margin-left:5px;margin-right:5px;" + style;
		html.append(indent, "<div id=\"", this.getId(),"___label\"", 
								this.getLabelCssString(null, style), ">",
								label,
							"</div>"
					);
	} else {
		html.append(indent, "<td id=\"", this.getId(),"___label\"", 
								this.getLabelCssString(), 
								(rowSpan > 1 ? " rowspan=" + rowSpan : ""), ">", 
								label
		);
		if (this.getRequired()) {
			html.append("<span class='redAsteric'>*</span>");
		}
		html.append("</td>\r");
	}


}



//
//	update script
//
XFormItem.prototype.outputUpdateScriptStart = function (html, updateScript, indent) {
	// we need to always call these, so they're set up for items with or without "ref" properties
	var updateElementMethod = this.getUpdateElementMethod();
	var elementChangedMethod = this.getElementChangedMethod();
	var getDisplayValueMethod = this.getDisplayValueMethod();

//TODO: take the script they want to place, do a regex look for the variables below and only include the ones they care about!
	var forceUpdate = this.getForceUpdate();
	var relevant = this.getRelevant();
	var relevantIfEmpty = this.getRelevantIfEmpty();
	
	var parentRequiresRelevantCheck = (this.__parentItem ? (this.__parentItem._childRelevantCheckRequired == true) : false);
	if (	forceUpdate == false 
			&& this.refPath == null 
			&& relevant == null 
			&& relevantIfEmpty == true
			&& parentRequiresRelevantCheck == false
			&& typeof this.insertElement != "function"
		) return;




	/*updateScript.append(
			// first line is to separate out each item
			"_____________________________________________________++;\r",
			"item = form.getItemById('", this.getId(),"', '", this.getRefPath(), "');\r"
	);*/
	updateScript.append(
			// first line is to separate out each item
			"_____________________________________________________++;\r",
			"item = form.getItemById('", this.getId(),"');\r"
	);

	// if there is a relevant attribute, 
	//		get whether or not this item is relevant, and
	//		write a script that will show or hide the container element
	//
	//	NOTE: we leave the script dangling in the "if relevant" clause, 
	//			and close the if clause in writeUpdateScriptEnd().
	//		It is the job  of each individual outputter to write script that will
	//		update the value of the element (or subelements, etc) during the updateScript.
	//		The can be assured that it will only be called when it is relevant, and
	//		can access the following variables:
	//			value = new value to show
	//			element = DOM element of the 'control' itself (INPUT, SELECT, whatever a custom outputter gave us)
	//			itemId = (often internally generated) ID for the control
	//			ref = ref for the control (in the XForm, not the model)
	//			container = DOM element of the DIV container of the control
	//
	if (relevant != null || relevantIfEmpty == false || parentRequiresRelevantCheck) {
		if (relevantIfEmpty == false) {
			if (relevant == null) {
				relevant = "get(item) != null";
			} else {
				relevant = "get(item) != null && (" + relevant + ")";
			}
		}
		if (parentRequiresRelevantCheck) {
			if (relevant == null) {
				relevant = "item.__parentItem.__isRelevant";
			} else {
				relevant = "item.__parentItem.__isRelevant && (" + relevant + ")";
			}
		}
		updateScript.append(
			"relevant = (", relevant, ");\r",
			"item.__isRelevant = (relevant == true);\r"
		);
			
		var relevantBehavior = this.getRelevantBehavior();
		if (relevantBehavior == _HIDE_ ) {
			this._endRelevantClause = true;
			updateScript.append(
				"if (!item.__isRelevant) {\r",
					"item.hide(false);\r",
				"} else {\r  ");
			if (this.focusable) {
				updateScript.append(
// 					"DBG.println(AjxDebug.DBG1, \"Adding item ", this.getId(), " to the tabIdOrder \");\r",
					"item.getForm().tabIdOrder.push(item.getId());\r"
				);
			}
			updateScript.append("item.show();\r");
		} else if (relevantBehavior == _BLOCK_HIDE_) {
			this._endRelevantClause = true;
			updateScript.append(
				"if (!item.__isRelevant) {\r",
					"item.hide(true);\r",
				"} else {\r  ");
			if (this.focusable) {
				updateScript.append(
// 					"DBG.println(AjxDebug.DBG1, \"Adding item ", this.getId(), " to the tabIdOrder \");\r",
					"item.getForm().tabIdOrder.push(item.getId());\r"
				);
			}
			updateScript.append("item.show();\r");
		} else if (relevantBehavior == _DISABLE_) {
			this._endRelevantClause = false;
			this._childRelevantCheckRequired = true;
			updateScript.append(
				"if (!item.__isRelevant) {\r",
					"item.disableElement();\r",
				"} else {\r  ");
			if (this.focusable) {
				updateScript.append(
// 					"DBG.println(AjxDebug.DBG1, \"Adding item ", this.getId(), " to the tabIdOrder \");\r",
					"item.getForm().tabIdOrder.push(item.getId());\r"
				);
			}
			updateScript.append(
					"item.enableElement();\r",
				"}\r"//,
			);		
		}
	} else {
		if (this.focusable) {
			updateScript.append(
// 				"DBG.println(AjxDebug.DBG1, \"Adding item ", this.getId(), " to the tabIdOrder \");\r",
				"item.getForm().tabIdOrder.push(item.getId());\r"
			);
		}
	}

	// if the item should be inserted after drawing, do that now
	//	(note: this means that hidden elements won't be inserted until they're relevant)
	if (typeof this.insertElement == "function") {
		updateScript.append("item.insertElement();\r");
	}

	// if we should update the element, call that now.
	// NOTE: by default, we only update values that have changed since the last time
	//	the form items was updated.  To turn this off, set "forceUpdate:true" in a particular item.
	//
	if ((this.refPath || forceUpdate) && (updateElementMethod)) {
		updateScript.append(
			"if (!item.hasError()){\r",
				"value = ", (this.refPath ? 
							 "model.getInstanceValue(instance, item.refPath)" 
							 : "null"
							 ), ";\r",
			(getDisplayValueMethod != null? "value = item.$getDisplayValue(value);\r" : "")
		);

		if (forceUpdate != true) {
			updateScript.append(
				"var valueStr='';\r",
				"try {\r",
					"valueStr = ''+String(value);\r",
				"} catch (ex) {}\r",
				"if (item.$lastDisplayValue != valueStr) {\r  ",
					"item.$updateElement(value);\r",
					"item.$lastDisplayValue = valueStr;\r",
				"}\r"
			);
		} else {
			updateScript.append(
				"item.$updateElement(value);\r"
			);
		}
		updateScript.append("}\r");
	}
}


XFormItem.prototype.outputUpdateScriptEnd = function (html, updateScript, indent) {
	if (this._endRelevantClause) {
		updateScript.append("\r}\r");
		delete this._endRelevantClause;
	}
}


//
//	change handling
//

XFormItem.prototype.elementChanged = function(elementValue, instanceValue, event) {
	this.getForm().itemChanged(this.getId(), elementValue, event);
}







//
//	get and set instance values!
//


XFormItem.prototype.getInstanceValue = function (path) {
	if (path == null) path = this.getRefPath();
	if (path == null) return null;
	return this.getModel().getInstanceValue(this.getInstance(), path);
}

//NOTE: model.getInstance() gets count of PARENT
XFormItem.prototype.getInstanceCount = function () {
	if (this.getRefPath() == null) return 0;
	return this.getModel().getInstanceCount(this.getInstance(), this.getRefPath());
}

XFormItem.prototype.setInstanceValue = function (value, path) {
	if (path == null) path = this.getRefPath();
	if (path == null) return null;
	return this.getModel().setInstanceValue(this.getInstance(), path, value);
}
XFormItem.prototype.set = XFormItem.prototype.setInstancevalue;

XFormItem.getValueFromHTMLSelect = function (element) {
	var values = [];
	for (var i = 0; i < element.options.length; i++) {
		if (element.options[i].selected) {
			values[values.length] = element.options[i].value;	
		}
	}
	return values.join(",");
}

XFormItem.prototype.getValueFromHTMLSelect = function(element) {
	if (element == null) element = this.getElement();
	return XFormItem.getValueFromHTMLSelect(element);
}

XFormItem.updateValueInHTMLSelect1 = function (newValue, element, selectionIsOpen) {
	if (element == null) return null;
	if (selectionIsOpen == null) selectionIsOpen = false;
	
	var options = element.options;
	for (i = 0; i < options.length; i++) {
		var choice = options[i];
		if (choice.value == newValue) {
			element.selectedIndex = i;
			return element.value;
		}
	}
	// default to the first element if nothing was selected (?)
	if (options.length > 0) {
		element.selectedIndex = 0;
		return options[0].value;
	}
	return null;
}
XFormItem.prototype.updateValueInHTMLSelect1 = function (newValue, element, selectionIsOpen) {
	if (element == null) element = this.getElement();
	if (selectionIsOpen == null) selectionIsOpen = this.getSelectionIsOpen();
	return XFormItem.updateValueInHTMLSelect1(newValue, element, selectionIsOpen);
}


XFormItem.updateValueInHTMLSelect = function (newValue, element, selectionIsOpen) {
	if (element == null) return null;
	if (newValue == null) newValue = "";
	if (selectionIsOpen == null) selectionIsOpen = false;
	
	// assumes newValue is a comma-delimited string or an array
	if (typeof newValue == "string") newValue = newValue.split(",");
	// hack up newValue to make searching for a particular option newValue easier
	var uniqueStartStr = "{|[", 
		uniqueEndStr = "]|}"
	;
	newValue = uniqueStartStr + newValue.join(uniqueEndStr + uniqueStartStr) + uniqueEndStr;
	
	var options = element.options;
	var anySelected = false;
	for (var i = 0; i < options.length; i++) {
		var isPresent = (newValue.indexOf(uniqueStartStr + options[i].value + uniqueEndStr) > -1);
		options[i].selected = isPresent;
		anySelected = anySelected || isPresent;		
	}
	
	if (!anySelected && !selectionIsOpen) {
		// select the first value???
		options[0].selected = true;
	}
}

XFormItem.prototype.updateValueInHTMLSelect = function (newValue, element, selectionIsOpen) {
	if (newValue == null) newValue = "";
	if (element == null) element = this.getElement();
	if (selectionIsOpen == null) selectionIsOpen = this.getSelectionIsOpen();
	return XFormItem.updateValueInHTMLSelect(newValue, element, selectionIsOpen);
}

XFormItem.prototype.getChoicesHTML = function() {
	var choices = this.getNormalizedChoices();
	if (choices == null) return "";	//throw an error?
	var html = new AjxBuffer();
	

	this.outputChoicesHTMLStart(html);
	var values = choices.values;
	var labels = choices.labels;

	var choiceCssClass = this.getChoiceCssClass();
	for (var i = 0; i < values.length; i++) {
		html.append("", this.getChoiceHTML(i, values[i], labels[i], choiceCssClass, ""));
	}
	this.outputChoicesHTMLEnd(html);
	return html.toString();
}

XFormItem.prototype.outputChoicesHTMLStart = function(html, indent) {
	return;
}
XFormItem.prototype.outputChoicesHTMLEnd = function(html, indent) {
	return;
}

XFormItem.prototype.getChoiceCssClass = function() {
	return "";
}

XFormItem.prototype.getChoiceHTML = function (itemNum, value, label, cssClass, indent) {
	return AjxBuffer.concat(indent,"<option value=\"", value, "\">", label,"</option>");
}

XFormItem.prototype.updateChoicesHTML = function () {
	this.cleanChoiceDisplay();

	// NOTE: setting the innerHTML of the options doesn't work
	//	for now, just set the outer HTML of the entire widget
	// TODO: do this by frobbing the options manually for speed and so things don't flash
	var html = new AjxBuffer();
	var updateScript = new AjxBuffer();	// NOTE: we won't be using this...
	this.outputHTML(html, new AjxBuffer(), "");
	this.getContainer().innerHTML = html.toString();
	return;

/*	var element = this.getElement();
	if (element != null) {
		var options = element.options;
		element.options.innerHTML = this.getChoicesHTML();
	}
*/
}


XFormItem.prototype.getInheritedProperty = function(prop) {
	// first look in the instance attributes
	if (this.__attributes[prop] !== _UNDEFINED_) return this.__attributes[prop];

	// look up the inheritance chain for this type
	if (this[prop] !== _UNDEFINED_) return this[prop];

	// if not found there, look in the xmodel
	var modelItem = this.__modelItem;
	if (modelItem && modelItem[prop]) return modelItem[prop];

	return null;
}

// NOTE: cacheProp MUST be different than prop!
XFormItem.prototype.cacheInheritedProperty = function (prop, cacheProp) {
	if (this[cacheProp] !== _UNDEFINED_) return this[cacheProp];
	return (this[cacheProp] = this.getInheritedProperty(prop));
}

XFormItem.prototype.cacheInheritedMethod = function (methodName, cacheProp, arguments) {
	if (this[cacheProp] !== _UNDEFINED_) return this[cacheProp];
	var func = this.getInheritedProperty(methodName);
	if (func != null) func = this.convertToFunction(func, arguments);
	this[cacheProp] = func;
	return func;
}




//
//	properties of the element after its' been drawn
//


XFormItem.prototype.getElement = XForm.prototype.getElement;
XFormItem.prototype.showElement = XForm.prototype.showElement;
XFormItem.prototype.hideElement = XForm.prototype.hideElement;
XFormItem.prototype.createElement = XForm.prototype.createElement;


XFormItem.prototype.getWidget = function() {
	return this.widget;
}

XFormItem.prototype.setWidget = function(widget) {
	this.widget = widget;
}


XFormItem.prototype.getContainer = function() {
	return this.getElement(this.getId() + "___container");
}
XFormItem.prototype.getLabelContainer = function() {
	return this.getElement(this.getId() + "___label");
}
XFormItem.prototype.show = function() {
	if(this.deferred)
		this._outputHTML();
		
	var container = this.getLabelContainer();
	if (container) this.showElement(container);
	container = this.getContainer();
	if (container != null) {
		this.showElement(container);
	} else {
		var items = this.getItems();
		if (items != null) {
			for (var i = 0; i < items.length; i++) {
				var item = items[i];
				item.show();
			}
		}
	}
}
XFormItem.prototype.hide = function(isBlock) {
	var container = this.getLabelContainer()
	if (container) this.hideElement(container,isBlock);
	container = this.getContainer();
	if (container != null) {
		this.hideElement(container,isBlock);
	} else {
		var items = this.getItems();
		if (items != null) {
			for (var i = 0; i < items.length; i++) {
				items[i].hide(isBlock);
			}
		}
	}
}

XFormItem.prototype.focus = function () {
	this.getForm().focusElement(this.getId());
};


//
//	SIMPLE ATTRIBUTE ACCESSORS
//
//	NOTE: this is effectively the public API for the properties you can define
//			for a FormItem
//

XFormItem.prototype.getRequired = function() {
	return this.getInheritedProperty("required");
}

XFormItem.prototype.getValue = function() {
	return this.getInheritedProperty("value");
}

// SPECIAL CASE:  don't take ITEMS from the model...
//XXX NON-STANDARD
XFormItem.prototype.getItems = function () {
	if (this.items) return this.items;
	return this.__attributes.items;
}

XFormItem.prototype.getRelevant = function () {
	return this.cacheInheritedProperty("relevant","_relevant");
}

XFormItem.prototype.getRelevantIfEmpty = function () {
	return this.getInheritedProperty("relevantIfEmpty");
}

XFormItem.prototype.evalRelevant = function () {
	var relevant = this.getRelevant();
	if (relevant == null) return true;

	var item = this;
	var form = this.getForm();
	var model = this.getModel();
	var instance = this.getForm().getInstance();
	with (form) {
		return eval(relevant);
	}
}


XFormItem.prototype.getRelevantBehavior = function () {
	var behavior = this.getInheritedProperty("relevantBehavior");
	if (behavior == _PARENT_) {
		if (this.__parentItem) {
			return this.__parentItem.getRelevantBehavior();
		} else {
			return _HIDE_;
		}
	}
	return behavior;
}

XFormItem.prototype.getChoices = function () {
	return this.getInheritedProperty("choices");
}

// normalized choices look like:  {values:[v1, v2, v3...], labels:[l1, l2, l3...]}
XFormItem.prototype.getNormalizedChoices = function () {
	if (this.$normalizedChoices) return this.$normalizedChoices;

	var choices = this.getChoices();
	if (choices == null) return null;

	var normalizedChoices;
	if (typeof choices.getChoices == "function") {
		normalizedChoices = choices.getChoices();
	} else if (AjxUtil.isArray(choices)) {
		// it's either an array of objects or an array of strings
		if (typeof choices[0] == "object") {
			// list of objects
			normalizedChoices = XFormChoices.normalizeChoices(choices, XFormChoices.OBJECT_LIST);
		} else {
			// list of simple values
			normalizedChoices = XFormChoices.normalizeChoices(choices, XFormChoices.SIMPLE_LIST);
		}
	} else {
		// assume it's a hash
		normalizedChoices = XFormChoices.normalizeChoices(choices, XFormChoices.HASH);
	}
	this.$normalizedChoices = normalizedChoices;
	return this.$normalizedChoices;
}


XFormItem.prototype.getNormalizedValues = function () {
	var choices = this.getNormalizedChoices();
	if (choices) return choices.values;
	return null;
}


XFormItem.prototype.getNormalizedLabels = function () {
	var choices = this.getNormalizedChoices();
	if (choices) return choices.labels;
	return null;
}
	
	
	
//
//	appearance methods
//

XFormItem.prototype.getAppearance = function () {
	return this.getInheritedProperty("appearance");
}
XFormItem.prototype.getCssClass = function () {
	return this.getInheritedProperty("cssClass");
}

XFormItem.prototype.getCssStyle = function () {
	return this.getInheritedProperty("cssStyle");
}

XFormItem.prototype.getLabel = function (value) {
	return this.getInheritedProperty("label");
}

XFormItem.prototype.getErrorCssClass = function () {
	return this.getInheritedProperty("errorCssClass");
}
XFormItem.prototype.getLabelCssClass = function (className) {
	if (className != null) return className;
	return this.getInheritedProperty("labelCssClass");
}

XFormItem.prototype.getLabelCssStyle = function (style) {
	if (style != null) return style;
	return this.getInheritedProperty("labelCssStyle");
}

XFormItem.prototype.getLabelWrap = function () {
	return this.getInheritedProperty("labelWrap");
}

XFormItem.prototype.getLabelLocation = function () {
	return this.getInheritedProperty("labelLocation");
}

XFormItem.prototype.getContainerCssClass = function () {
	return this.getInheritedProperty("containerCssClass");
}

XFormItem.prototype.getContainerCssStyle = function () {
	return this.getInheritedProperty("containerCssStyle");
}

XFormItem.prototype.getTableCssClass = function () {
	return this.getInheritedProperty("tableCssClass");
}
XFormItem.prototype.getTableCssStyle = function () {
	return this.getInheritedProperty("tableCssStyle");
}

XFormItem.prototype.getNowrap = function () {
	return this.getInheritedProperty("nowrap");
}

XFormItem.prototype.getWidth = function () {
	return this.cacheInheritedProperty("width","_width");
}

XFormItem.prototype.getHeight = function () {
	return this.getInheritedProperty("height");
}

XFormItem.prototype.getOverflow = function () {
	return this.getInheritedProperty("overflow");
}

XFormItem.prototype.getNumCols = function () {
	return this.getInheritedProperty("numCols");
}

XFormItem.prototype.getAlign = function () {
	return this.getInheritedProperty("align");
}


XFormItem.prototype.getValign = function() {
	return this.getInheritedProperty("valign");
}

XFormItem.prototype.getName = function () {
	return this.getInheritedProperty("name");
}

// NEW TABLE LAYOUT STUFF
XFormItem.prototype.useParentTable = true;
XFormItem.prototype.getUseParentTable = function () {
	return this.getInheritedProperty("useParentTable");
}
XFormItem.prototype.colSizes = _UNDEFINED_;
XFormItem.prototype.getColSizes = function () {
	return this.getInheritedProperty("colSizes");
}
XFormItem.prototype.colSpan = 1;
XFormItem.prototype.getColSpan = function () {
	return this.getInheritedProperty("colSpan");
}
XFormItem.prototype.rowSpan = 1;
XFormItem.prototype.getRowSpan = function () {
	return this.getInheritedProperty("rowSpan");
}
// END NEW TABLE LAYOUT STUFF

// error handling
XFormItem.prototype.getErrorLocation = function () {
	return this.getInheritedProperty("errorLocation");
};

//
//	convenience methods to figure out drawing types for you
//

// return the "label" in the choices array for this item
//	(allows us to do lookup of displayed values easily)
XFormItem.prototype.getChoiceLabel = function (value) {
	var choices = this.getNormalizedChoices();
	if (choices == null) return value;
	
	// choices will look like:  {values:[v1, v2, v3...], labels:[l1, l2, l3...]}
	var values = choices.values;
	for (var i = 0; i < values.length; i++) {
		if (values[i] == value) {
			return choices.labels[i];
		}
	}
	// if we didn't find it, simply return the original value
	return value;
}

// return the "label" in the choices array for this item
//	(allows us to do lookup of displayed values easily)
XFormItem.prototype.getChoiceValue = function (label) {
	function labelComparator (a, b) {
			return String(a).toLowerCase() < String(b).toLowerCase() ? -1 : (String(a).toLowerCase() > String(b).toLowerCase() ? 1 : 0);
	 };
	var choices = this.getNormalizedChoices();
	if (choices == null) return value;
	
	// choices will look like:  {values:[v1, v2, v3...], labels:[l1, l2, l3...]}
	// bug 6738: sort will change the mapping between value and label.
	/*
	var labels = choices.labels;
	var vec = AjxVector.fromArray(labels);
	vec.sort(labelComparator);
	var ix = vec.binarySearch(label,labelComparator); */
	var labels = choices.labels;
	var ix = -1;
	for (var i=0; i < labels.length ; i++ ){
		if (labelComparator (label, labels[i]) == 0) {
			ix = i ;
			break;
		}		
	}
	
	if(ix>=0) 
		return choices.values[ix];
	else 
		return choices.values[0];
}

// return the number of the choice for a particular value
//	returns -1 if not found
XFormItem.prototype.getChoiceNum = function (value) {
	var choices = this.getNormalizedChoices();
	if (choices == null) return -1;
	
	// choices will look like:  {values:[v1, v2, v3...], labels:[l1, l2, l3...]}
	var values = choices.values;
	for (var i = 0; i < values.length; i++) {
		if (values[i] == value) {
			return i;
		}
	}
	return -1
}


XFormItem.prototype.getCssString = function () {
	var css = (this.getCssClass() || '');
	if (css != '' && css != null) css = " class=\"" + css + "\"";

	var style = (this.getCssStyle() || '');

	var width = this.getWidth();
	if (width != null && width != "auto") style += ";width:" + width;

	var height = this.getHeight();
	if (height != null) style += ";height:" + height;

	var overflow = this.getOverflow();
	if (overflow != null) style += ";overflow:" + overflow;
	
	if (this.getNowrap())	style += ";white-space:nowrap;";

	var valign = this.getValign();
	if (valign) style += "vertical-align:"+valign;
	
	if (style != '') css += " style=\"" + style + ";\"";
	return css;
}


XFormItem.prototype.getLabelCssString = function (className, style) {
	var css = (this.getLabelCssClass(className) || '');
	if (css != '' && css != null) css = " class=\"" + css + "\"";
	var style = (this.getLabelCssStyle(style) || '');
	if (this.getLabelWrap() == false) {
		style += ";white-space:nowrap";
	}
	if (style != '') css += " style=\"" + style + ";\"";
	
	return css;
}




XFormItem.prototype.getTableCssString = function () {
	var css = (this.getTableCssClass() || '');
	if (css != '' && css != null) css = " class=\"" + css + "\"";

	var style = this.getTableCssStyle();
	if (style == null) style = '';
	
	var colSizes = this.getColSizes();
	if (colSizes != null) {
		style += ";table-layout:fixed";
	}

	var width = this.getWidth();
	if (width != null) 	style += ";width:"+ width;
	
//	var height = this.getHeight();
//	if (height != null)	style += ";height:"+ height;
	
	var overflow = this.getOverflow();
	if (overflow != null) style += ";overflow:" + overflow;

	return css + (style != null ? " style=\"" + style + ";\"" : "");
}


XFormItem.prototype.getContainerCssString = function () {
	var css = (this.getContainerCssClass() || '');
	if (css != '' && css != null) css = " class=\"" + css + "\"";
	var style = this.getContainerCssStyle();
	if (style == null) style = '';
	
	var align = this.getAlign();
	if (align != _LEFT_) {
		if (align == _CENTER_ || align == _MIDDLE_) {
			style += ";text-align:center";
		} else if (align == _RIGHT_) {
			style += ";text-align:right";
		}
	}
	var valign = this.getValign();
	if (valign == _TOP_) {
		style += ";vertical-align:top";
	} else if (valign == _BOTTOM_) {
		style += ";vertical-align:bottom";
	} else if (valign == _CENTER_ || valign == _MIDDLE_) {
		style += ";vertical-align:middle";
	}

	var relevant = this.getRelevant();
	if (relevant) {
		var relevantBehavior = this.getRelevantBehavior();
		if (relevantBehavior == _HIDE_) {
			style += ";display:none";
		} else if(relevantBehavior == _BLOCK_HIDE_) {
			style += ";display:block";
		} 
	}

	if (style != "") css += " style=\"" + style + ";\"";
	return css;
}




//
//	handling changes to items
//
XFormItem.prototype.getElementChangeHandler = function () {
	return this.getInheritedProperty("elementChangeHandler");
}




//
//	outputting, inserting and updating items
//

XFormItem.prototype.getForceUpdate = function() {
	return this.getInheritedProperty("forceUpdate");
}

XFormItem.prototype.getOutputHTMLMethod = function() {
	return this.convertToFunction(
				this.getInheritedProperty("outputHTML"),
				"html,updateScript,indent,currentCol"
		);
}

XFormItem.prototype.getElementChangedMethod = function () {
	return this.cacheInheritedMethod("elementChanged","$elementChanged","elementValue, instanceValue, event");
}

XFormItem.prototype.getUpdateElementMethod = function() {
	return this.cacheInheritedMethod("updateElement","$updateElement","newValue");
}

XFormItem.prototype.getDisplayValueMethod = function() {
	return this.cacheInheritedMethod("getDisplayValue","$getDisplayValue","newValue");
}


XFormItem.prototype.convertToFunction = function (script, arguments) {
	if ((script == null) || (typeof(script) == "function")) return script;
	if (typeof(this[script]) == "function") return this[script];
	// CLOSURE???
	return new Function(arguments, script);
}



// note that this form item's display needs to be updated
XFormItem.prototype.dirtyDisplay = function () {
	delete this.$lastDisplayValue;
}

// override the next method in your subclass to enable/disable element
XFormItem.prototype.setElementEnabled = function(enable) {}

// convenience methods that call the above routine
XFormItem.prototype.disableElement = function () {
	this.setElementEnabled(false);
}

XFormItem.prototype.enableElement = function () {
	this.setElementEnabled(true);
}

// you can use these to 
XFormItem.prototype.setElementDisabledProperty = function (enable) {
	this.getElement().disabled = (enable != true)
}


XFormItem.prototype.setElementEnabledCssClass = function (enable) {
	var el = this.getElement();
	if (!el) return;
	
	if (enable) {
		el.className = this.getCssClass();
	} else {
		el.className = this.getCssClass() + "_disabled";
	}
}



//
//	_SELECT_ etc type properties
//
XFormItem.prototype.getSelection = function () {
	return this.getInheritedProperty("selection");
}

XFormItem.prototype.getSelectionIsOpen = function () {
	return this.getInheritedProperty("selection");
}

XFormItem.prototype.getOpenSelectionLabel = function () {
	return this.getInheritedProperty("openSelectionLabel");
}


//
//	_REPEAT_ type properties
//

XFormItem.prototype.getNumberToShow = function () {
	return this.getInheritedProperty("number");
}

XFormItem.prototype.getShowAddButton = function () {
	return this.getInheritedProperty("showAddButton");
}

XFormItem.prototype.getShowRemoveButton = function () {
	return this.getInheritedProperty("showRemoveButton");
}

XFormItem.prototype.getShowMoveUpButton = function () {
	return this.getInheritedProperty("showMoveUpButton");
}

XFormItem.prototype.getShowMoveDownButton = function () {
	return this.getInheritedProperty("showMoveDownButton");
}

XFormItem.prototype.getAddButton = function () {
	return this.getInheritedProperty("addButton");
}

XFormItem.prototype.getRemoveButton = function () {
	return this.getInheritedProperty("removeButton");
}

XFormItem.prototype.getMoveUpButton = function () {
	return this.getInheritedProperty("moveUpButton");
}

XFormItem.prototype.getMoveDownButton = function () {
	return this.getInheritedProperty("moveDownButton");
}

XFormItem.prototype.getAlwaysShowAddButton = function () {
	return this.getInheritedProperty("alwaysShowAddButton");
}

XFormItem.prototype.getRepeatInstance = function () {
	return this.getInheritedProperty("repeatInstance");
}




//
//	_IMAGE_ type properties
//

XFormItem.prototype.getSrc = function () {
	return this.getInheritedProperty("src");
}

XFormItem.prototype.getSrcPath = function () {
	return this.getInheritedProperty("srcPath");
}



//
//	_ANCHOR_, _URL_, etc
//
//	type defaults
XFormItem.prototype.getShowInNewWindow = function () {
	return this.getInheritedProperty("showInNewWindow");
}




//
//	internal properties for creating various item types
//


XFormItem.prototype.getWriteElementDiv = function () {
	return this.getInheritedProperty("writeElementDiv");
}

XFormItem.prototype.getMultiple = function () {
	return this.getInheritedProperty("multiple");
}

XFormItem.prototype.getAlwaysUpdateChoices = function () {
	return this.getInheritedProperty("alwaysUpdateChoices");
}

XFormItem.prototype.choicesAreDirty = function () {
	return (this._choiceDisplayIsDirty == true || this.getAlwaysUpdateChoices());
}












/**
* @class defines XFormItem type _OUTPUT_
* @contructor
**/
function Output_XFormItem() {}
XFormItemFactory.createItemType("_OUTPUT_", "output", Output_XFormItem, XFormItem);


//	type defaults
Output_XFormItem.prototype.writeElementDiv = true;
Output_XFormItem.prototype.cssClass =  "xform_output";	// element itself (or element div)
Output_XFormItem.prototype.containerCssClass =  "xform_output_container";	// element itself (or element div)

//	methods

Output_XFormItem.prototype.outputHTML = function (html, updateScript, indent) {
	// by defaut, we output the "attributes.value" if set 
	//	(in case an item only wants to write out on the initial draw)
	// NOTE: dereferencing through the choice map happens in getDisplayValue()
	var value = this.getValue();
	var method = this.getDisplayValueMethod();
	if (method) {
		value = method.call(this, value);
	}
	html.append(value);
}


Output_XFormItem.prototype.getDisplayValue = function(newValue) {
	// dereference through the choices array, if provided
	newValue = this.getChoiceLabel(newValue);

	if (newValue == null) {
		newValue = "";
	} else {
		newValue = "" + newValue;
	}
	return newValue;
}

Output_XFormItem.prototype.updateElement = function (newValue) {
	this.getElement().innerHTML = newValue;
}


// set up how disabling works for this item type
Output_XFormItem.prototype.setElementEnabled = XFormItem.prototype.setElementEnabledCssClass;





/**
* @class defines XFormItem type _TEXTFIELD_
* @contructor
**/
function Textfield_XFormItem() {}
XFormItemFactory.createItemType("_TEXTFIELD_", "textfield", Textfield_XFormItem, XFormItem);
// aliases for _TEXTFIELD_:  _INPUT_
XFormItemFactory.registerItemType("_INPUT_", "input", Textfield_XFormItem);

//	type defaults
//Textfield_XFormItem.prototype.width = 100;
Textfield_XFormItem.prototype._inputType = "text";
Textfield_XFormItem.prototype.cssClass = "xform_field";
Textfield_XFormItem.prototype.elementChangeHandler="onkeypress";
Textfield_XFormItem.prototype.focusable = true;
Textfield_XFormItem.prototype.containerCssClass = "xform_field_container";

//	methods
Textfield_XFormItem.prototype.outputHTML = function (html, updateScript, indent, currentCol) {
	var inputType = this._inputType;
	var value = this.getValue();
	var modelItem = this.getModelItem();


	/***
//XXX this is probably not the best way to tell if we only want to enter numbers...
	if (modelItem && (modelItem.type == _NUMBER_)) {// || modelItem.type == _COS_NUMBER_)) {
		var keyStrokeHandler = " onkeypress=\""
//			+"',45,46,48,49,50,51,52,53,54,55,56,57,69,101,'.indexOf(','+(event||window.event).keyCode+',') > -1\""		
				+"var code = ','+(event||window.event).which+',';"
				+"var isValidChar = (',45,46,48,49,50,51,52,53,54,55,56,57,69,101,'.indexOf(code) > -1);"
				+"DBG.println(code + ':'+isValidChar);"
				+"event.returnValue = isValidChar;"
				+"return isValidChar;"
				+"\""
	}
	/***/
	html.append(indent, 
			"<input autocomplete='off' id=\"", this.getId(),"\" type=\"", inputType, "\"", this.getCssString(), 
				this.getChangeHandlerHTML(), this.getFocusHandlerHTML(),
				(value != null ? " value=\"" + value + "\"" : ""),
			">");
}

Textfield_XFormItem.prototype.updateElement = function(newValue) {
	if (newValue == null) newValue = this.getValue();
	if (newValue == null) newValue = "";
	if (this.getElement().value != newValue) {
		this.getElement().value = newValue;
	}
}

// set up how disabling works for this item type
Textfield_XFormItem.prototype.setElementEnabled = XFormItem.prototype.setElementDisabledProperty;





/**
* @class defines XFormItem type _SECRET_
* @contructor
**/
function Secret_XFormItem() {}
XFormItemFactory.createItemType("_SECRET_", "secret", Secret_XFormItem, Textfield_XFormItem);
// alias for the SECRET class:  PASSWORD
XFormItemFactory.registerItemType("_PASSWORD_", "password", Secret_XFormItem);


//	type defaults
Secret_XFormItem.prototype._inputType = "password";
Secret_XFormItem.prototype.focusable = true;




/**
* @class defines XFormItem type _FILE_
* @contructor
**/
function File_XFormItem() {}
XFormItemFactory.createItemType("_FILE_", "file", File_XFormItem, Textfield_XFormItem)

//	type defaults
File_XFormItem.prototype._inputType = "file";
File_XFormItem.prototype.forceUpdate = false;
File_XFormItem.prototype.focusable = true;



/**
* @class defines XFormItem type _TEXTAREA_
* @contructor
**/
function Textarea_XFormItem() {}
XFormItemFactory.createItemType("_TEXTAREA_", "textarea", Textarea_XFormItem, Textfield_XFormItem)

Textarea_XFormItem.prototype.width = "100%";
Textarea_XFormItem.prototype.height = 100;
Textarea_XFormItem.prototype.focusable = true;
//	methods
Textarea_XFormItem.prototype.outputHTML = function (html, updateScript, indent, currentCol) {
	var wrap = this.getInheritedProperty("textWrapping");
	if (!wrap)
		wrap = "off";
		
	html.append(indent, 
		"<textarea id=\"", this.getId(), "\"", this.getCssString(),
				this.getChangeHandlerHTML(), this.getFocusHandlerHTML(), "wrap='", wrap, "'",
		"></textarea>");
}





/**
* @class defines XFormItem type _CHECKBOX_
* @contructor
**/
function Checkbox_XFormItem() {}
XFormItemFactory.createItemType("_CHECKBOX_", "checkbox", Checkbox_XFormItem, XFormItem)

//	type defaults
Checkbox_XFormItem.prototype._inputType = "checkbox";
Checkbox_XFormItem.prototype.elementChangeHandler = "onclick";
Checkbox_XFormItem.prototype.labelLocation = _RIGHT_;
Checkbox_XFormItem.prototype.cssClass = "xform_checkbox";
Checkbox_XFormItem.prototype.labelCssClass = "xform_checkbox";
Checkbox_XFormItem.prototype.align = _RIGHT_;
Checkbox_XFormItem.prototype.trueValue = _UNDEFINED_;		// Don't set in proto so model can override
Checkbox_XFormItem.prototype.falseValue = _UNDEFINED_;
Checkbox_XFormItem.prototype.focusable = true;

//	methods
Checkbox_XFormItem.prototype.outputHTML = function (html, updateScript, indent, currentCol) {
	// figure out how to show the checkbox as checked or not
	var checked = "";
	if (this.getInstanceValue() == this.getTrueValue()) {
		checked = " CHECKED";
	}
	html.append(indent, 
		"<input autocomplete='off' id=\"", this.getId(),"\" type=\"", this._inputType, "\"",  
				this.getChangeHandlerHTML(), this.getFocusHandlerHTML(), checked,
		">");
}


Checkbox_XFormItem.prototype.getTrueValue = function () {
	var trueValue = this.getInheritedProperty("trueValue");
	if (trueValue == null) trueValue = true;
	return trueValue;
}

Checkbox_XFormItem.prototype.getFalseValue = function () {
	var falseValue = this.getInheritedProperty("falseValue");
	if (falseValue == null) falseValue = false;
	return falseValue;
}



Checkbox_XFormItem.prototype.updateElement = function(newValue) {
	newValue = (newValue == this.getTrueValue());
	this.getElement().checked = newValue;
}

Checkbox_XFormItem.prototype.getElementValueGetterHTML = function () {
	var trueValue = this.getTrueValue();
	if (trueValue !== _UNDEFINED_) {
		if (typeof trueValue == "string") trueValue = "'" + trueValue + "'";
		
		var falseValue = this.getFalseValue();
		if (typeof falseValue == "string") falseValue = "'" + falseValue + "'";
	
		if (trueValue == null) trueValue = true;
		if (falseValue == null) falseValue = false;
	
		return AjxBuffer.concat(
			"var value = (this.checked ? ",  trueValue, " : ", falseValue, ");"
		);
	} else {
		return "var value = '"+this.getValue()+"';";
	}
}


// set up how disabling works for this item type
//	XXXX eventually we want to disable our label as well...
Checkbox_XFormItem.prototype.setElementEnabled = XFormItem.prototype.setElementDisabledProperty;



/**
* @class defines XFormItem type _RADIO_
* @contructor
**/
function Radio_XFormItem() {}
XFormItemFactory.createItemType("_RADIO_", "radio", Radio_XFormItem, Checkbox_XFormItem)

//	type defaults
Radio_XFormItem.prototype._inputType = "radio";
Radio_XFormItem.prototype.focusable = true;
//	methods

Radio_XFormItem.prototype.updateElement = function(newValue) {
	this.getElement().checked = (this.getValue() == newValue);
}




/**
* @class defines XFormItem type _BUTTON_
* this item is a simple HTML <button> element
* @contructor
**/
function Button_XFormItem() {}
XFormItemFactory.createItemType("_BUTTON_", "button", Button_XFormItem, XFormItem);
XFormItemFactory.registerItemType("_TRIGGER_", "trigger", Button_XFormItem);
//	type defaults
Button_XFormItem.prototype.forceUpdate = false;
Button_XFormItem.prototype.elementChangeHandler = "onclick";
Button_XFormItem.prototype.labelLocation = _NONE_;
Button_XFormItem.prototype.relevantBehavior = _DISABLE_;
Button_XFormItem.prototype.cssClass = "xform_button";
Button_XFormItem.prototype.focusable = true;
// 	methods
Button_XFormItem.prototype.outputHTML = function (html, updateScript, indent, currentCol) {
	// write the div to hold the value (will be filled in on update)
	html.append(indent,
		"<button id=\"", this.getId(), "\"", this.getCssString(),
			"\r  ",indent, this.getOnActivateHandlerHTML(), 
			"\r  ",indent, this.getFocusHandlerHTML(),
		"\r",indent,">", 
			this.getLabel(),
		"</button>");
}

// set up how disabling works for this item type
Button_XFormItem.prototype.setElementEnabled = XFormItem.prototype.setElementDisabledProperty;



/**
* @class defines XFormItem type _SUBMIT_
* this item is a simple HTML <input type="submit"> element
* @contructor
**/
function Submit_XFormItem() {}
XFormItemFactory.createItemType("_SUBMIT_", "submit", Submit_XFormItem, Button_XFormItem)


//	methods
Submit_XFormItem.prototype.outputHTML = function (html, updateScript, indent, currentCol) {
	// write the div to hold the value (will be filled in on update)
	html.append(
		"<input id=\"", this.getId(), "\" type=\"submit\"", this.getCssString(),
			this.getChangeHandlerHTML(), this.getFocusHandlerHTML(),
		" value=\"", this.getLabel(), ">"
	);
}






/**
* @class defines XFormItem type _ANCHOR_
* this item is an HTML <a> element
* @contructor
**/
function Anchor_XFormItem() {}
XFormItemFactory.createItemType("_ANCHOR_", "anchor", Anchor_XFormItem, XFormItem)

//	type defaults
Anchor_XFormItem.prototype.writeElementDiv = true;
Anchor_XFormItem.prototype.forceUpdate = true;
Anchor_XFormItem.prototype.cssClass = "xform_anchor";
Anchor_XFormItem.prototype.elementChangeHandler = "onclick";
Anchor_XFormItem.prototype.href = "javascript:;";
Anchor_XFormItem.prototype.showInNewWindow = true;
Anchor_XFormItem.prototype.focusable = true;

Anchor_XFormItem.prototype.getHref = function () {
	return this.getInheritedProperty("href");
}

//	type defaults


Anchor_XFormItem.prototype.getAnchorTag = function(href, label) {
	if (href == null) href = this.getHref();
	if (label == null) label = this.getLabel();
	
	var inNewWindow = this.getShowInNewWindow();
	return AjxBuffer.concat(
			'<a href=', href, 
				this.getOnActivateHandlerHTML(), 
				(inNewWindow ? ' target="_blank"' : ''),
			'>',
				label,
			'</a>');
}

//	methods
Anchor_XFormItem.prototype.outputHTML = function (html) {
	html.append(this.getAnchorTag());
}


Anchor_XFormItem.prototype.updateElement = function (value) {
	this.getElement().innerHTML = this.getAnchorTag(value);
}


// set up how disabling works for this item type
Anchor_XFormItem.prototype.setElementEnabled = XFormItem.prototype.setElementEnabledCssClass;




/**
* @class defines XFormItem type _DATA_ANCHOR_
* this item is an HTML <a> element
* @contructor
**/
function Data_Anchor_XFormItem() {}
XFormItemFactory.createItemType("_DATA_ANCHOR_", "data_anchor", Data_Anchor_XFormItem, Anchor_XFormItem)


Data_Anchor_XFormItem.prototype.updateElement = function (value) {
	this.getElement().innerHTML = this.getAnchorTag(null, value);
}




/**
* @class defines XFormItem type _URL_
* @contructor
**/
function Url_XFormItem() {}
XFormItemFactory.createItemType("_URL_", "url", Url_XFormItem, Anchor_XFormItem)


Url_XFormItem.prototype.updateElement = function (value) {
	this.getElement().innerHTML = this.getAnchorTag(value, value);
}





/**
* @class defines XFormItem type _MAILTO_
* this item is an _ANCHOR_ element with "mailto:" link
* @contructor
**/
function Mailto_XFormItem() {}
XFormItemFactory.createItemType("_MAILTO_", "mailto", Mailto_XFormItem, Anchor_XFormItem)
Mailto_XFormItem.prototype.updateElement = function (value) {
	this.getElement().innerHTML = this.getAnchorTag("mailto:"+value, value);
}




/**
* @class defines XFormItem type _IMAGE_
* @contructor
**/
function Image_XFormItem() {}
XFormItemFactory.createItemType("_IMAGE_", "image", Image_XFormItem, XFormItem)


//	type defaults
Image_XFormItem.prototype.forceUpdate = true;
Image_XFormItem.prototype.src = _UNDEFINED_;
Image_XFormItem.prototype.srcPath = _UNDEFINED_;;
Image_XFormItem.prototype.writeElementDiv = true;


//	methods
Image_XFormItem.prototype.updateElement = function (src) {
	if (src == null) src = this.getSrc();
	
	// dereference through the choices array, if provided
	src = this.getChoiceLabel(src);

	// if we didn't get an image name, output nothing (?)
	if (src == null || src == "") {
		var output = "";
	} else {
		// prepend the image path
		var path = this.getSrcPath();
		if (path != null) src = path + src;

		var output = AjxBuffer.concat(
			"<img id=\"", this.getId(), "\" border=0 ", this.getCssString(),
				" src=\"", src, "\"",
			">"
		);
	}
	this.getElement().innerHTML = output;
}


// set up how disabling works for this item type
Image_XFormItem.prototype.setElementEnabled = XFormItem.prototype.setElementEnabledCssClass;



// Ajx_Image
function Ajx_Image_XFormItem() {}
XFormItemFactory.createItemType("_AJX_IMAGE_", "ajx_image", Ajx_Image_XFormItem, XFormItem);


//	type defaults
Ajx_Image_XFormItem.prototype.forceUpdate = true;
Ajx_Image_XFormItem.prototype.src = _UNDEFINED_;
Ajx_Image_XFormItem.prototype.srcPath = _UNDEFINED_;;
Ajx_Image_XFormItem.prototype.writeElementDiv = false;

// //	methods
Ajx_Image_XFormItem.prototype.updateElement = function (src) {
	if (src == null) src = this.getSrc();

 	// dereference through the choices array, if provided
 	src = this.getChoiceLabel(src);
	var output;
 	// if we didn't get an image name, output nothing (?)
 	if (src == null || src == "") {
 		output = "";
 	} else {
 		// prepend the image path
 		var path = this.getSrcPath();
 		if (path != null) src = path + src;
		output = AjxImg.getImageHtml(src, "position:relative;" + this.getCssStyle())
 	}
 	this.getContainer().innerHTML = output;
};



/**
* @class defines XFormItem type _SELECT1_
* this item is rendered as HTML <select> element
* @contructor
**/
function Select1_XFormItem() {}
XFormItemFactory.createItemType("_SELECT1_", "select1", Select1_XFormItem, XFormItem)

//	type defaults
Select1_XFormItem.prototype.multiple = false;
Select1_XFormItem.prototype.alwaysUpdateChoices = false;
Select1_XFormItem.prototype.focusable = true;
Select1_XFormItem.prototype.cssClass = "xform_select1";
Select1_XFormItem.prototype.containerCssClass = "xform_select_container";

//	methods
Select1_XFormItem.prototype.initFormItem = function () {
	// if we're dealing with an XFormChoices object...
	var choices = this.getChoices();
	if (choices == null || choices.constructor != XFormChoices) return;

	//	...set up to receive notification when its choices change
	var listener = new AjxListener(this, this.dirtyDisplay);
	choices.addListener(DwtEvent.XFORMS_CHOICES_CHANGED, listener);
}


Select1_XFormItem.prototype.outputHTML = function (html, updateScript, indent, currentCol) {
	html.append(indent, 
		"<select id=\"", this.getId(), "\" ", this.getCssString(), 
			(this.getMultiple() ? "multiple " : ""), 
			this.getChangeHandlerHTML(), this.getFocusHandlerHTML(),
		">\r",
			this.getChoicesHTML(),
		"\r", indent, "</select>"
		);
	this.cleanChoiceDisplay();
}

Select1_XFormItem.prototype.getElementValueGetterHTML = function () {
	return "var value = XFormItem.getValueFromHTMLSelect(this);";
}



Select1_XFormItem.prototype.setChoices = function(newChoices) {
	this.choices = newChoices;
	this.dirtyDisplay();
	this.updateChoicesHTML();
}

Select1_XFormItem.prototype.dirtyDisplay = function () {
	XFormItem.prototype.dirtyDisplay.call(this);
	this._choiceDisplayIsDirty = true;
	delete this.$normalizedChoices;
}

Select1_XFormItem.prototype.cleanChoiceDisplay = function () {
	this._choiceDisplayIsDirty = false;
}


Select1_XFormItem.prototype.updateElement = function (newValue) {
	if (this.choicesAreDirty()) this.updateChoicesHTML();
	this.updateValueInHTMLSelect1(newValue, this.getElement(), this.getSelectionIsOpen());
}


// set up how disabling works for this item type
Select1_XFormItem.prototype.setElementEnabled = XFormItem.prototype.setElementDisabledProperty;



/**
* @class defines XFormItem type _SELECT_
* this item is rendered as HTML <select> element
* @contructor
**/
function Select_XFormItem() {}
XFormItemFactory.createItemType("_SELECT_", "select", Select_XFormItem, Select1_XFormItem)

//	type defaults
Select_XFormItem.prototype.multiple = true;
Select_XFormItem.prototype.selection = _OPEN_;
Select_XFormItem.prototype.focusable = true;
Select_XFormItem.prototype.containerCssClass = "xform_select_container";

//	methods

Select_XFormItem.prototype.updateElement = function (newValue) {
	if (this.choicesAreDirty()) this.updateChoicesHTML();
	this.updateValueInHTMLSelect(newValue, this.getElement(), this.getSelectionIsOpen());
}





/**
* @class defines XFormItem type _SPACER_
* Use to output an entire row spacer
* @contructor
**/
function Spacer_XFormItem() {}
XFormItemFactory.createItemType("_SPACER_", "spacer", Spacer_XFormItem, XFormItem)

//	type defaults
Spacer_XFormItem.prototype.forceUpdate = false;
Spacer_XFormItem.prototype.labelLocation = _NONE_;
Spacer_XFormItem.prototype.width = 1;
Spacer_XFormItem.prototype.height = 10;
Spacer_XFormItem.prototype.cssStyle = "font-size:1px;overflow:hidden;";
Spacer_XFormItem.prototype.colSpan = "*";
Spacer_XFormItem.prototype.focusable = false;

// 	methods
Spacer_XFormItem.prototype.outputHTML = function (html, updateScript, indent, currentCol) {
	html.append(indent, "<div ", this.getCssString(),"></div>");
}

// set up how disabling works for this item type
Spacer_XFormItem.prototype.setElementEnabled = XFormItem.prototype.setElementEnabledCssClass;

/**
* @class defines XFormItem type _CELL_SPACER_
* Use to output a single cell of space
* @contructor
**/
function Cell_Spacer_XFormItem() {}
XFormItemFactory.createItemType("_CELL_SPACER_", "cell_spacer", Cell_Spacer_XFormItem, Spacer_XFormItem)
XFormItemFactory.registerItemType("_CELLSPACER_", "cell_spacer", Cell_Spacer_XFormItem);
Cell_Spacer_XFormItem.prototype.width = 10;
Cell_Spacer_XFormItem.prototype.height = 10;
Cell_Spacer_XFormItem.prototype.colSpan = 1;
Cell_Spacer_XFormItem.prototype.focusable = false;

/**
* @class defines XFormItem type _SEPARATOR_
* @contructor
**/
function Separator_XFormItem() {}
XFormItemFactory.createItemType("_SEPARATOR_", "separator", Separator_XFormItem, XFormItem)

//	type defaults
Separator_XFormItem.prototype.cssClass = "xform_separator";
Separator_XFormItem.prototype.colSpan = "*";
Separator_XFormItem.prototype.align = _CENTER_;
Separator_XFormItem.prototype.valign = _CENTER_;
Separator_XFormItem.prototype.height = 10;
Separator_XFormItem.prototype.focusable = false;

// methods
Separator_XFormItem.prototype.outputHTML = function (html, updateScript, indent, currentCol) {
	var css = (this.getCssClass() || '');
	if (css != '' && css != null) css = " class=\"" + css + "\"";
	
	html.append(indent, 
			"<table width=100% cellspacing=0 cellpadding=0>",
				"<tr><td height=",this.getHeight(),">",
					"<div ", css,"></div>",
			"</td></tr></table>"
	);
}


// set up how disabling works for this item type
Separator_XFormItem.prototype.setElementEnabled = XFormItem.prototype.setElementEnabledCssClass;







/**
* @class defines XFormItem type _GROUP_
* @contructor
**/
function Group_XFormItem() {}
XFormItemFactory.createItemType("_GROUP_", "group", Group_XFormItem, XFormItem)

//	type defaults
Group_XFormItem.prototype.forceUpdate = false;
Group_XFormItem.prototype.numCols = 2;
Group_XFormItem.prototype.useParentTable = false;
Group_XFormItem.prototype.focusable = false;

Group_XFormItem.prototype.outputHTML = function (html, updateScript, indent, currentCol) {
	this.getForm().outputItemList(this.getItems(), this, html, updateScript, indent, this.getNumCols(), currentCol);
}

// nothing to do on group update -- each item will take care of it itself
//group_XFormItem.prototype.updateElement = function (newValue) {}


/**
* @class defines XFormItem type _BORDER_
* dependent on the file DwtBorder.js
* @contructor
**/
function Border_XFormItem() {}
XFormItemFactory.createItemType("_BORDER_", "border", Border_XFormItem, Group_XFormItem)

//	type defaults
Border_XFormItem.prototype.forceUpdate = true;
Border_XFormItem.prototype.colSpan = "*";
Border_XFormItem.prototype.numCols = 2;
Border_XFormItem.prototype.useParentTable = false;
Border_XFormItem.prototype.borderStyle = "card";
Border_XFormItem.prototype.focusable = false;

Border_XFormItem.prototype.getBorderStyle = function () {
	return this.getInheritedProperty("borderStyle");
}

Border_XFormItem.prototype.getSubstitutions = function () {
	return this.getInheritedProperty("substitutions");
}



Border_XFormItem.prototype.getBorderWidth = function () {
	return DwtBorder.getBorderWidth(this.getBorderStyle());
}

Border_XFormItem.prototype.getBorderHeight = function () {
	return DwtBorder.getBorderHeight(this.getBorderStyle());
}


Border_XFormItem.prototype.outputHTMLStart = function (html, updateScript, indent, currentCol) {
	var style = this.getBorderStyle();
	var substitutions = this.getSubstitutions();
	html.append(DwtBorder.getBorderStartHtml(style, substitutions));
}

Border_XFormItem.prototype.outputHTMLEnd = function (html, updateScript, indent, currentCol) {
	var style = this.getBorderStyle();
	var substitutions = this.getSubstitutions();
	html.append(DwtBorder.getBorderEndHtml(style, substitutions));
}

Border_XFormItem.prototype.updateElement = function () {
	// firefox has a bug where it will not resize a border vertically if it should get smaller
	//	set the border table height to a random value to get it to resize
	if (AjxEnv.isNav) {
		var it = this.getContainer().getElementsByTagName('TABLE')[0]; 
		if (it) {
			var height = parseInt(it.style.height);
			if (isNaN(height)) height = 0;
			var newHeight = height;
			while (newHeight == height) {
				newHeight = Math.ceil(Math.random() * 20); 
			}
			it.style.height = newHeight + 'px';
		}
	}
}


/**
* @class defines XFormItem type _GROUPER_
* Draws a simple border around the group, with the label placed over the border
* @contructor
**/
function Grouper_XFormItem() {}
XFormItemFactory.createItemType("_GROUPER_", "grouper", Grouper_XFormItem, Group_XFormItem)
Grouper_XFormItem.prototype.labelCssClass = "GrouperLabel";
Grouper_XFormItem.prototype.labelLocation = _INLINE_;		// managed manually by this class
Grouper_XFormItem.prototype.borderCssClass = "GrouperBorder";
Grouper_XFormItem.prototype.insetCssClass = "GrouperInset";
//Grouper_XFormItem.prototype.colSpan = "*";
//Grouper_XFormItem.prototype.width = "100%";

Grouper_XFormItem.prototype.getBorderCssClass = function () {
	return this.getInheritedProperty("borderCssClass");
}

Grouper_XFormItem.prototype.getInsetCssClass = function () {
	return this.getInheritedProperty("insetCssClass");
}

// output the label
Grouper_XFormItem.prototype.outputHTMLStart = function (html, updateScript, indent, currentCol) {
	html.append(
			"<div class=", this.getBorderCssClass(), ">",
				"<span ", this.getLabelCssString(),">", this.getLabel(), "</span>",
				"<div class=", this.getInsetCssClass(),">"
		);
}

Grouper_XFormItem.prototype.outputHTMLEnd = function (html, updateScript, indent, currentCol) {
	html.append(
			"</div></div>"
		);
}


function RadioGrouper_XFormItem() {}
XFormItemFactory.createItemType("_RADIO_GROUPER_", "radiogrouper", RadioGrouper_XFormItem, Grouper_XFormItem)
RadioGrouper_XFormItem.prototype.labelCssClass = "xform_radio_grouper_label";
RadioGrouper_XFormItem.prototype.borderCssClass = "xform_radio_grouper_border";
RadioGrouper_XFormItem.prototype.insetCssClass = "xform_radio_grouper_inset";
RadioGrouper_XFormItem.prototype.width = "100%";



function CollapsableRadioGrouper_XFormItem() {}
XFormItemFactory.createItemType("_COLLAPSABLE_RADIO_GROUPER_", "collapsableradiogrouper", CollapsableRadioGrouper_XFormItem, RadioGrouper_XFormItem)

CollapsableRadioGrouper_XFormItem.prototype.getLabel = function () {
	var label = XFormItem.prototype.getLabel.apply(this);
	return "<nobr><span class=xform_button style='font-size:9px;color:black;'>&nbsp;&ndash;&nbsp;</span>&nbsp;"+label+"</nobr>";
}




/**
* @class defines XFormItem type _CASE_
* @contructor
**/
function Case_XFormItem() {}
XFormItemFactory.createItemType("_CASE_", "case", Case_XFormItem, Group_XFormItem)

//	type defaults
Case_XFormItem.prototype.labelLocation = _NONE_;
Case_XFormItem.prototype.width = "100%";
Case_XFormItem.prototype.focusable = false;
Case_XFormItem.prototype.deferred = true;

Case_XFormItem.prototype.outputHTML = function (html, updateScript, indent, currentCol) {
	this.getForm().outputItemList([], this, html, updateScript, indent,this.getNumCols(), 0);
//	this.getForm().outputItemList(this.getItems(), this, html, updateScript, indent + "  ",this.getNumCols(), currentCol);
	this.deferred = this.getInheritedProperty("deferred");
	if(this.deferred) {
		this.getForm().outputItemList([], this, html, updateScript, indent,this.getNumCols(), 0);
	} else {
		this.getForm().outputItemList(this.getItems(), this, html, updateScript, indent, this.getNumCols(), currentCol);
	}
}

Case_XFormItem.prototype._outputHTML = function () {
	var form = this.getForm();
	
	var element = this.getElement();
	if(!element) {
		return;
	}
	var masterId = this.getId();
		
	var table = element.getElementsByTagName("table")[0];
	var tbody = element.getElementsByTagName("tbody")[0];

	if (AjxEnv.isIE) {
		var tempDiv = this.createElement("temp",null,"div","");
		tempDiv.display = "none";
	}
	var updateScript = new AjxBuffer();
	var html = new AjxBuffer();
	
	if (this.outputHTMLStart) {
		this.outputHTMLStart(html, updateScript, "", 0);
	}
	
	var drawTable = (this.getUseParentTable() == false);
	if (drawTable) {
		var colSizes = this.getColSizes();
		//XXX MOW: appending an elementDiv around the container if we need to style it
		var outerStyle = this.getCssString();
		if (outerStyle != null && outerStyle != "") {
			this.outputElementDivStart(html, updateScript, "");
		}
		html.append("<table cellspacing=0 cellpadding=0 ", 
				(XForm._showBorder ? "border=1" : "border=0"),
				" id=\"", this.getId(),"_table\" ", this.getTableCssString(),">\r");
		if (colSizes != null) {
			html.append(" <colgroup>\r");
			for (var i = 0; i < colSizes.length; i++) {
				var size = colSizes[i];
				if (size < 1) size = size * 100 + "%";
				html.append("<col width=", size, ">\r");
			}
			html.append("</colgroup>\r");
		}
		html.append("<tbody>\r");
	}
	form.outputItemList(this.getItems(), this, html, updateScript,"", this.getNumCols(), 0, true);
	html.append("</table>");	

	
//	DBG.dumpObj(html.toString());
	element.innerHTML = html.toString();

	/*if (AjxEnv.isIE) {
		tempDiv.innerHTML = "<table>" + html.toString() + "</table>";
		var rows = tempDiv.getElementsByTagName("table")[0].rows;
		for (var r = 0; r < rows.length; r++) {
			tbody.appendChild(rows[r]);
		}
	} else {
		var row = table.insertRow(-1);
		var cell = row.insertCell(-1);
		cell.innerHTML = html;
	}*/

		
	// update the insert and update scripts so they'll be called next time
	form.appendToUpdateScript(updateScript);
	this.deferred = false;		
	// Since this is being called in the middle of update, 
	//	any items that need to be inserted won't have been, 
	//  and we won't have updated the items required.  
	// Handle this now.

	//TODO: PUT this IN THE CORRECT PLACE BY PARSING THE STRING SOMEHOW???
	form.tempScript = new Function(form.getUpdateScriptStart() + updateScript + form.getUpdateScriptEnd());
	form.tempScript();
	delete form.tempScript;
}



/**
* @class defines XFormItem type _TOP_GROUPER_
* Draws a simple border around the group, with the label placed over the border
* @contructor
**/
function TopGrouper_XFormItem() {}
XFormItemFactory.createItemType("_TOP_GROUPER_", "top_grouper", TopGrouper_XFormItem, RadioGrouper_XFormItem)
TopGrouper_XFormItem.prototype.borderCssClass = "xform_top_grouper_border";

// output the label
TopGrouper_XFormItem.prototype.outputHTMLStart = function (html, updateScript, indent, currentCol) {
	html.append(
			"<div class=", this.getBorderCssClass(), ">",
				"<div ", this.getLabelCssString(),">", this.getLabel(), "</div>",
				"<div class=", this.getInsetCssClass(),">"
		);
}

TopGrouper_XFormItem.prototype.outputHTMLEnd = function (html, updateScript, indent, currentCol) {
	html.append(
			"</div></div>"
		);
}




/**
* @class defines XFormItem type _SWITCH_
* @contructor
**/
function Switch_XFormItem() {}
XFormItemFactory.createItemType("_SWITCH_", "switch", Switch_XFormItem, Group_XFormItem)

//	type defaults
Switch_XFormItem.prototype.labelLocation = _NONE_;
Switch_XFormItem.prototype.colSpan = "*";
Switch_XFormItem.prototype.width = "100%";
Switch_XFormItem.prototype.numCols = 1;


/**
* @class defines XFormItem type _REPEAT_
* @contructor
**/
function Repeat_XFormItem() {}
XFormItemFactory.createItemType("_REPEAT_", "repeat", Repeat_XFormItem, Group_XFormItem)

//	type defaults
Repeat_XFormItem.prototype.useParentTable = false;
Repeat_XFormItem.prototype.writeElementDiv = true;
Repeat_XFormItem.prototype.numCols = 1;
Repeat_XFormItem.prototype.number = 1;
Repeat_XFormItem.prototype.showRemoveButton = true;
Repeat_XFormItem.prototype.showAddButton = true;
Repeat_XFormItem.prototype.alwaysShowAddButton = false;
Repeat_XFormItem.prototype.showMoveUpButton = false;
Repeat_XFormItem.prototype.showMoveDownButton = false;

Repeat_XFormItem.prototype.getRemoveButton = function () {
	if(!this.removeButton) {
		this.removeButton = {
			type:_BUTTON_, 
			label: AjxMsg.xformRepeatRemove, 
			//width:20,
			cssStyle:"margin-left:20px;",
			onActivate:function (event) {
				var repeatItem = this.getParentItem().getParentItem();
				repeatItem.removeRowButtonClicked(this.getParentItem().instanceNum);
			},
			relevantBehavior:_HIDE_,
			relevant: "item.__parentItem.getInstanceCount() != 0"
		};
		var label = this.getInheritedProperty("removeButtonLabel");
		if(label)
			this.removeButton.label = label;
	}
	return this.removeButton;	
}

Repeat_XFormItem.prototype.getAddButton = function () {
	if(!this.addButton) {
		var showAddOnNextRow = this.getInheritedProperty("showAddOnNextRow");
		this.addButton = {
			ref:".",
			type:_BUTTON_, 
			label: AjxMsg.xformRepeatAdd, 
			onActivate:function (event) {
				var repeatItem = this.getParentItem().getParentItem();
				repeatItem.addRowButtonClicked(this.getParentItem().instanceNum);
			},
			relevantBehavior:_HIDE_,
			forceUpdate:true
		};
		var label = this.getInheritedProperty("addButtonLabel");
		if(label)
			this.addButton.label = label;			
			
		if(showAddOnNextRow) {
			this.addButton.colSpan = "*";
		}
			
	}
	return this.addButton;	
}

Repeat_XFormItem.prototype.moveUpButton = {
	type:_BUTTON_, 
	label:"^", 
	width:20,
	cssStyle:"margin-left:20px;",
	onActivate:function (event) {
		var repeatItem = this.getParentItem().getParentItem();
		repeatItem.moveUpButtonClicked(this.getParentItem().instanceNum);
	}
}
Repeat_XFormItem.prototype.moveDownButton = {
	ref:".",
	type:_BUTTON_, 
	label:"v", 
	width:20,
	onActivate:function (event) {
		var repeatItem = this.getParentItem().getParentItem();
		repeatItem.moveDownButtonClicked(this.getParentItem().instanceNum);
	},
	relevantBehavior:_HIDE_,
	relevant:"(item.getInstanceCount()-1) == item.__parentItem.instanceNum",
	forceUpdate:true
}


Repeat_XFormItem.prototype.initializeItems = function () {
	var items = this.getItems();

	if (items.length == 1 && items[0].items) {
		var group = items[0];
	} else {
		var group = {	
				ref: this.getRef(), 
				fromRepeat:true, 
//				useParentTable:true,
				type:_GROUP_, 
				numCols: items.length,
				items:[].concat(items)
			};
	}
	
//	group.useParentTable = true;
	group.colSpan = 1;

	var relevant = "(item.instanceNum < " + this.getNumberToShow() + ") || "+
				   "(item.instanceNum < item.getInstanceCount())";
	group.relevant = relevant;
	
	//Check if we have an explicit condition defined for Remove button
	
	// add the add and remove buttons to the original items array, if appropriate
	if (this.getShowRemoveButton()) {
		var button = this.getRemoveButton();
			
		var removeButtonRelevant = this.cacheInheritedProperty("remove_relevant","_remove_relevant");
		if(removeButtonRelevant) {
			button.relevant = removeButtonRelevant;
		} 
		group.items[group.items.length] = button;
		group.numCols++;			
	}
	if (this.getShowAddButton()) {
		var button = this.getAddButton();
	
		var showAddOnNextRow = this.getInheritedProperty("showAddOnNextRow");
		if (!this.getAlwaysShowAddButton()) {
			button.relevant = "(item.getInstanceCount()-1) == item.__parentItem.instanceNum";
		}
		group.items[group.items.length] = button;
		if(showAddOnNextRow) {
			group.items[group.items.length] = {type:_SPACER_, colSpan:(group.numCols-1), relevant:"(item.getInstanceCount()-1) == item.__parentItem.instanceNum"};
		} else {
			group.numCols++;
		}
	}
	if (this.getShowMoveUpButton()) {
		group.items[group.items.length] = this.getMoveUpButton();
		group.numCols++;
	}
	if (this.getShowMoveDownButton()) {
		group.items[group.items.length] = this.getMoveDownButton();
		group.numCols++;
	}

	// save off the original items in the group
	this.__originalItems = group;
	// and reset the items array
	this.items = [];
}

Repeat_XFormItem.prototype.makeRepeatInstance = function() {
	// NOTE: We always append the new items to the end, which is OK,
	//			since if a *data value* is inserted in the middle,
	//			each row will show the proper thing when the update script is called
	//
	//  NOTE: XFORMS SPEC REQUIRES REPEAT ITEMS TO START AT 1, this implementation starts at 0!!!
	//
	var originalGroup = this.__originalItems;
	var numCols = this.getNumCols();
	var newItems = [];
	
	for (var i = 0; i < numCols; i++) {
		var instanceNum = this.items.length;
	
		originalGroup.refPath = this.getRefPath() + "[" + instanceNum + "]";
	
		// initialize the originalGroup and its cloned items
		groupItem = this.getForm().initItem(originalGroup, this);
		groupItem.instanceNum = instanceNum;
	
		newItems.push(groupItem);
		this.items.push(groupItem);
	}	
	return newItems;
}


Repeat_XFormItem.prototype.outputHTML = function (html, updateScript, indent, currentCol) {
	// output one item to start
	//	all other items will be output dynamically
	this.makeRepeatInstance();
	this.getForm().outputItemList(this.items, this, html, updateScript, indent,this.getNumCols(), 0);
}


Repeat_XFormItem.prototype.updateElement = function (value) {
	var form = this.getForm();
	
	var element = this.getElement();
	if (value == null || value === "") value = [];
	var itemsToShow = Math.max(value.length, this.getNumberToShow());
	var slotsPresent = this.items.length;

	var masterId = this.getId();
	if (itemsToShow > slotsPresent) {
		var missingElementCount = (itemsToShow - slotsPresent);
		// create some more slots and show them

		var table = element.getElementsByTagName("table")[0];
		var tbody = element.getElementsByTagName("tbody")[0];
	
		var tempDiv;	
		if (AjxEnv.isIE) {
			tempDiv = this.createElement("temp",null,"div","");
			tempDiv.display = "none";
		}
		var updateScript = new AjxBuffer();
		while (this.items.length < itemsToShow) {
			var newItems = this.makeRepeatInstance(this);
			var html = new AjxBuffer();
			form.outputItemList(newItems, this, html, updateScript, "", this.getNumCols(), 0, true);
			if (AjxEnv.isIE) {
				tempDiv.innerHTML = "<table>" + html.toString() + "</table>";
				var rows = tempDiv.getElementsByTagName("table")[0].rows;
				for (var r = 0; r < rows.length; r++) {
					tbody.appendChild(rows[r]);
				}
			} else {
				var row = table.insertRow(-1);
				row.innerHTML = html;
			}
		}
		
		// update the insert and update scripts so they'll be called next time
		form.appendToUpdateScript(updateScript);
		
		// Since this is being called in the middle of update, 
		//	any items that need to be inserted won't have been, 
		//  and we won't have updated the items required.  
		// Handle this now.

		//TODO: PUT this IN THE CORRECT PLACE BY PARSING THE STRING SOMEHOW???
		form.tempScript = new Function(form.getUpdateScriptStart() + updateScript + form.getUpdateScriptEnd());
		form.tempScript();
		delete form.tempScript;
	}
}





Repeat_XFormItem.prototype.addRowButtonClicked = function (instanceNum) {
	var path = this.getRefPath();
	this.getModel().addRowAfter(this.getInstance(), path, instanceNum);
	this.getForm().refresh();
}

Repeat_XFormItem.prototype.removeRowButtonClicked = function (instanceNum) {
	if (this.getOnRemoveMethod() ) {
		this.getOnRemoveMethod().call(this, instanceNum, this.getForm())
	} else {
		var path = this.getRefPath();
		this.getModel().removeRow(this.getInstance(), path, instanceNum);
	}
	this.getForm().refresh();	
}

Repeat_XFormItem.prototype.getOnRemoveMethod = function() {
	return this.cacheInheritedMethod("onRemove","$onRemove","index,form");
}


/**
* @class defines XFormItem type _REPEAT_GRID_
* @contructor
**/
function Repeat_Grid_XFormItem() {}
XFormItemFactory.createItemType("_REPEAT_GRID_", "repeat_grid", Repeat_Grid_XFormItem, Repeat_XFormItem)
Repeat_Grid_XFormItem.prototype.showRemoveButton = false;
Repeat_Grid_XFormItem.prototype.showAddButton = false;
Repeat_Grid_XFormItem.numCols = 2;





/**
* @class defines XFormItem type _COMPOSITE_
* @contructor
**/
function Composite_XFormItem() {}
XFormItemFactory.createItemType("_COMPOSITE_", "composite", Composite_XFormItem, Group_XFormItem)

//	type defaults
Composite_XFormItem.prototype.useParentTable = false;
Composite_XFormItem.prototype.tableCssClass = "xform_composite_table";
Composite_XFormItem.prototype.focusable = false;

Composite_XFormItem.prototype.initializeItems = function () {
	var items = this.getItems();
	if (items == null) return;
	
	// make sure the numCols is defined (default to the number of items in the composite)
	if (this.numCols == null) this.numCols = items.length;
	
	// actually instantiate them as formItems
	this.items = this.getForm().initItemList(items, this);
}

Composite_XFormItem.onFieldChange = function(value, event, form) {
	if (this.getParentItem() && this.getParentItem().getOnChangeMethod()) {
		return this.getParentItem().getOnChangeMethod().call(this, value, event, form);
	} else {
		return this.setInstanceValue(value);
	}
}

//Composite_XFormItem.prototype.getErrorContainer = function () {
//	
//}









/**
* @class defines XFormItem type _DATE_
* @contructor
**/
function Date_XFormItem() {}
XFormItemFactory.createItemType("_DATE_", "date", Date_XFormItem, Composite_XFormItem)

//	type defaults
Date_XFormItem.prototype.DATE_MONTH_CHOICES = [
				{value:1, label:I18nMsg.monthJanMedium},
				{value:2, label:I18nMsg.monthFebMedium},
				{value:3, label:I18nMsg.monthMarMedium},
				{value:4, label:I18nMsg.monthAprMedium},
				{value:5, label:I18nMsg.monthMayMedium},
				{value:6, label:I18nMsg.monthJunMedium},
				{value:7, label:I18nMsg.monthJulMedium},
				{value:8, label:I18nMsg.monthAugMedium},
				{value:9, label:I18nMsg.monthSepMedium},
				{value:10, label:I18nMsg.monthOctMedium},
				{value:11, label:I18nMsg.monthNovMedium},
				{value:12, label:I18nMsg.monthDecMedium}
			];
Date_XFormItem.prototype.DATE_DAY_CHOICES = ["1","2","3","4","5","6","7","8","9","10","11","12",
						  "13","14","15","16","17","18","19","20","21","22",
						  "23","24","25","26","27","28","29","30","31"];
Date_XFormItem.prototype.numCols = 3;
Date_XFormItem.prototype.items = [
	{	type:_SELECT1_, 
		ref:".",
		width:50,
		valign:_MIDDLE_,
		relevantBehavior:_PARENT_,
		choices: Date_XFormItem.prototype.DATE_MONTH_CHOICES,
		labelLocation:_NONE_,
		getDisplayValue:function (newValue) {
			if (!(newValue instanceof Date)) newValue = new Date();
			return "" + (newValue.getMonth() + 1);
		},
		elementChanged:function (monthStr, currentDate, event) {
			if (currentDate == null) currentDate = new Date();	//??? should get values of other field???
		
			var month = parseInt(monthStr);
			if (!isNaN(month)) {
				month -= 1;
				currentDate.setMonth(month);
			}
			this.getForm().itemChanged(this.getParentItem(), currentDate, event);
		}
	},
	{	type:_SELECT1_, 
		ref:".",
		width:50,
		valign:_MIDDLE_,
		relevantBehavior:_PARENT_,
		labelLocation:_NONE_,
		choices: Date_XFormItem.prototype.DATE_DAY_CHOICES,
		getDisplayValue:function (newValue) {
			if (!(newValue instanceof Date)) newValue = new Date();
			return "" + newValue.getDate();
		},
		elementChanged: function (dateStr, currentDate, event) {
			if (currentDate == null) currentDate = new Date();	//??? should get values of other field???
		
			var date = parseInt(dateStr);
			if (!isNaN(date)) {
				currentDate.setDate(date);
			}
			this.getForm().itemChanged(this.getParentItem(), currentDate, event);
		}
	},
	{	type:_TEXTFIELD_, 
		ref:".",
		relevantBehavior:_PARENT_,
		width:45,
		labelLocation:_NONE_,

		getDisplayValue:function (newValue) {
			if (!(newValue instanceof Date)) newValue = new Date();
			return "" + newValue.getFullYear();
		},
		elementChanged: function (yearStr, currentDate, event) {
			if (currentDate == null) currentDate = new Date();	//??? should get values of other field???
		
			var year = parseInt(yearStr);
			if (!isNaN(year)) {
				currentDate.setYear(year);
			}
			this.getForm().itemChanged(this.getParentItem(), currentDate, event);
		}

	}
];



/**
* @class defines XFormItem type _TIME_
* @contructor
**/
function Time_XFormItem() {}
XFormItemFactory.createItemType("_TIME_", "time", Time_XFormItem, Composite_XFormItem)

//	type defaults
Time_XFormItem.prototype.numCols = 3;
Time_XFormItem.prototype.TIME_HOUR_CHOICES = ["1","2","3","4","5", "6","7","8","9","10","11","12"];
Time_XFormItem.prototype.TIME_MINUTE_CHOICES = ["00","05","10","15","20","25", "30","35","40","45","50","55"];
Time_XFormItem.prototype.TIME_AMPM_CHOICES = [I18nMsg.periodAm,I18nMsg.periodPm];


Time_XFormItem.prototype.items = [
	{	
		type:_SELECT1_, 
		ref:".",
		width:50,
		valign:_MIDDLE_,
		choices: Time_XFormItem.prototype.TIME_HOUR_CHOICES,
		labelLocation:_NONE_,
		getDisplayValue:function (newValue) {
			if (!(newValue instanceof Date)) newValue = new Date();
			var hours = "" + (newValue.getHours() % 12);
			if (hours == "0") hours = "12";
			return hours;
		},
		elementChanged:function (hoursStr, currentDate, event) {
			if (currentDate == null) currentDate = new Date();	//??? should get values of other fields???
			if (this.__dummyDate == null) {
				this.__dummyDate = new Date();
			}
			this.__dummyDate.setTime(currentDate.getTime());
			var hours = parseInt(hoursStr);
			if (!isNaN(hours)) {
				if (hours == 12) hours = 0;
				var wasPM = (currentDate.getHours() > 11);
				if (wasPM) hours += 12;
				this.__dummyDate.setHours(hours);
			}
			var parentItem = this.getParentItem();
			if (parentItem.$elementChanged != null) {
				this.getParentItem().$elementChanged(this.__dummyDate, currentDate, event);
			} else {
				this.getForm().itemChanged(this.getParentItem(), this.__dummyDate, event);
			}
		}
	},

	{	
		type:_SELECT1_, 
		ref:".",
		width:50,
		valign:_MIDDLE_,
		choices: Time_XFormItem.prototype.TIME_MINUTE_CHOICES,
		labelLocation:_NONE_,
		getDisplayValue:function (newValue) {
			if (!(newValue instanceof Date)) newValue = new Date();
			var minutes = newValue.getMinutes();
			minutes = Math.round(minutes / 5) * 5;
			minutes = (minutes < 10 ? "0" + minutes : "" + minutes);
			return minutes;
		},
		elementChanged:function (minutesStr, currentDate, event) {
			if (currentDate == null) currentDate = new Date();	//??? should get values of other fields???
			if (this.__dummyDate == null) {
				this.__dummyDate = new Date();
			}
			this.__dummyDate.setTime(currentDate.getTime());
		
			var minutes = parseInt(minutesStr);
			if (!isNaN(minutes)) {
				this.__dummyDate.setMinutes(minutes);
			}
			var parentItem = this.getParentItem();
			if (parentItem.$elementChanged != null) {
				this.getParentItem().$elementChanged(this.__dummyDate, currentDate, event);
			} else {
				this.getForm().itemChanged(this.getParentItem(), this.__dummyDate, event);
			}
		}
	},
	
	{	
		type:_SELECT1_, 
		ref:".",
		choices: Time_XFormItem.prototype.TIME_AMPM_CHOICES,
		width:50,
		valign:_MIDDLE_,
		labelLocation:_NONE_,
		getDisplayValue:function (newValue) {
			if (!(newValue instanceof Date)) newValue = new Date();
			var hours = newValue.getHours();
			if (hours > 11) return I18nMsg.periodPm;
			return I18nMsg.periodAm;
		},
		elementChanged:function (ampmStr, currentDate, event) {
			if (currentDate == null) currentDate = new Date();	//??? should get values of other fields???
			if (this.__dummyDate == null) {
				this.__dummyDate = new Date();
			}
			this.__dummyDate.setTime(currentDate.getTime());

			var isPM = (ampmStr == I18nMsg.periodPm);
			var hours = currentDate.getHours() % 12;
			
			this.__dummyDate.setHours(hours + (isPM ? 12 : 0));
			var parentItem = this.getParentItem();
			if (parentItem.$elementChanged != null) {
				this.getParentItem().$elementChanged(this.__dummyDate, currentDate, event);
			} else {
				this.getForm().itemChanged(this.getParentItem(), this.__dummyDate, event);
			}
		}
	}
];




/**
* @class defines XFormItem type _DATETIME_
* @contructor
**/
function Datetime_XFormItem() {}
XFormItemFactory.createItemType("_DATETIME_", "datetime", Datetime_XFormItem, Composite_XFormItem)

Datetime_XFormItem._datetimeFormatToItems = function(format, dateItem, timeItem) {
	var items = [];
	var pattern = /{(\d+),\s*(date|time)}/;
	var index = 0;
	while ((index = format.search(pattern)) != -1) {
		if (index > 0) {
			var item = { type: _OUTPUT_, value: format.substring(0,index), valign: _CENTER_ };
			items.push(item);
			format = format.substring(index);
		}
		var result = pattern.exec(format);
		items.push(result[2] == "date" ? dateItem : timeItem);
		format = format.substring(result[0].length);
	}
	if (format.length > 0) {
		var item = { type:_OUTPUT_, value: format };
		items.push(item);
	}
	return items;
}

//	type defaults
Datetime_XFormItem.prototype.numCols = 3;
Datetime_XFormItem.prototype.items = Datetime_XFormItem._datetimeFormatToItems(
	AjxMsg.xformDateTimeFormat,
	{type:_DATE_, ref:".", labelLocation:_NONE_},
	{type:_TIME_, ref:".", labelLocation:_NONE_}
);

/**
* @class defines XFormItem type _WIDGET_ADAPTOR_
*	An adaptor for using any random (non-DWT) widget in an xform
*	NOTE: the generic implementation assumes:
*			1) you'll create a method called "constructWidget()" which will construct the appropriate widget
*			2) the widget has a function "insertIntoXForm(form, item, element)"
*				(overide "this.insertWidget" to change)
*			3) the widget has a function "updateInXForm(form, item, value, element)"
*				(overide "this.updateWidget" to change)
*
* @contructor
**/


function WidgetAdaptor_XFormItem() {}
XFormItemFactory.createItemType("_WIDGET_ADAPTOR_", "widget_adaptor", WidgetAdaptor_XFormItem, XFormItem)

//	type defaults
WidgetAdaptor_XFormItem.prototype.writeElementDiv = true;
WidgetAdaptor_XFormItem.prototype.focusable = false;
//	methods

// implement the following to actually construct the instance of your widget
WidgetAdaptor_XFormItem.prototype.constructWidget = function () {}


//
//	insertElement must guarantee that each element is only inserted ONCE
//
WidgetAdaptor_XFormItem.prototype.insertElement = function (newValue) {
	if (!this.__alreadyInserted) {
		this.__alreadyInserted = true;
		
		// try to construct a widget
		var widget = this.constructWidget();

		// if we didn't get one, there's nothing to do here
		if (widget == null) return;

		// otherwise insert it into the form!
		this.widget = widget;
		this.insertWidget(this.getForm(), this.widget, this.getElement());
	}
}


WidgetAdaptor_XFormItem.prototype.insertWidget = function (form, widget, element) {
	this.widget.insertIntoXForm(form, this, element);
}

WidgetAdaptor_XFormItem.prototype.updateElement = function(newValue) {
	this.updateWidget(newValue);
}
WidgetAdaptor_XFormItem.prototype.updateWidget = function (newValue) {
	this.widget.updateInXForm(this.getForm(), this, newValue, this.getElement());
}





/**
* @class defines XFormItem type _DWT_ADAPTOR_"
*
*	An adaptor for using any random DWT widget in an xform
*
*	NOTE: the generic implementation assumes:
*			1) you'll create a method called "constructWidget()" which will construct the appropriate widget
*			2) you'll adapt "insertWidget(form,  widget, element)" to insert the widget properly
*			3) you'll adapt "updateWidget(newValue)" to update the value properly
* @contructor
**/
function Dwt_Adaptor_XFormItem() {}
XFormItemFactory.createItemType("_DWT_ADAPTOR_", "dwt_adaptor", Dwt_Adaptor_XFormItem, WidgetAdaptor_XFormItem)

//	type defaults
Dwt_Adaptor_XFormItem.prototype.focusable = false;
//	methods

Dwt_Adaptor_XFormItem.prototype.setElementEnabled = function(enabled) {
	WidgetAdaptor_XFormItem.prototype.setElementEnabled.call(this, enabled);
	if (this.widget) {
		this.widget.setEnabled(enabled);
	}
	this._enabled = enabled;
}

// implement the following to actually construct the instance of your widget
Dwt_Adaptor_XFormItem.prototype.constructWidget = function () {}


Dwt_Adaptor_XFormItem.prototype.insertWidget = function (form, widget, element) {
	this.getForm()._reparentDwtObject(widget, element);
}

Dwt_Adaptor_XFormItem.prototype.updateWidget = function (newValue) {}

Dwt_Adaptor_XFormItem.prototype.getDwtSelectItemChoices = function () {
	if (this.__selOption != null) return this.__selOptions;
	
	var selectOptions = null;
	var choices = this.getChoices();
	if (choices != null) {
		var selectOptions = new Array(choices.length);
		for (var i = 0; i < choices.length; i++) {
			var choice = choices[i];
			var choiceValue = (choice instanceof Object ? choice.value : choice);
			var choiceLabel = (choice instanceof Object ? choice.label : choice);
			selectOptions[i] = new DwtSelectOptionData(choiceValue, choiceLabel);
		}
	}
	this.__selOptions = selectOptions;
	return this.__selOptions;
};

Dwt_Adaptor_XFormItem.prototype._addCssStylesToDwtWidget = function () {
	var style = this.getCssStyle();
	if (style != null){
		var styleArr = style.split(";");
		var el = this.widget.getHtmlElement();
		var kp;
		for (var i = 0 ; i < styleArr.length ; ++i ){
			kp = styleArr[i].split(":");
			if (kp.length > 0){
				var key = kp[0];
				if (key != null) {
					key = key.replace(/^(\s)*/,"");
				}
				if (key == "float"){
					key = (AjxEnv.isIE)? "styleFloat": "cssFloat";
				}
				var val = kp[1];
				if (val != null) {
					el.style[key] = val.replace(/^(\s)*/,"");
				}
			}
		}
	}
};

/**
* @class defines XFormItem type  _DWT_BUTTON_
* Adapts a DwtButton to work with the XForm
* @constructor
**/
function Dwt_Button_XFormItem() {}
XFormItemFactory.createItemType("_DWT_BUTTON_", "dwt_button", Dwt_Button_XFormItem, Dwt_Adaptor_XFormItem)

//	type defaults
Dwt_Button_XFormItem.prototype.labelLocation = DwtLabel.IMAGE_LEFT | DwtLabel.ALIGN_CENTER;
Dwt_Button_XFormItem.prototype.writeElementDiv = false;
//	methods

Dwt_Button_XFormItem.prototype.insertWidget = function (form, widget, element) {
	this.getForm()._reparentDwtObject(widget, this.getContainer());
};

// implement the following to actually construct the instance of your widget
Dwt_Button_XFormItem.prototype.constructWidget = function () {
	var widget = this.widget = new DwtButton(this.getForm(), this.getLabelLocation(), this.getCssClass());
	var height = this.getHeight();
	var width = this.getWidth();
	
	var el = null;
	if (width != null || height != null){
		el = widget.getHtmlElement();
		if (width != null) el.style.width = width;
		if (height != null) el.style.height = height;
	} 
	this._addCssStylesToDwtWidget();
	
	var icon = this.getInheritedProperty("icon");
	if(icon != null) {
		widget.setImage(icon);
	}
	
	var disIcon = this.getInheritedProperty("disIcon");
	if(disIcon != null) {
		widget.setDisabledImage(disIcon);
	}
		
	var toolTipContent = this.getInheritedProperty("toolTipContent");
	if(toolTipContent != null) {
		widget.setToolTipContent(toolTipContent);
	}
	
	widget.setText(this.getLabel());

	var onActivateMethod = this.getOnActivateMethod();
	if (onActivateMethod != null) {
		var ls = new AjxListener(this, onActivateMethod);
		widget.addSelectionListener(ls);
	}

	if (this._enabled !== void 0) {
		//this.widget = widget;
		this.setElementEnabled(this._enabled);
	}
	
	return widget;
}

Dwt_Button_XFormItem.prototype.getWidget =
function (){
	return this.widget ;
}

/**	
* @class defines XFormItem type _DWT_SELECT_
* Adapts a DwtSelect to work with the XForm
* @contructor
**/
function Dwt_Select_XFormItem() {}
XFormItemFactory.createItemType("_DWT_SELECT_", "dwt_select", Dwt_Select_XFormItem, Dwt_Adaptor_XFormItem)
//XFormItemFactory.registerItemType("_SELECT1_", "select1", Dwt_Select_XFormItem)

//	type defaults
Dwt_Select_XFormItem.prototype.writeElementDiv = false;
//	methods

Dwt_Select_XFormItem.prototype.insertWidget = function (form, widget, element) {
	this.getForm()._reparentDwtObject(widget, this.getContainer());
}

Dwt_Select_XFormItem.prototype.constructWidget = function () {
	var choices = this.getDwtSelectItemChoices(this.getChoices());

	var widget = this.widget = new DwtSelect(this.getForm(), choices);
	var height = this.getHeight();
	var width = this.getWidth();
	if (width != null || height != null){
		var el = widget.getHtmlElement();
		if (width != null) el.style.width = width;
		if (height != null) el.style.height = height;
	} 
	this._addCssStylesToDwtWidget();

	var onChangeFunc = new Function("event", 
			"var widget = event._args.selectObj;\r"
		  + "value = event._args.newValue; " + this.getExternalChangeHandler()
	);
	var ls = new AjxListener(this.getForm(), onChangeFunc);
	widget.addChangeListener(ls);

	if (this._enabled !== void 0) {
		//this.widget = widget;
		this.setElementEnabled(this._enabled);
	}
	return widget;
}

Dwt_Select_XFormItem.prototype.updateWidget = function (newValue) {
	this.widget.setSelectedValue(newValue);
}

Dwt_Select_XFormItem.prototype.setElementEnabled = function (enable) {
	this._enabled = enable;
	if (this.widget == null) return;
	if (enable) {
		this.widget.enable();
	} else {
		this.widget.disable();
	}
};




/**	
* @class defines XFormItem type _DWT_DATE_
* Adapts a DwtDate to work with the XForm
* @contructor
**/
function Dwt_Date_XFormItem() {}
XFormItemFactory.createItemType("_DWT_DATE_", "dwt_date", Dwt_Date_XFormItem, Dwt_Adaptor_XFormItem)


//	type defaults
Dwt_Date_XFormItem.prototype.cssStyle = "width:80px;";


//	methods

Dwt_Date_XFormItem.prototype.constructWidget = function () {

	var widget = new DwtButton(this.getForm());
	widget.setActionTiming(DwtButton.ACTION_MOUSEDOWN);

	// ONE MENU??
	var menu = this.menu = new DwtMenu(widget, DwtMenu.CALENDAR_PICKER_STYLE, null, null, this.getForm());
	widget.setMenu(menu, true)
	menu.setAssociatedObj(widget);

	// For now, create a new DwtCalendar for each of the buttons, since on
	// IE, I'm having trouble getting the one calendar to work.
	// TODO: Figure out the IE problem.
	var cal = new DwtCalendar(menu);
	cal._invokingForm = this.getForm();
	cal._invokingFormItemId = this.getId();
	cal.addSelectionListener(new AjxListener(this, this._calOnChange));
	widget.__cal = cal;
	
	// create a static instance of DwtCalendar that all instances will show
	//if (window.DwtCalendar && (this.constructor._calendarPopup == null)) {
		// DO WE NEED TO CONSTRUCT A MENU HERE FIRST???
		//	CAN THE MENU BE SHARED???
	//	var cal = this.constructor._calendarPopup = new DwtCalendar(menu);
	//	cal.addSelectionListener(new AjxListener(this, this._calOnChange));
	//}

	// We have to add listeners both for the drop down cell, and 
	// the button proper, to get notified when any part of the 
	// button is hit.
	//widget.addSelectionListener(new AjxListener(this, this._prePopup));
	//widget.addDropDownSelectionListener(new AjxListener(this, this._prePopup));
	// NOTE: WHEN THE BUTTON IS PRESSED, WE WANT TO CALL:
	//var cal = this.constructor._calendarPopup;
	//cal.setDate(this.widget._date, true);
	//cal._invokingForm = this.getForm();
	//cal._invokingFormItemId = this.getId();
	//cal.reparent(event.item.getMenu());
	//	THEN SHOW THE THING... ???

	return widget;
}

Dwt_Date_XFormItem.prototype.updateWidget = function (newValue) {
	if (newValue == null) newValue = new Date();
	this.widget.setText(this.getButtonLabel(newValue));
	this.widget._date = newValue;
	this.widget.__cal.setDate(newValue,true);
};

Dwt_Date_XFormItem.prototype._calOnChange = function (event) {
	var value = event.detail;
	var cal = event.item;
	var elemChanged = this.getElementChangedMethod();
	elemChanged.call(this,value, this.getInstanceValue(), event);	
};

Dwt_Date_XFormItem.prototype._prePopup = function (event) {
	var cal = this.constructor._calendarPopup;
	cal.setDate(this.widget._date, true);
	cal._invokingForm = this.getForm();
	cal._invokingFormItemId = this.getId();
	cal.reparent(event.item.getMenu());
	event.item._toggleMenu();
};

Dwt_Date_XFormItem.prototype.getButtonLabel = function (newValue) {
	if (newValue == null || !(newValue instanceof Date)) return "";
	return (newValue.getMonth()+1) + "/" + newValue.getDate() + "/" + (newValue.getFullYear());
};


function Dwt_Time_XFormItem() {
	this.items[0].type = _DWT_SELECT_;
	this.items[0].errorLocation = _INHERIT_;
	this.items[1].type = _DWT_SELECT_;
	this.items[1].errorLocation = _INHERIT_;
	this.items[1].choices = Dwt_Time_XFormItem.TIME_MINUTE_CHOICES;
	this.items[1].getDisplayValue = function (newValue) {
		if (!(newValue instanceof Date)) newValue = new Date();
		var ret = AjxDateUtil._pad(AjxDateUtil.getRoundedMins(newValue, 15));
		return ret;
	};
	this.items[2].type = _DWT_SELECT_;
	this.items[2].errorLocation = _INHERIT_;
}
Dwt_Time_XFormItem.TIME_MINUTE_CHOICES = ["00","15","30","45"];
XFormItemFactory.createItemType("_DWT_TIME_", "dwt_time", Dwt_Time_XFormItem, Time_XFormItem);


/**	
* @class defines XFormItem type _DWT_DATETIME_
* Composes a _DWT_DATE_ and a (non-DWT) _TIME_ to make a date/time editor, just for kicks.
* @contructor
**/
function Dwt_Datetime_XFormItem() {}
XFormItemFactory.createItemType("_DWT_DATETIME_", "dwt_datetime", Dwt_Datetime_XFormItem, Composite_XFormItem)

//	type defaults
Dwt_Datetime_XFormItem.prototype.numCols = 3;
Dwt_Datetime_XFormItem.prototype.useParentTable = false;
Dwt_Datetime_XFormItem.prototype.cssClass =  "xform_dwt_datetime";
Dwt_Datetime_XFormItem.prototype.items = Datetime_XFormItem._datetimeFormatToItems(
	AjxMsg.xformDateTimeFormat,
	{type:_DWT_DATE_, ref:".", labelLocation:_NONE_, errorLocation:_PARENT_,
	 elementChanged: 
	 function (newDate, currentDate, event) {
		 newDate.setHours(currentDate.getHours(), currentDate.getMinutes(), currentDate.getSeconds(), 0);
		 this.getParentItem().$elementChanged(newDate, currentDate, event);
	 }
	},
	{type:_DWT_TIME_, ref:".", labelLocation:_NONE_, errorLocation:_PARENT_, 
	 elementChanged:
	 function (newDate, currentDate, event) {
		 this.getParentItem().$elementChanged(newDate, currentDate, event);
	 }
	}
);


/**	
* @class defines XFormItem type _DWT_LIST_
* @contructor
**/
function Dwt_List_XFormItem() {}
XFormItemFactory.createItemType("_DWT_LIST_", "dwt_list", Dwt_List_XFormItem, Dwt_Adaptor_XFormItem)

//	type defaults
Dwt_List_XFormItem.prototype.writeElementDiv = false;
Dwt_List_XFormItem.prototype.widgetClass = DwtListView;

Dwt_List_XFormItem.prototype.getOnSelectionMethod = function() {
	return this.cacheInheritedMethod("onSelection","$onSelection","event");
}


Dwt_List_XFormItem.prototype.constructWidget = function () {
	var headerList = this.getInheritedProperty("headerList");
	var listClass = this.getInheritedProperty("widgetClass");

	var widget = new listClass(this.getForm(), this.getCssClass(), null, headerList);
	var multiselect = this.getInheritedProperty("multiselect");
	if(multiselect != undefined) {
		widget.setMultiSelect(multiselect);
	}
	var width = this.getWidth();
	var height = this.getHeight();
	if(width && height)
		widget.setSize(width, height);
		
	// make sure the user defined listener is called 
	// before our selection listener.
	var selMethod = this.getOnSelectionMethod();
	if (selMethod) {
		widget.addSelectionListener(new AjxListener(this, selMethod));
	}

	var localLs = new AjxListener(this, this._handleSelection);
	widget.addSelectionListener(localLs);
	//check if createPopupMenu method is defined
	var createPopupMenumethod = this.cacheInheritedMethod("createPopupMenu","$createPopupMenu","parent");
	if(createPopupMenumethod != null) {
		createPopupMenumethod.call(this, widget);
	}
	
	return widget;
};

Dwt_List_XFormItem.prototype.getSelection = function () {
	return this.widget.getSelection();
};

Dwt_List_XFormItem.prototype._handleSelection = function (event) {
	this.getForm().refresh();
};

Dwt_List_XFormItem.prototype.insertWidget = function (form, widget, element) {
	this.getForm()._reparentDwtObject(widget, this.getContainer());
};

Dwt_List_XFormItem.prototype.updateWidget = function (newValue) {
	if (typeof (newValue) != 'undefined') {
		this.setItems(newValue);
	}
};

Dwt_List_XFormItem.prototype.setItems = function (itemArray){
	var list = this.widget.getList();
	var existingArr = [];
	var tmpArr = new Array();
	if (list) {
		existingArr = list.getArray();
	}
	tmpArr = new Array();
	
	//we have to compare the objects, because XForm calls this method every time an item in the list is selected
	if(itemArray.join() != existingArr.join() ) {
		var preserveSelection = this.getInheritedProperty("preserveSelection");
		var selection = null;
		if(preserveSelection) {
			selection = this.widget.getSelection();
		}		
		var cnt=itemArray.length;
		for(var i = 0; i< cnt; i++) {
			tmpArr.push(itemArray[i]);		
		}
		this.widget.set(AjxVector.fromArray(tmpArr));
		if(preserveSelection && selection) {
			this.widget.setSelectedItems(selection);
		}
	}
};

Dwt_List_XFormItem.prototype.appendItems = function (itemArray){ 
	this.widget.addItems(itemArray);
};


/**	
* @class defines XFormItem type _BUTTON_GRID_
* @contructor
**/
function Button_Grid_XFormItem() {}
XFormItemFactory.createItemType("_BUTTON_GRID_", "button_grid", Button_Grid_XFormItem, WidgetAdaptor_XFormItem)

//	type defaults
Button_Grid_XFormItem.prototype.numCols = 5;
Button_Grid_XFormItem.prototype.cssClass = "xform_button_grid_medium";
Button_Grid_XFormItem.prototype.forceUpdate = true;


//	methods
Button_Grid_XFormItem.prototype.constructWidget = function () {
	var changeHandler = this.getExternalChangeHandler();
	var attributes = {
		numCols:this.getNumCols(),
		choices:choices.getChoiceObject(),
		cssClass:this.getCssClass(),
		onChange:changeHandler,
		addBracketingCells:(this.getAlign() == _CENTER_)
	}
	var multiple = this.getMultiple();
	if (multiple !== null) attributes.multiple = multiple;
	return new ButtonGrid(attributes);
}


/**	
* @class defines XFormItem type _TAB_BAR_
* A simple tab (for switching a switch)
* @contructor
**/
function Tab_Bar_XFormItem() {}
XFormItemFactory.createItemType("_TAB_BAR_", "tab_bar", Tab_Bar_XFormItem, Button_Grid_XFormItem)

//	type defaults
Tab_Bar_XFormItem.prototype.multiple = false;
Tab_Bar_XFormItem.prototype.cssClass = "xform_button_grid_tab";
Tab_Bar_XFormItem.prototype.align = _CENTER_;
Tab_Bar_XFormItem.prototype.colSpan = "*";

//	methods

Tab_Bar_XFormItem.prototype.constructWidget = function () {
	var changeHandler = this.getExternalChangeHandler();
	var attributes = {
		numCols:this.getNumCols(),
		cssClass:this.getCssClass(),
		onChange:changeHandler,
		addBracketingCells:(this.getAlign() == _CENTER_)
	}

	var choices = this.getChoices();
	if(choices.constructor == XFormChoices) {
		attributes.choices = choices.getChoiceObject();
	} else {
		attributes.choices = choices;
	}
	var multiple = this.getMultiple();
	if (multiple !== null) attributes.multiple = multiple;
	return new ButtonGrid(attributes);
}

Tab_Bar_XFormItem.prototype.initFormItem = function() {
	this.choices = this.getChoices();

	if(!this.choices)
		return;
	if(this.choices.constructor == XFormChoices) {
		var listener = new AjxListener(this, this.dirtyDisplay);
		this.choices.addListener(DwtEvent.XFORMS_CHOICES_CHANGED, listener);	
		this.numCols = this.getChoices().values.length;
	} else {
		this.numCols = this.getChoices().length;
	}
}

Tab_Bar_XFormItem.prototype.dirtyDisplay = function(newChoices) {
	//this.dirtyDisplay();
	if(this.choices.constructor == XFormChoices) {
		this.widget.updateChoicesHTML(this.getNormalizedLabels());	
	}
}

/**	
* @class defines XFormItem type _DWT_ADD_REMOVE_
* @contructor
**/
function Dwt_AddRemove_XFormItem() {}
XFormItemFactory.createItemType("_DWT_ADD_REMOVE_", "add_remove", Dwt_AddRemove_XFormItem, Dwt_Adaptor_XFormItem);

/***
NOTE: this won't work because attributes.ref is accessed before this
method is called in XFormItemFactory#createItem.
Dwt_AddRemove_XFormItem.prototype._setAttributes = function(attributes) {
	// allows "targetRef" alias for "ref" attribute
	if (!attributes.ref && attributes.targetRef) {
		attributes.ref = attributes.targetRef;
	}
	XFormItem.prototype._setAttributes.call(this, attributes);
}
**/
Dwt_AddRemove_XFormItem.prototype.getSorted = function() {
	return this.getInheritedProperty("sorted");
}
Dwt_AddRemove_XFormItem.prototype.getListCssClass = function() {
	return this.getInheritedProperty("listCssClass");
}

Dwt_AddRemove_XFormItem.prototype.getTargetListCssClass = function() {
	return this.getInheritedProperty("targetListCssClass");
}

Dwt_AddRemove_XFormItem.prototype.getSourceInstanceValue = function() {
	var items = this.getModel().getInstanceValue(this.getInstance(), this.getInheritedProperty("sourceRef"));
	return items ? items : [];
}

Dwt_AddRemove_XFormItem.prototype.getTargetInstanceValue = function() {
	var items = this.getInstanceValue();
	return items ? items : [];
}

Dwt_AddRemove_XFormItem.prototype._handleStateChange = function(event) {
	var form = this.getForm();
	var id = this.getId();
	var widget = this.getWidget();
	var value = widget.getTargetItems();
	form.itemChanged(id, value);
}

Dwt_AddRemove_XFormItem.prototype.constructWidget = function() {
	var form = this.getForm();
	var cssClass = this.getCssClass();
	var sourceListCssClass = this.getListCssClass();
	var targetListCssClass = this.getTargetListCssClass();
	var widget = new DwtAddRemove(form, cssClass, null, sourceListCssClass, targetListCssClass);
	return widget;
}

Dwt_AddRemove_XFormItem.prototype.updateWidget = function(newvalue) {
	if (this.widget.isUpdating) {
		this.widget.isUpdating = false;
		return;
	}
	if (this._skipUpdate) {
		return;
	}

	if (this._stateChangeListener) {
		this.widget.removeStateChangeListener(this._stateChangeListener);
	}
	else {
		this._stateChangeListener = new AjxListener(this, Dwt_AddRemove_XFormItem.prototype._handleStateChange)
	}

	var sourceItems = this.getSourceInstanceValue();
	var targetItems = this.getTargetInstanceValue();

	var sorted = this.getSorted();
	if (sorted) {
		sourceItems = sourceItems.sort();
		targetItems = targetItems.sort();
	}

	this.widget.setSourceItems(sourceItems);
	this.widget.removeSourceItems(targetItems);
	this.widget.setTargetItems(targetItems);

	this.widget.addStateChangeListener(this._stateChangeListener);
}

//
// XFormItem class: "alert"
//

function Dwt_Alert_XFormItem() {}
XFormItemFactory.createItemType("_DWT_ALERT_", "alert", Dwt_Alert_XFormItem, Dwt_Adaptor_XFormItem);

Dwt_Alert_XFormItem.prototype.colSpan = "*";
Dwt_Alert_XFormItem.prototype.labelLocation = _NONE_;

Dwt_Alert_XFormItem.prototype.getStyle = function() {
	return this.getInheritedProperty("style");
}
Dwt_Alert_XFormItem.prototype.getIconVisible = function() {
	return this.getInheritedProperty("iconVisible");
}
Dwt_Alert_XFormItem.prototype.getTitle = function() {
	return this.getInheritedProperty("title");
}
Dwt_Alert_XFormItem.prototype.getContent = function() {
	return this.getInheritedProperty("content");
}
Dwt_Alert_XFormItem.prototype.getAlertCssClass = function() {
	return this.getInheritedProperty("alertCssClass");
}

Dwt_Alert_XFormItem.prototype.constructWidget = function() {
	var style = this.getStyle();
	var iconVisible = this.getIconVisible();
	var title = this.getTitle();
	var content = this.getContent();
	var alertCssClass = this.getAlertCssClass();
	
	var form = this.getForm();
	var alert = new DwtAlert(form, alertCssClass);
	
	alert.setStyle(style);
	alert.setIconVisible(iconVisible);
	alert.setTitle(title);
	alert.setContent(content);
	
	return alert;
}

Dwt_Alert_XFormItem.prototype.updateWidget = function(newvalue) {
	// nothing
	var content = this.getContent();
	if(!content && newvalue) {
		this.getWidget().setContent(newvalue);
	}
}

//
// XFormItem class: "dwt_tab_bar"
//

function Dwt_TabBar_XFormItem() {}
XFormItemFactory.createItemType("_DWT_TAB_BAR_", "dwt_tab_bar", Dwt_TabBar_XFormItem, Dwt_Adaptor_XFormItem);
Dwt_TabBar_XFormItem.prototype.colSpan = "*";
Dwt_TabBar_XFormItem.prototype.labelLocation = _NONE_;
// NOTE: Overriding the _TAB_BAR_
XFormItemFactory.registerItemType(_TAB_BAR_, "tab_bar", Dwt_TabBar_XFormItem);

Dwt_TabBar_XFormItem.prototype._value2tabkey;
Dwt_TabBar_XFormItem.prototype._tabkey2value;

Dwt_TabBar_XFormItem.prototype._stateChangeListener;

Dwt_TabBar_XFormItem.prototype.getChoices = function() {
	return this.getInheritedProperty("choices");
}

Dwt_TabBar_XFormItem.prototype._handleStateChange = function(event) {
	var form = this.getForm();
	var widget = this.getWidget();
	
	var tabKey = widget.getCurrentTab();
	var newvalue = this._tabkey2value[tabKey];
	
	var id = this.getId();
	form.itemChanged(id, newvalue);
}

Dwt_TabBar_XFormItem.prototype.constructWidget = function() {
	var form = this.getForm();
	var cssClass = this.getCssClass();
	var btnCssClass = this.getInheritedProperty("buttonCssClass");	
	
	//var widget = new DwtTabView(form, cssClass, DwtControl.STATIC_STYLE);
	var widget = new DwtTabBar(form, cssClass, btnCssClass);
	this._value2tabkey = {};
	this._tabkey2value = {};
	
	var choices = this.getChoices();
	if(choices.constructor == XFormChoices) {
		this.choices = choices;
		var listener = new AjxListener(this, this.dirtyDisplay);
		choices.addListener(DwtEvent.XFORMS_CHOICES_CHANGED, listener);	
		
		var values = this.getNormalizedValues();
		var labels = this.getNormalizedLabels();
		var cnt = values.length;
		for (var i = 0; i < cnt; i++) {
			// NOTE: DwtTabView keeps its own internal keys that are numerical
			this._value2tabkey[values[i]] = i + 1;
			this._tabkey2value[i + 1] = values[i];
	//		var page = new DwtTabViewPage(widget);
			widget.addButton(i+1, labels[i]);
			//widget.addTab(choice.label, page);
		}			
	} else {
		var cnt = choices.length;
		for (var i = 0; i < cnt; i++) {
			var choice = choices[i];
			// NOTE: DwtTabView keeps its own internal keys that are numerical
			this._value2tabkey[choice.value] = i + 1;
			this._tabkey2value[i + 1] = choice.value;
	//		var page = new DwtTabViewPage(widget);
			widget.addButton(i+1, choice.label);
			//widget.addTab(choice.label, page);
		}
	}
	
	return widget;
}

Dwt_TabBar_XFormItem.prototype.updateWidget = function(newvalue) {
	if (this.widget.isUpdating) {
		this.widget.isUpdating = false;
		return;
	}

	if (this._stateChangeListener) {
		this.widget.removeStateChangeListener(this._stateChangeListener);
	}
	else {
		this._stateChangeListener = new AjxListener(this, Dwt_TabBar_XFormItem.prototype._handleStateChange);
	}
	
	var tabKey = this._value2tabkey[newvalue];
	if (tabKey != this.widget.getCurrentTab()) {
		//this.widget.switchToTab(tabKey);
		this.widget.openTab(tabKey);
	}

	this.widget.addStateChangeListener(this._stateChangeListener);
}

Dwt_TabBar_XFormItem.prototype.dirtyDisplay = function() {
	if(this.choices && this.choices.constructor == XFormChoices) {
		var labels = this.getNormalizedLabels();
		var values = this.getNormalizedValues();
		var cnt = labels.length;
		for(var i=0;i<cnt;i++) {
			var tabKey = this._value2tabkey[values[i]];
			if(tabKey) {
				var btn = this.widget.getButton(tabKey);
				if(btn) {
					btn.setText(labels[i]);
				}
			}
		}
	}
	this._choiceDisplayIsDirty = true;
	delete this.$normalizedChoices;	
}

//
// XFormItem class: "alert"
//

function Dwt_ProgressBar_XFormItem() {}
XFormItemFactory.createItemType("_DWT_PROGRESS_BAR_", "dwt_progress_bar", Dwt_ProgressBar_XFormItem, Dwt_Adaptor_XFormItem);

Dwt_ProgressBar_XFormItem.prototype.constructWidget = function() {
	var form = this.getForm();
	var widget = new DwtProgressBar(form, null);
	var maxvalue = this.getInheritedProperty("maxValue");
	if(!maxvalue) {
		this.maxValueRef = this.getInheritedProperty("maxValueRef");
		maxvalue = this.getModel().getInstanceValue(this.getInstance(), this.maxValueRef)
	}
	widget.setMaxValue(maxvalue);
	
	var progressCssClass = this.getInheritedProperty("progressCssClass");
	if(progressCssClass) {
		widget.setProgressCssClass(progressCssClass);
	}
	
	var wholeCssClass = this.getInheritedProperty("wholeCssClass");
	if(wholeCssClass) {
		widget.setWholeCssClass(wholeCssClass);
	}	
	return widget;
}

Dwt_ProgressBar_XFormItem.prototype.updateWidget = function(newvalue) {
	// nothing
//	var maxValueRef = this.getInheritedProperty("maxValueRef");
	if(!newvalue)
		newvalue=0;
	if(this.maxValueRef) {
		maxvalue = this.getModel().getInstanceValue(this.getInstance(), this.maxValueRef)
		this.getWidget().setMaxValue(maxvalue);	
	}
	this.getWidget().setValue(newvalue);
}/*
* ***** BEGIN LICENSE BLOCK *****
* Version: MPL 1.1
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 ("License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.zimbra.com/license
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
* the License for the specific language governing rights and limitations
* under the License.
*
* The Original Code is: Zimbra AJAX Toolkit.
*
* The Initial Developer of the Original Code is Zimbra, Inc.
* Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
* All Rights Reserved.
*
* Contributor(s):
*
* ***** END LICENSE BLOCK *****
*/


function XFormChoices(choiceObject, type, valueProperty, labelProperty) {
	if (arguments.length == 0) return;
	
	if (choiceObject != null) this._choiceObject = choiceObject;
	if (type != null) this._type = type;
	if (valueProperty != null) this._valueProperty = valueProperty;
	if (labelProperty != null) this._labelProperty = labelProperty;
	
	this._choiceChangeTime = new Date().getTime();
	this._lastNormalizeTime = 0;
	
	if (this._type == XFormChoices.AUTO) this.autoDetermineType();
	
	this._eventMgr = new AjxEventMgr();
}
XFormChoices.prototype = new Object();
XFormChoices.prototype.constructor = XFormChoices;


//
//	static methods
//
XFormChoices.normalizeChoices = function (choices, type, valueProperty, labelProperty) {
	var values;
	var labels;
	switch (type) {
		case XFormChoices.SIMPLE_LIST:
			values = [].concat(choices)
			labels = [].concat(choices)
		
			break;


		case XFormChoices.OBJECT_LIST:
			values = []; labels = [];
			if (valueProperty == null) valueProperty = "value";
			if (labelProperty == null) labelProperty = "label";
			for (var i = 0; i < choices.length; i++) {
				values.push(choices[i][valueProperty]);
				labels.push(choices[i][labelProperty]);
			}
		
			break;
		case XFormChoices.OBJECT_REFERENCE_LIST:
			values = []; labels = [];
			if (labelProperty == null) labelProperty = "label";
			for (var i = 0; i < choices.length; i++) {
				values.push(choices[i]);
				labels.push(choices[i][labelProperty]);
			}		
			break;	

		case XFormChoices.HASH:
			values = []; labels = [];
			for (var prop in choices) {
				values.push(prop);
				labels.push(choices[prop]);
			}
		
			break;
	}
	return {values:values, labels:labels};
}


// constants
XFormChoices.AUTO = "auto";
XFormChoices.SIMPLE_LIST = "list";
XFormChoices.HASH = "hash";
XFormChoices.OBJECT_LIST = "object";
XFormChoices.OBJECT_REFERENCE_LIST = "object_reference_list";

// type defaults
XFormChoices.prototype._type = XFormChoices.AUTO;
XFormChoices.prototype._valueProperty = "value";
XFormChoices.prototype._labelProperty = "label";


XFormChoices.prototype.getChoiceObject = 
function () {
	return this._choiceObject;
}

XFormChoices.prototype.autoDetermineType = function () {
	var type;

	var choices = this._choiceObject;
	if (choices) {
		if (AjxUtil.isArray(choices)) {
			var firstChoice = choices[0];
			if (AjxUtil.isObject(firstChoice)) {
				type = XFormChoices.OBJECT_LIST;
			} else {
				type = XFormChoices.SIMPLE_LIST;
			}
		} else if (AjxUtil.isObject(choices)) {
			type = XFormChoices.HASH;
		}
	}
	
	if (type == null) type = XFormChoices.SIMPLE_LIST;
	this._type = type;
}

XFormChoices.prototype.setChoices = function (choiceObject) {
	this._choiceObject = choiceObject;
}

XFormChoices.prototype.getChoices = function () {
	// only normalize if dirty
	if (this._lastNormalizeTime == this._choiceChangeTime && this.$normalizedChoices) {
		return this.$normalizedChoices;
	}
	this._lastNormalizeTime = this._choiceChangeTime;

	this.$normalizedChoices = XFormChoices.normalizeChoices(this._choiceObject, this._type, this._valueProperty, this._labelProperty);
	return this.$normalizedChoices;
}

XFormChoices.prototype.getChoiceByValue = function(value) {
	switch (this._type) {
		case XFormChoices.SIMPLE_LIST: 
			return value;
			break;
		
		case XFormChoices.OBJECT_LIST: 
			var valueProperty = this._valueProperty || "value";
			for (var i = 0; i < this._choiceObject.length; i++) {
				if (this._choiceObject[i][valueProperty] == value) {
					return this._choiceObject[i];
				}
			}
			break;
		
		case XFormChoices.OBJECT_REFERENCE_LIST:
			for (var i = 0; i < this._choiceObject.length; i++) {
				if (this._choiceObject[i] == value) {
					return this._choiceObject[i];
				}
			}
			break;
		case XFormChoices.HASH: 
			return this._choiceObject[value];
		break;
	}
	return null;
}

XFormChoices.prototype.dirtyChoices = function () {
	this._choiceChangeTime = new Date().getTime();
	this.notifyListeners(DwtEvent.XFORMS_CHOICES_CHANGED, {});
}






//
//	listening -- these are from DwtControl  -- make an installable interface?
//
XFormChoices.prototype.addListener = function(eventType, listener) {
	return this._eventMgr.addListener(eventType, listener); 	
}

XFormChoices.prototype.notifyListeners = function(eventType, event) {
	return this._eventMgr.notifyListeners(eventType, event);
}

XFormChoices.prototype.isListenerRegistered = function(eventType) {
	return this._eventMgr.isListenerRegistered(eventType);
}

XFormChoices.prototype.removeListener =  function(eventType, listener) {
	return this._eventMgr.removeListener(eventType, listener);
}
/*
 * Copyright (C) 2006, The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
* @class OSelect1_XFormItem class -- lightning fast SELECT type widget
* @constructor
* @author Owen Williams, Greg Solovyev
**/
function OSelect1_XFormItem(){ this._enabled = true; }
XFormItemFactory.createItemType("_OSELECT1_", "oselect1", OSelect1_XFormItem, Select1_XFormItem);

OSelect1_XFormItem._mouseWheelEventAttached = false;
OSelect1_XFormItem._mouseWheelCurrentSelect;
OSelect1_XFormItem._mouseWheelHideMenu = function() {
	OSelect1_XFormItem._mouseWheelCurrentSelect.hideMenu();
};

// override the default SELECT type
//XFormItemFactory.registerItemType("_SELECT1_", "select1", OSelect1_XFormItem)
OSelect1_XFormItem.prototype.focusable = false;
OSelect1_XFormItem.prototype.cssClass = "oselect";
OSelect1_XFormItem.prototype.multiple = false;
OSelect1_XFormItem.prototype.writeElementDiv = false;
OSelect1_XFormItem.prototype.width = "auto";
OSelect1_XFormItem.prototype.editable = false;

//TODO: get showing check working for the normal SELECT, requires:
//		* separate notion of hilited row (for mouseover) and selected row(s)
//		* teach select1 that more than one value may be selected (same as select)
//		* convert OSELECT_CHECK to just use showCheck?
//		* does &radic; work everywhere?  Use an image?
OSelect1_XFormItem.prototype.showCheck = false;
OSelect1_XFormItem.prototype.checkHTML = "&radic;";


OSelect1_XFormItem.prototype.updateElement = function (newValue) {
	// hack: if this item can display multiple values and there's a comma in the value
	//		assume it's a list of values
	if (this.getMultiple() && newValue != null && newValue.indexOf(",") > -1) {
		newValue = newValue.split(",");
		for (var i = 0; i < newValue.length; i++) {
			newValue[i] = this.getChoiceLabel(newValue[i]);
		}
	} else {
		newValue = this.getChoiceLabel(newValue);
	}
	if (newValue == null) newValue = "";
	
	var el = this.getDisplayElement();

	if (el) {
		if(this.getInheritedProperty("editable")) {
			el.value = newValue;
		} else {
			el.innerHTML = newValue;
		}
		//el.readOnly = !this.getInheritedProperty("editable");
	}
}

OSelect1_XFormItem.prototype.getShowCheck = function () {
	return this.cacheInheritedProperty("showCheck", "$showCheck");
}

OSelect1_XFormItem.prototype.getCheckHTML = function () {
	return this.cacheInheritedProperty("checkHTML", "$checkHTML");
}


OSelect1_XFormItem.prototype.getMenuElementId = function () {
	return "___OSELECT_MENU___";
}
OSelect1_XFormItem.prototype.getMenuElement = function () {
	var id = this.getMenuElementId();
	var el = this.getElement(id);
	if (el == null) {
		el = this.createElement(id, null, "div", "MENU CONTENTS");
	}
	return el;
}


OSelect1_XFormItem.prototype.showMenu = function() {
	if(!this._enabled)
		return;

	if (AjxEnv.isIE && !OSelect1_XFormItem._mouseWheelEventAttached) {
		var form = this.getForm();
		var formElement = form.getHtmlElement();
		if (formElement.attachEvent) {
			formElement.attachEvent("onmousewheel", OSelect1_XFormItem._mouseWheelHideMenu);
			OSelect1_XFormItem._mouseWheelCurrentSelect = this;
			OSelect1_XFormItem._mouseWheelEventAttached = true;
		}
	}

	var menu = this.getMenuElement();
	if (menu == null) return; 

	menu.className = this.getMenuCssClass();
	menu.innerHTML = this.getChoicesHTML();	
	var bounds;
	bounds = this.getBounds(this.getElement().childNodes[0]);

	var w = DwtShell.getShell(window).getSize();
	var wh = w.y;
	var WINDOW_GUTTER = 8;
	menu.style.left = parseInt(bounds.left);
	menu.style.top = parseInt(bounds.top) + parseInt(bounds.height) - 1;
	var choices = this.getNormalizedChoices();
	if(choices && choices.values) {
	//	menu.style.width = bounds.width;
		//menu.style.overflow="hidden";
		menu.style.overflow="visible";
		//var height4win = (parseInt(bounds.height-3)*choices.values.length)+3;
		//var height4linux = (parseInt(bounds.height + 2)*choices.values.length)+3;
		menu.style.height = (parseInt(bounds.height-3)*choices.values.length)+3;
	}

	var value = this.getInstanceValue();
	if (this.$getDisplayValue) {
		value = this.$getDisplayValue(value);
	}
	var selectedItemNum = this.getChoiceNum(value);
	this.__currentHiliteItem = selectedItemNum;
	this.hiliteChoice(selectedItemNum);
	menu.style.zIndex = Dwt.Z_HIDDEN;
	menu.style.display = "block";


	var mBounds = this.getBounds(menu);
	var menuHeight = mBounds.height;
	var menuTop = mBounds.top;

	if(menuHeight + menuTop > wh - WINDOW_GUTTER) {
		//menu does not fit downwards - check if it fits upwards
		if((bounds.top - menuHeight) > WINDOW_GUTTER) {
			//yes - it fits upwards
			menu.getElementsByTagName("table")[0].style.width = parseInt(bounds.width);
			menu.style.width = parseInt(bounds.width);	
			menu.getElementsByTagName("table")[0].className = this.getChoiceTableCssClass();				
		} else {
			/*
			* menu is too big to expand either up or down 
			* make it expand wherever ther is more space and make it scrollable
			*/
			if(bounds.top > ((wh - WINDOW_GUTTER*2)/2) ) {
				//expand upwards
				menu.style.height = parseInt(bounds.top) - WINDOW_GUTTER;												
				menu.style.top = WINDOW_GUTTER;
			} else {
				//expand downwards
				menu.style.top	= 	parseInt(menu.style.top)+2;				
				menu.style.height = wh-WINDOW_GUTTER-parseInt(menu.style.top);								
			}
			menu.style.width = parseInt(bounds.width)+2;					
			menu.style.overflow="auto";	
			menu.getElementsByTagName("table")[0].className = this.getChoiceScrollTableCssClass();
		} 
	} else {
		menu.getElementsByTagName("table")[0].style.width = parseInt(bounds.width);
		menu.style.width = parseInt(bounds.width);	
		menu.getElementsByTagName("table")[0].className = this.getChoiceTableCssClass();
	}
	menu.style.zIndex = 1000000;
	if (this.$hideListener == null) {
		this.$hideListener = new AjxListener(this, this.oMouseUp);
	}
	
	if (this.$outsideMouseDownListener == null) {
		this.$outsideMouseDownListener = new AjxListener(this, this.onOutsideMouseDown);
	}

	AjxCore.addListener(window, "onmouseup", this.$hideListener);
	AjxCore.addListener(document.body, "onmousedown", this.$outsideMouseDownListener);
	DwtEventManager.addListener(DwtEvent.ONMOUSEDOWN, this.$outsideMouseDownListener);	
	
}

OSelect1_XFormItem.prototype.hideMenu = function () {
	// hide the menu on a timer so we don't have to deal with wierd selection bugs
	setTimeout(this.getFormGlobalRef()+".getElement('" + this.getMenuElementId() + "').style.display = 'none'", 10);

	AjxCore.removeListener(window, "onmouseup", this.$hideListener);
	AjxCore.removeListener(document.body, "onmousedown", this.$outsideMouseDownListener);	
	DwtEventManager.removeListener(DwtEvent.ONMOUSEDOWN, this.$outsideMouseDownListener);
	
	if (AjxEnv.isIE && OSelect1_XFormItem._mouseWheelEventAttached) {
		var form = this.getForm();
		var formElement = form.getHtmlElement();
		if (formElement.detachEvent) {
			window.event.cancelBubble = true;
			formElement.detachEvent("onmousewheel", OSelect1_XFormItem._mouseWheelHideMenu);
			OSelect1_XFormItem._mouseWheelEventAttached = false;
			OSelect1_XFormItem._mouseWheelCurrentSelect = null;
		}
	}
}

OSelect1_XFormItem.prototype.oMouseUp = function (ev) {
	// hide the menu on a timer so we don't have to deal with wierd selection bugs
	ev = ev || window.event;
	var found = false;
    if (ev) {
		// figure out if we are over the menu that is up
		var htmlEl = DwtUiEvent.getTarget(ev);
	//	DBG.println(AjxDebug.DBG1, AjxBuffer.concat("oMouseUp; htmlEl.nodeName=",htmlEl.nodeName," htmlEl.localName = ", htmlEl.nodeName));
		//check if the user clicked on the scrollbar
			if(htmlEl.localName == "scrollbar" && ( (htmlEl.parentNode && htmlEl.parentNode.id=="___OSELECT_MENU___") || (htmlEl.id && htmlEl.id=="___OSELECT_MENU___"))) { 
				found = true;
			} else if (htmlEl.id && htmlEl.id == "___OSELECT_MENU___"){
				found = true;
			}
	}


	if(!found)
		this.hideMenu();
		
	return true;
}

OSelect1_XFormItem.prototype.onOutsideMouseDown = function (ev) {
	// hide the menu on a timer so we don't have to deal with wierd selection bugs
	ev = ev || window.event;
	var found = false;
    if (ev) {
		// figure out if we are over the menu that is up
		var htmlEl = DwtUiEvent.getTarget(ev);
		if(htmlEl && htmlEl.attributes && htmlEl.attributes.length) {
			var cnt = htmlEl.attributes.length;
			for(var i = 0; i < cnt; i++) {
				if(htmlEl.attributes[i].name == "itemnum") {
					this.onChoiceClick(htmlEl.attributes[i].value, ev);
					found = true;
					break;
				}
			}
		}
		if(!found) {
		//	DBG.println(AjxDebug.DBG1, AjxBuffer.concat("onOutsideMouseDown; htmlEl.nodeName=", htmlEl.nodeName," htmlEl.localName = ", htmlEl.localName, " htmlEl.id=", htmlEl.id));
			//check if the user clicked on the scrollbar
			if(htmlEl.localName == "scrollbar" && ( (htmlEl.parentNode && htmlEl.parentNode.id=="___OSELECT_MENU___") || (htmlEl.id && htmlEl.id=="___OSELECT_MENU___"))) { 
				found = true;
			} else if (htmlEl.id && htmlEl.id == "___OSELECT_MENU___"){
				found = true;
			}
		}
		
	}
	if(!found)
		this.hideMenu();
		
	return true;
}

OSelect1_XFormItem.prototype.getBounds = function(anElement, containerElement) {
	var myBounds = new Object();
	myBounds.left = 0;
	myBounds.top = 0;
	myBounds.width = anElement.offsetWidth;
	myBounds.height = anElement.offsetHeight;

	if(!containerElement) {
		containerElement = AjxEnv.isIE ? anElement.document.body : anElement.ownerDocument.body;
	}

	// account for the scrollbars if necessary
	var hasScroll = (anElement.scrollLeft !== void 0);
	var trace = anElement;

	while(trace != containerElement) {
		myBounds.left += trace.offsetLeft;
		myBounds.top += trace.offsetTop;

		var nextEl = trace.offsetParent;
		while (hasScroll && (trace != nextEl)) {
			myBounds.left -= trace.scrollLeft;
			myBounds.top -= trace.scrollTop;
			trace = AjxEnv.isIE ? nextEl : trace.parentNode;
		}
		trace = nextEl;
	}
	return myBounds;
};



// TAKE DIRECTLY FROM DWT_SELECT
OSelect1_XFormItem.prototype.onChoiceOver = function (itemNum, event) {
	if (this.__currentHiliteItem != null) this.dehiliteChoice(this.__currentHiliteItem);
	this.hiliteChoice(itemNum);
	this.__currentHiliteItem = itemNum;
}
OSelect1_XFormItem.prototype.onChoiceOut = function (itemNum, event) {
	if (this.__currentHiliteItem != null) this.dehiliteChoice(this.__currentHiliteItem);
	this.__currentHiliteItem = null;
}
OSelect1_XFormItem.prototype.onChoiceClick = function (itemNum, event) {
	this.choiceSelected(itemNum, false, event);
}

OSelect1_XFormItem.prototype.onChoiceDoubleClick = function (itemNum, event) {
	this.choiceSelected(itemNum, true, event);
}

OSelect1_XFormItem.prototype.onValueTyped = function(label, event) {
	var value = this.getChoiceValue(label);
	this.setValue(value, false, event);
}

OSelect1_XFormItem.prototype.choiceSelected = function (itemNum, clearOldValues, event) {
	this.onChoiceOut();
	this.hideMenu();
	var value = this.getNormalizedValues()[itemNum];
	this.setValue(value, clearOldValues, event);
}


OSelect1_XFormItem.prototype.setValue = function (newValue, clearOldValues, event) {
	var method = this.getElementChangedMethod();
	method.call(this, newValue, this.getInstanceValue(), event);
}

OSelect1_XFormItem.prototype.hiliteChoice = function (itemNum) {
	this.setChoiceCssClass(itemNum, this.getChoiceSelectedCssClass());
	if (this.getShowCheck() == true) {
		var els = this.getChoiceElements(itemNum);
		if (els) els[0].innerHTML = this.getCheckHTML();
	}
}

OSelect1_XFormItem.prototype.displayMouseOver = function () {
	if(!this._enabled)
		return;
}

OSelect1_XFormItem.prototype.displayMouseOut = function () {
	if(!this._enabled)
		return;
}

OSelect1_XFormItem.prototype.displayMouseDown = function () {
	if(!this._enabled)
		return;
}

OSelect1_XFormItem.prototype.dehiliteChoice = function(itemNum) {
	this.setChoiceCssClass(itemNum, this.getChoiceCssClass());
	if (this.getShowCheck() == true) {
		var els = this.getChoiceElements(itemNum);
		if (els) els[0].innerHTML = "&nbsp;";
	}
}


OSelect1_XFormItem.prototype.clearAllHilites = function () {
	for (var i = 0; i < this._normalizedValues.length; i++) {
		this.dehiliteChoice(i);
	}
}



OSelect1_XFormItem.prototype.setChoiceCssClass = function (itemNum, cssClass) {
	var els = this.getChoiceElements(itemNum);
	if (els) {
		els.className = cssClass;
/*		if (this.getShowCheck()) {
			els[0].className = cssClass + "_check";
			els[1].className = cssClass;
		} else {
			els[0].className = cssClass;
		}
*/		
	}
}

OSelect1_XFormItem.prototype.getArrowElement = function () {
	return this.getForm().getElement(this.getId() + "_arrow_button");
}

OSelect1_XFormItem.prototype.getDisplayElement = function () {
	return this.getElement(this.getId() + "_display");
}


OSelect1_XFormItem.prototype.getItemNumFromEvent = function (event) {
	var target = event.target || event.src;
	while (target) {
		if (target.id) {
			var itemNum = parseInt(target.id);
			if (isNaN(itemNum)) return -1;
			return itemNum;
		}
		target = target.parentNode;
	}
	return -1;
}

OSelect1_XFormItem.prototype.getChoiceElements = function (itemNum) {
	if (itemNum == null || itemNum == -1) return null;
	try {
//		return this.getForm().getElement(this.getId() + "_menu_table").rows[itemNum].getElementsByTagName("td");
		return this.getForm().getElement(this.getId() + "_menu_table").getElementsByTagName("div")[itemNum];
	} catch (e) {
		return null;
	}
}


/*OSelect1_XFormItem.prototype.outputHTML = function (HTMLoutput, updateScript, indent) {
	var id = this.getId();
	if (this.getWidth() == "auto") {
		var element = this.getElement("temp");
		var element = this.createElement("temp", null, "div", "MENU CONTENTS");
		element.style.left = -1000;
		element.style.top = -1000;
		element.className = this.getMenuCssClass();
		element.innerHTML = this.getChoicesHTML();
		this._width = element.offsetWidth+20;
		element.innerHTML = "";
	}

	HTMLoutput.append(indent,
		"<div id=", id, this.getCssString(),
			" onclick=\"", this.getFormGlobalRef(), ".getItemById('",this.getId(),"').showMenu(this, event)\"",
			" onselectstart=\"return false\"",
			">\r", indent,

			"  <table ", this.getTableCssString(), ">\r", indent,
				"  <tr><td width=100%><div id=", id, "_display class=", this.getDisplayCssClass(), ">VALUE</div></td>\r", indent,
					"    <td>", this.getArrowButtonHTML(),"</td>\r", indent,
				"  </tr>\r", indent,
			"  </table>\r", indent,
		"</div>\r"
	);
}*/

OSelect1_XFormItem.prototype.outputHTML = function (HTMLoutput, updateScript, indent) {
	var id = this.getId();
	var ref = this.getFormGlobalRef() + ".getItemById('"+ id + "')";	
	if (this.getWidth() == "auto") {
		var element = this.getElement("temp");
		var element = this.createElement("temp", null, "div", "MENU CONTENTS");
		element.style.left = -1000;
		element.style.top = -1000;
		element.className = this.getMenuCssClass();
		element.innerHTML = this.getChoicesHTML();
		this._width = element.offsetWidth+20;
		element.innerHTML = "";
	}

	if(this.getInheritedProperty("editable")) {
		HTMLoutput.append(indent,
			"<div id=", id, this.getCssString(),
				" onclick=\"", this.getFormGlobalRef(), ".getItemById('",this.getId(),"').showMenu(this, event)\"",
				" onselectstart=\"return false\"",
				">",
				"<table ", this.getTableCssString(), ">", 
					"<tr><td width=100%><input type=text id=", id, "_display class=", this.getDisplayCssClass(), " value='VALUE' ", 
					" onchange=\"",ref, ".onValueTyped(this.value, event||window.event)\"", (this.getInheritedProperty("editable") ? " readOnly=false " : " readOnly=true "),
					"></td>",
						"<td>", this.getArrowButtonHTML(),"</td>", 
					"</tr>", 
				"</table>", 
			"</div>"
		);
	} else {
		HTMLoutput.append(indent,
			"<div id=", id, this.getCssString(),
				" onclick=\"", this.getFormGlobalRef(), ".getItemById('",this.getId(),"').showMenu(this, event)\"",
				" onselectstart=\"return false\"",
				"><table ", this.getTableCssString(), ">",
					"<tr><td width=100%><div id=", id, "_display class=", this.getDisplayCssClass(), ">VALUE</div></td>",
						"<td>", this.getArrowButtonHTML(),"</td>", 
					"</tr>", indent,
				"</table>", indent,
			"</div>"
		);	
	}
}

OSelect1_XFormItem.prototype.getArrowButtonHTML = function () {
	var ref = this.getFormGlobalRef() + ".getItemById('"+ this.getId()+ "')";
	return AjxBuffer.concat("<div id=", this.getId(), "_arrow_button",
	 " onmouseover=\"", ref, ".displayMouseOver();\"",
 	 " onmouseout=\"", ref, ".displayMouseOut();\"",
 	 " onmousedown=\"", ref, ".displayMouseDown();\"", 	 
 	 ">", AjxImg.getImageHtml("SelectPullDownArrow"), "</div>");
//	return AjxImg.getImageHtml("SelectPullDownArrow", "", AjxBuffer.concat("id=",this.getId(), "_arrow_button"));
}

OSelect1_XFormItem.prototype.getTableCssClass = function () {
	return this.cssClass + "_table";
}
OSelect1_XFormItem.prototype.getDisplayCssClass = function () {
	return this.cssClass + "_display";
}

OSelect1_XFormItem.prototype.getMenuCssClass = function () {
	return this.cssClass + "_menu";
}
OSelect1_XFormItem.prototype.getChoiceTableCssClass = function () {
	return this.cssClass + "_choice_table";
}
OSelect1_XFormItem.prototype.getChoiceScrollTableCssClass = function () {
	return this.cssClass + "_choice_table_scrolled";
}

OSelect1_XFormItem.prototype.getChoiceCssClass = function () {
	return this.cssClass + "_choice";
}
OSelect1_XFormItem.prototype.getChoiceSelectedCssClass = function () {
	return this.cssClass + "_choice_selected";
}



OSelect1_XFormItem.prototype.outputChoicesHTMLStart = function(html, indent) {
	html.append(indent, "<table cellspacing=0 cellpadding=0 id=", this.getId(),"_menu_table class=", this.getChoiceTableCssClass(), ">\r");
	//html.append(indent, "<div width=100% style='overflow:visible;' id=", this.getId(),"_menu_table class=", this.getChoiceTableCssClass(), ">\r");
}
OSelect1_XFormItem.prototype.outputChoicesHTMLEnd = function(html, indent) {
	html.append(indent, "</table>\r");
	//html.append(indent, "</div>\r");
}

OSelect1_XFormItem.prototype.getChoiceHTML = function (itemNum, value, label, cssClass, indent) {
	var ref = this.getFormGlobalRef() + ".getItemById('"+ this.getId()+ "')";
	//try DIVs
	/*
	
	return AjxBuffer.concat(indent,
		"<div width=100% class=", cssClass, 
			" onmouseover=\"",ref, ".onChoiceOver(", itemNum,", event||window.event)\"",
			" onmouseout=\"",ref, ".onChoiceOut(", itemNum,", event||window.event)\"",
			" onclick=\"",ref, ".onChoiceClick(", itemNum,", event||window.event)\"",
			" itemnum = '", itemNum, "'",
		">",
				label,
		"</div>\r"
	);*/
	return AjxBuffer.concat("<tr><td><div class=", cssClass, 
			" onmouseover=\"",ref, ".onChoiceOver(", itemNum,", event||window.event)\"",
			" onmouseout=\"",ref, ".onChoiceOut(", itemNum,", event||window.event)\"",
			" onclick=\"",ref, ".onChoiceClick(", itemNum,", event||window.event)\"",
			" itemnum = '", itemNum, "'",">",label,	"</div></td></tr>");
	
}


// set up how disabling works for this item type
OSelect1_XFormItem.prototype.setElementEnabled = function(enabled) {
	this._enabled = enabled;
	var table = this.getForm().getElement(this.getId()).getElementsByTagName("table")[0];
	if(enabled) {
		this.getDisplayElement().className = this.getDisplayCssClass();
		AjxImg.setImage(this.getArrowElement(), "SelectPullDownArrow");
		this.getForm().getElement(this.getId()).className = this.cssClass;
		table.className = this.getTableCssClass();
	} else {
		this.getDisplayElement().className = this.getDisplayCssClass() + "_disabled";
		AjxImg.setImage(this.getArrowElement(), "SelectPullDownArrowDis");
		this.getForm().getElement(this.getId()).className = this.cssClass + "_disabled";
		table.className = this.getTableCssClass()+"_disabled";
	}
}

//
//	OSelect class -- lightning fast SELECT type widget
//
function OSelect_XFormItem() {}
XFormItemFactory.createItemType("_OSELECT_", "oselect", OSelect_XFormItem, OSelect1_XFormItem);
// override the default SELECT type
//XFormItemFactory.registerItemType("_SELECT_", "select", OSelect_XFormItem)

OSelect_XFormItem.prototype.focusable = false;
OSelect_XFormItem.prototype.multiple = true;
OSelect_XFormItem.prototype.writeElementDiv = true;
OSelect_XFormItem.prototype.overflow = "auto";
OSelect_XFormItem.prototype.cssStyle = "border:2px inset gray;";
OSelect_XFormItem.prototype.showCheck = false;

OSelect_XFormItem.prototype.outputHTML = function(html) {
	var it = this.getChoicesHTML();
	html.append(it);
}

OSelect_XFormItem.prototype.outputChoicesHTMLStart = function(html, indent) {
	html.append(indent, "<table id=", this.getId(),"_menu_table width=100% cellspacing=0 cellpadding=0>\r");
}
OSelect_XFormItem.prototype.outputChoicesHTMLEnd = function(html, indent) {
	html.append(indent, "</table>\r");
}


OSelect_XFormItem.prototype.getMenuElementId = function () {
	return this.getId();
}

OSelect_XFormItem.prototype.updateElement = function (values) {
	var element = this.getElement();
	element.innerHTML = this.getChoicesHTML();

	if (values == null) return;	
	if(this.getMultiple()) {
		if (typeof values == "string") values = values.split(",");
		for (var i = 0; i < values.length; i++) {
			var itemNum = this.getChoiceNum(values[i]);
			if (itemNum != -1) this.hiliteChoice(itemNum);
		}
	} else {
		var itemNum = this.getChoiceNum(values);
		if (itemNum != -1) this.hiliteChoice(itemNum);
	}
}

OSelect_XFormItem.prototype.onChoiceOver = function (itemNum) {}
OSelect_XFormItem.prototype.onChoiceOut = function (itemNum) {}

OSelect_XFormItem.prototype.onChoiceClick = function (itemNum, event) {
	event = event || window.event;
	var clearOthers = true;
	var includeIntermediates = false;
	//if (event.ctrlKey){
	if(this.getMultiple()) {
		clearOthers = false;
		if (event.shiftKey) {
			includeIntermediates = true;
		}
	}
	//} else if (event.shiftKey) {
	this.choiceSelected(itemNum, clearOthers, includeIntermediates, event);
};

OSelect_XFormItem.prototype.choiceSelected = function (itemNum, clearOldValues, includeIntermediates, event) {
	if (includeIntermediates){
		this._selectionCursor = itemNum;
		if (this._selectionAnchor == null) {
			this._selectionAnchor = itemNum;
		}
	} else {
		this._selectionAnchor = itemNum;
		this._selectionCursor = itemNum;
	}

	var value = this.getNormalizedValues()[itemNum];
	this.setValue(value, clearOldValues, includeIntermediates, event);
}

OSelect_XFormItem.prototype.setValue = function (newValue, clearOldValues, includeIntermediates, event) {
	var oldValues
	if (clearOldValues) {
		if(this.getMultiple()) {
			oldValues = [newValue];
		} else {
			oldValues = newValue;
		}
	} else {
		oldValues;
		if (includeIntermediates) {
			oldValues = [];
			var vals = this.getNormalizedValues();
			var start = this._selectionCursor;
			var dist = this._selectionAnchor - this._selectionCursor;
			if (dist < 0 ) {
				dist = this._selectionCursor - this._selectionAnchor;
				start = this._selectionAnchor;
			}
			for (var i = start; i <= start + dist; ++i) {
				oldValues.push(vals[i]);
			}
		} else {
			oldValues = this.getInstanceValue();

			if(oldValues) {
				if (typeof oldValues == "string") {
					if (oldValues == "") 	
						oldValues = [];
					else
						oldValues = oldValues.split(",");
				}
			} else {
				oldValues = new Array();			
			}			
			
			var found = false;
			for (var i = 0; i < oldValues.length; i++) {
				if (oldValues[i] == newValue) {
					found = true;
					break;
				}
			}
			
			if (found) {
				oldValues.splice(i, 1);
			} else {
				oldValues.push(newValue);
			}
		}
		if(!oldValues || (oldValues.length == 1 && oldValues[0] == "")) {
			oldValues = []
		} 
		// if we have a modelItem which is a LIST type
		//	convert the output to the propert outputType
		var modelItem = this.getModelItem();
		if (modelItem && modelItem.getOutputType) {
			if (modelItem.getOutputType() == _STRING_) {
				oldValues = oldValues.join(modelItem.getItemDelimiter());
			}
		} else {
			// otherwise assume we should convert it to a comma-separated string
			oldValues = oldValues.join(",");
		}
	}
	this.getForm().itemChanged(this, oldValues, event);
}






function OSelect_Check_XFormItem() {}
XFormItemFactory.createItemType("_OSELECT_CHECK_", "oselect_check", OSelect_Check_XFormItem, OSelect_XFormItem)

OSelect_Check_XFormItem.prototype.getChoiceHTML = function (itemNum, value, label, cssClass, indent) {
	var ref = this.getFormGlobalRef() + ".getItemById('"+ this.getId()+ "')";
	return AjxBuffer.concat(indent,
		"<tr><td class=", cssClass, 
			" onmouseover=\"",ref, ".onChoiceOver(", itemNum,", event||window.event)\"",
			" onmouseout=\"",ref, ".onChoiceOut(", itemNum,", event||window.event)\"",
			" onclick=\"",ref, ".onChoiceClick(", itemNum,", event||window.event)\"",
			" ondblclick=\"",ref, ".onChoiceDoubleClick(", itemNum,", event||window.event)\"",
		">",
		"<table cellspacing=0 cellpadding=0><tr><td><input type=checkbox></td><td>",
				label,
		"</td></tr></table></tr>\r"
	);
}

OSelect_Check_XFormItem.prototype.hiliteChoice = function (itemNum) {
	var el = this.getChoiceElements(itemNum)[0];
	el.className = this.getChoiceSelectedCssClass();
	
	var checks = el.getElementsByTagName("input");
	if (checks) {
		checks[0].checked = true;
	}
}

OSelect_Check_XFormItem.prototype.dehiliteChoice = function(itemNum) {
	var el = this.getChoiceElements(itemNum)[0];
	el.className = this.getChoiceCssClass();

	var checks = el.getElementsByTagName("input");
	if (checks) {
		checks[0].checked = false;
	}
}
/*
 * Copyright (C) 2006, The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
* @class ButtonGrid  example of putting a custom widget in a XForm
* @constructor
**/

function ButtonGrid(attributes) {
	XFG.assignUniqueId(this, "__BUTTON_GRID__");

	// copy any props passed in into the object
	for (var prop in attributes) {
		this[prop] = attributes[prop];
	}
	// handle any props that need special care
	if (this.onChange) this.setOnChange(this.onChange);

	// initialize to an empty array for value
	this.value = [];
	
	
}
var BGP = ButtonGrid.prototype;
BGP.choices = null;
BGP.numCols = 4;
BGP.cssClass = "xform_button_grid_medium";
BGP.onChange = null;
BGP.multiple = true;
BGP.addBracketingCells = false;

BGP.setOnChange = function (onChange) {
	if (onChange && typeof onChange == "string") {
		onChange = new Function("value, event", onChange);	
	}
	this.onChange = onChange;
}


BGP.getValue = function() {
	return this.value;
}

BGP.setValue = function(value) {
	if (value == null) value = [];
	if (typeof value == "string") value = value.split(",");
	this.value = value;
	
	this.showValue();
}

BGP.showValue = function() {
	var value = this.value;
	if (value == null) value = "";

	// assumes value is a comma-delimited string or an array
	if (typeof value == "string") value = value.split(",");
	
	// hack up value to make searching for a particular option value easier
	var uniqueStartStr = "{|[", uniqueEndStr = "]|}";
	value = uniqueStartStr + value.join(uniqueEndStr + uniqueStartStr) + uniqueEndStr;
	var choices = this.choices;
	for (var i = 0; i < choices.length; i++) {
		var element = XFG.getEl(this.getButtonId(i));
		var isPresent = (value.indexOf(uniqueStartStr + choices[i].value + uniqueEndStr) > -1);
		if (isPresent) {
			XFG.showSelected(element);
		} else {
			XFG.hideSelected(element);
		}
	}	
}

BGP.toggleValue = function(value, element) {
	if (this.multiple) {
		if (this.valueIsSelected(value)) {
			this.deselectValue(value, element);
		} else {
			this.selectValue(value, element);
		}
	} else {
		this.value = value;
	}
	return this.value;
}

BGP.valueIsSelected = function(value) {
	for (var i = 0; i < this.value.length; i++) {
		if (this.value[i] == value) return true;
	}
}

BGP.selectValue = function(value, element) {
	if (!this.valueIsSelected(value)) {
		this.value.push(value);
	}
	if (element) XFG.showSelected(element);
}

BGP.deselectValue = function(value, element) {
	if (this.valueIsSelected(value)) {
		for (var i = 0; i < this.value.length; i++) {
			if (this.value[i] == value) {
				this.value = this.value.slice(0, i).concat(this.value.slice(i+1, this.value.length));
			}
		}
	}
	if (element) XFG.hideSelected(element);
}

BGP.getButtonId = function (btnNum) {
	return this.__id + "_button_" + btnNum;
}


BGP.onButtonClick = function(choiceValue, element, event) {
	var newValue = this.toggleValue(choiceValue, element);
	if (this.onChange) {
		this.onChange(newValue, event);
	}
}

BGP.getHTML = function (indent) {
	if (this.choices == null) return (this.__HTMLOutput = null);

	var buffer = new AjxBuffer();
	if (indent == null) indent = "";
	
	// write HTML for this element
	var buttonCssClass = this.cssClass + "_button";
	buffer.append(indent, "<table class=\"", this.cssClass, "_table\">");
	var i = 0;
	var numRows = Math.ceil(this.choices.length / this.numCols);
	for (var r = 0; r < numRows; r++) {
		buffer.append("<tr>\r");
		if (this.addBracketingCells) {
			buffer.append("\t<td width=50%><div class=", this.cssClass + "_start></div></td>");
		}
		for (var c = 0; c < this.numCols; c++) {
			var choice = this.choices[i];
			if (typeof choice == "string") {
				choice = this.choices[i] = {value:choice, label:choice};
			}
			buffer.append(indent, "\t<td class=", this.cssClass + "_td ><div id=", this.getButtonId(i), " class=", buttonCssClass, //(this.valueIsSelected(choice.value) ? "_selected" : ""),
								" onclick=\"XFG.cacheGet('", this.__id, "').onButtonClick('",choice.value,"',this,event);\">", 
								choice.label,
						"</div></td>\r");
			i++;
			if (i >= this.choices.length) break;
		}
		if (this.addBracketingCells) {
			buffer.append("\t<td width=50%><div class=", this.cssClass + "_end></div></td>");
		}
		buffer.append(indent, "</tr>");
	}
	buffer.append("</table>");
	this.__HTMLOutput = buffer.toString();
	return this.__HTMLOutput;
}


BGP.insertIntoXForm = function (form, item, element) {
	element.innerHTML = this.getHTML();
}

BGP.updateChoicesHTML = function(labels) {
	var i = 0;
	for (var r = 0; r < numRows; r++) {
		for (var c = 0; c < this.numCols; c++) {
			var btn = document.getElementById(this.getButtonId(i));
			if(btn) {
				btn.innerHTML =labels[i].label;
			}
			i++;
			if (i >= labels.length) break;
		}
	}
}

BGP.updateInXForm = function (form, item, value, element) {
	var valueStr = (value instanceof Array ? value.join(",") : value);
	if (!form.forceUpdate && this.__lastDisplayValue == valueStr) return;
	
	this.setValue(value);
	this.__lastDisplayValue = valueStr;
}

